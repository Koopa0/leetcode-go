## 1. Original Problem

### English:
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

**Example 1:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**
```
Input: nums = [3,3], target = 6
Output: [0,1]
```

**Constraints:**
* 2 <= nums.length <= 10^4
* -10^9 <= nums[i] <= 10^9
* -10^9 <= target <= 10^9
* Only one valid answer exists.

### 繁體中文:
給定一個整數數組 `nums` 和一個整數目標值 `target`，請你在該數組中找出和為目標值 `target` 的那兩個整數，並返回它們的數組下標。

你可以假設每種輸入只會對應一個答案。但是，數組中同一個元素在答案裡不能重複出現。

你可以按任意順序返回答案。

**示例 1：**
```
輸入：nums = [2,7,11,15], target = 9
輸出：[0,1]
解釋：因為 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**
```
輸入：nums = [3,2,4], target = 6
輸出：[1,2]
```

**示例 3：**
```
輸入：nums = [3,3], target = 6
輸出：[0,1]
```

**約束條件：**
* 2 <= nums.length <= 10^4
* -10^9 <= nums[i] <= 10^9
* -10^9 <= target <= 10^9
* 只存在一個有效答案

## 2. 問題理解

這個問題要求在一個整數數組中找到兩個數字，使得它們的和等於給定的目標值，並返回這兩個數字的索引。

關鍵要點：
- 必須返回的是這兩個數字的**索引**，而不是數字本身
- 數組中的每個元素只能使用一次
- 每個輸入只有一個解
- 可以按任意順序返回答案

邊界情況：
- 數組的長度至少為2，所以不用考慮空數組或單元素數組
- 數字可以是負數，也可以是正數或零
- 可能有重複的數字，例如示例3中的[3,3]

主要挑戰：
- 如何高效地找到那兩個數字，而不是通過暴力枚舉所有可能的組合

## 3. 視覺解釋

讓我來通過視覺方式解釋這個問題的思路：

對於數組 [2, 7, 11, 15] 和目標值 9：

```
索引:  0   1   2   3
數值:  2   7  11  15
```

需要找到兩個加起來等於9的數字：

1. 暴力解法思路：
```
檢查 nums[0] + nums[1] = 2 + 7 = 9 ✓ 找到解！返回 [0, 1]
```

2. 雜湊表解法思路：
```
檢查 nums[0] = 2，需要 7 才能等於 9
  將 2 和索引 0 保存到雜湊表 {2: 0}
檢查 nums[1] = 7，需要 2 才能等於 9
  在雜湊表中找到了 2，返回 [0, 1] ✓
```

## 4. 思考過程

對於這個問題，可以考慮以下幾種解法：

### 方法一：暴力解法
最直觀的方法是使用兩層循環，枚舉所有可能的數字對，檢查它們的和是否等於目標值。
- 優點：容易理解和實現
- 缺點：時間複雜度為 O(n²)，對於大型數組效率較低

### 方法二：雜湊表（哈希表）
可以使用雜湊表來記錄已經遍歷過的數字及其索引，並在遍歷過程中檢查是否存在互補的數字：
- 對於每個數字 nums[i]，計算 target - nums[i]
- 如果這個差值已經在雜湊表中，說明找到了解
- 如果不存在，則將當前數字及其索引加入雜湊表
- 優點：時間複雜度為 O(n)，非常高效
- 缺點：需要額外的空間來存儲雜湊表

### 方法三：排序 + 雙指針
也可以先對數組排序，然後使用雙指針從兩端向中間移動：
- 優點：不需要額外空間（如果不考慮排序的空間消耗）
- 缺點：排序會改變原始索引，需要額外記錄，時間複雜度為 O(n log n)

比較：對於這個特定問題，由於需要返回原始索引，雜湊表方法是最優解。排序後會丟失原始索引信息，需要額外的工作來跟蹤，而暴力方法則效率太低。

## 5. 最優解決方案開發

讓從暴力解法開始，逐步改進到最優解：

### 暴力解法：
```go
// 暴力方法，時間複雜度 O(n²)
func twoSum(nums []int, target int) []int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for j := i+1; j < n; j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return nil  // 根據題目假設，這一行應該不會被執行
}
```

### 改進為雜湊表解法：
通過使用雜湊表，可以將時間複雜度從 O(n²) 降低到 O(n)：

1. 創建一個空的雜湊表，用於存儲已經訪問過的數字及其索引
2. 遍歷數組，對於每個數字 nums[i]：
    - 計算互補值 complement = target - nums[i]
    - 檢查 complement 是否在雜湊表中
    - 如果在，返回當前索引 i 和雜湊表中存儲的 complement 的索引
    - 如果不在，將當前數字及其索引加入雜湊表

讓通過一個具體的例子來說明：
```
nums = [2,7,11,15], target = 9
```

- 遍歷 nums[0] = 2：
    - complement = 9 - 2 = 7
    - 7 不在雜湊表中
    - 將 {2: 0} 加入雜湊表

- 遍歷 nums[1] = 7：
    - complement = 9 - 7 = 2
    - 2 在雜湊表中，對應索引為 0
    - 返回 [0, 1]

這種方法只需要遍歷數組一次，每次查詢和插入雜湊表的時間複雜度為 O(1)，因此總時間複雜度為 O(n)。

## 7. 複雜度分析

### 時間複雜度
- **最好情況**：O(1)，如果數組的前兩個數字就是解，那麼只需要一次操作
- **平均情況**：O(n)，在平均情況下，需要遍歷數組的一部分
- **最壞情況**：O(n)，需要遍歷整個數組才能找到解

對於雜湊表方法，在每次迭代中，進行的是常數時間的操作（查詢和插入雜湊表的時間複雜度為O(1)）。因此，整體時間複雜度取決於數組的大小，為 O(n)。

### 空間複雜度
- **空間複雜度**：O(n)，在最壞情況下，需要將所有數字都存入雜湊表

這種空間複雜度是不可避免的，因為需要記住已經遍歷過的數字，除非使用排序+雙指針的方法，但那種方法的時間複雜度更高（O(nlogn)）。

## 8. 優化與改進

雜湊表解法已經是這個問題的最優解，時間複雜度為 O(n)，這已經是遍歷數組所能達到的最低時間複雜度了。

可能的微小優化：
1. 提前檢查數組大小：如果數組長度小於2，可以直接返回空結果（但題目已保證數組長度至少為2）
2. 初始化雜湊表大小：如果知道數組的大小，可以預先分配適當大小的雜湊表，減少動態擴容的開銷

相關問題：
- 三數之和（3Sum）：找出數組中三個數使得它們的和為零
- 四數之和（4Sum）：找出數組中四個數使得它們的和為目標值
- 兩數之和 II - 輸入有序數組：如果輸入數組是有序的，可以使用雙指針方法


這個測試策略考慮了：
1. 基本功能測試：通過給定的示例驗證基本功能
2. 邊界測試：包括數組大小為2的情況和包含重複元素的情況
3. 特殊值測試：包括負數、零目標值的情況
4. 極限值測試：測試接近約束限制的大數值

由於題目保證每個輸入只有一個解，所以不需要測試無解的情況。

通過這些測試用例，可以全面驗證的解決方案的正確性和穩健性。

這個問題是算法面試中的經典問題，掌握這種使用雜湊表的方法對於解決類似的"找配對"問題非常有幫助。關鍵洞見是：可以通過空間換時間，用雜湊表記錄已經處理過的元素，從而將時間複雜度從 O(n²) 降低到 O(n)。