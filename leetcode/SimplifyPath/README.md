# LeetCode 71: Simplify Path (簡化路徑)

## 1. 問題定義

### Original Problem (English)
```
Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.

In a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (such as '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.

The canonical path should have the following format:
- The path starts with a single slash '/'.
- Any two directories are separated by a single slash '/'.
- The path does not end with a trailing '/'.
- The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')

Return the simplified canonical path.
```

### 問題翻譯（繁體中文）
```
給定一個字串 path，表示 Unix 風格檔案系統中的絕對路徑（以斜線 '/' 開頭），將其轉換為簡化的規範路徑。

在 Unix 風格的檔案系統中，一個句點 '.' 表示當前目錄，兩個句點 '..' 表示上一層目錄，任何多個連續的斜線（如 '//'）都被視為單個斜線 '/'。在本問題中，任何其他格式的句點（如 '...'）都被視為檔案/目錄名稱。

規範路徑應具有以下格式：
- 路徑以單個斜線 '/' 開頭。
- 任何兩個目錄之間用單個斜線 '/' 分隔。
- 路徑不以尾隨斜線 '/' 結尾。
- 路徑僅包含從根目錄到目標檔案或目錄的路徑上的目錄（即沒有句點 '.' 或雙句點 '..'）。

返回簡化後的規範路徑。
```

### 範例與約束條件
- **範例 1:**
  ```
  輸入: path = "/home/"
  輸出: "/home"
  說明: 注意，最後一個目錄名稱後面沒有斜線。
  ```
- **範例 2:**
  ```
  輸入: path = "/../"
  輸出: "/"
  說明: 從根目錄向上一級是不可行的，因此保持在根目錄。
  ```
- **範例 3:**
  ```
  輸入: path = "/home//foo/"
  輸出: "/home/foo"
  說明: 在規範路徑中，多個連續斜線會被替換為單個斜線。
  ```
- **範例 4:**
  ```
  輸入: path = "/a/./b/../../c/"
  輸出: "/c"
  ```

- **約束條件:**
    - 1 <= path.length <= 3000
    - path 由英文字母，數字，'.', '/' 或 '_' 組成
    - path 是一個有效的 Unix 風格的絕對路徑

## 2. 問題理解

### 初步反應與心智模型
- 這個問題本質上是在模擬 Unix 系統處理路徑的方式
- 我需要解析路徑字串，處理特殊字元（如 '.'、'..'）和多餘的斜線
- 可以把路徑視為由斜線分隔的目錄名稱序列
- 需要按照特定規則處理這些目錄名稱，最終生成一個標準化的路徑

### 問題分解
- 首先需要將路徑分割為目錄名稱序列
- 處理空目錄名稱（由連續斜線產生）
- 處理 '.' 目錄（當前目錄，可以直接忽略）
- 處理 '..' 目錄（上一層目錄，需要返回上一級）
- 最後將有效的目錄名稱組合成規範路徑

### 視覺表示
```
例如路徑 "/a/./b/../../c/"：

分割後：["", "a", ".", "b", "..", "..", "c", ""]
                    ↓
忽略空字串和 '.'：["a", "b", "..", "..", "c"]
                    ↓
處理 '..'：["a", "b"] → ["a"] → []，然後添加 "c"
                    ↓
最終為：["c"]
                    ↓
組合為："/c"
```

## 3. 模式識別與知識映射

### 算法模式分類
- [x] 字串操作/陣列操作
- [ ] 雙指針/滑動窗口
- [ ] 二分搜尋/二元答案
- [ ] 深度優先搜尋 (DFS)
- [ ] 廣度優先搜尋 (BFS)
- [ ] 回溯法
- [ ] 動態規劃 (DP)
- [ ] 貪婪算法
- [ ] 分治法
- [ ] 圖算法
- [ ] 樹問題
- [x] 堆疊/佇列
- [ ] 優先佇列/堆
- [ ] 雜湊表/集合
- [ ] 排序算法
- [ ] 位元操作
- [ ] 其他: ________

- 識別基礎:
    - 這個問題涉及路徑處理，需要處理前後相關的目錄名稱
    - 遇到 '..' 時需要回到上一層目錄，這種「後進先出」的特性很適合用堆疊來處理
    - 可以使用字串分割和組合操作來處理路徑字串

### 知識連結
- 這個問題涉及字串處理、堆疊資料結構和檔案系統路徑規則
- 堆疊的「後進先出」特性非常適合處理需要回溯的路徑問題
- 了解 Unix 風格檔案系統中路徑的規則是解決此問題的關鍵

### 相似問題比較
- LeetCode 388: Longest Absolute File Path（最長絕對檔案路徑）- 也是處理檔案路徑的問題
- LeetCode 65: Valid Number（有效數字）- 同樣涉及字串解析和狀態處理
- 這些問題都需要仔細處理字串並按照特定規則進行解析

## 4. 算法直覺發展

### 直覺建立
- 當我看到路徑處理問題時，我首先想到的是使用堆疊
- 堆疊可以很好地模擬目錄的進入和退出操作
- 將路徑按斜線分割後，可以逐個處理目錄名稱，遇到 '..' 時彈出堆疊頂部的元素

### 多角度思考
- 自頂向下 vs. 自底向上：這個問題適合自頂向下的方法，從頭開始處理路徑字串
- 迭代 vs. 遞迴：迭代方法更直觀，也更高效
- 基於狀態 vs. 基於轉換：基於轉換的視角更適合，我們將輸入路徑轉換為規範路徑

## 5. 解決方案開發歷程

### 方法 1: 暴力解法（使用堆疊）

#### 思考過程
- 最直接的方式是使用堆疊來跟踪目錄層次
- 我們可以先按斜線分割路徑，然後逐個處理目錄名稱
- 對於普通目錄名稱，將其推入堆疊
- 對於 '.'，不做任何操作
- 對於 '..'，彈出堆疊頂部的元素（如果堆疊不為空）
- 最後將堆疊中的元素組合成規範路徑

#### 算法設計
```
1. 將路徑按 '/' 分割成目錄名稱陣列
2. 創建一個空堆疊用於存儲有效的目錄名稱
3. 遍歷目錄名稱陣列：
   a. 如果是空字串或 '.'，跳過
   b. 如果是 '..'，且堆疊不為空，彈出堆疊頂部元素
   c. 如果是其他目錄名稱，將其推入堆疊
4. 使用 '/' 連接堆疊中的所有目錄名稱，在前面加上 '/'
5. 如果結果為空，返回 '/'
```

#### 實作細節
- 使用 Go 的 `strings.Split` 函數來分割路徑字串
- 使用切片作為堆疊，通過 `append` 添加元素，通過切片操作移除元素
- 使用 `strings.Join` 函數將堆疊中的目錄名稱組合成最終路徑

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是路徑的長度。我們需要遍歷整個路徑一次。
- **空間複雜度**: O(n)，在最壞情況下，堆疊可能需要存儲接近 n 個字元（當路徑中沒有 '.' 或 '..' 時）。

#### 解法評估
- 優點：直觀易懂，實作簡單
- 缺點：沒有特別的缺點，這個解法已經很高效了
- 這個解法在面試中是完全可接受的，它清晰地展示了問題解決思路

### 方法 2: 優化解法（簡化實作）

#### 關鍵洞察
- 前一個解法已經很高效，但我們可以進一步優化程式碼的簡潔性
- 我們可以使用更精簡的條件判斷來處理不同類型的目錄名稱

#### 優化策略
```
基本策略與暴力解法相同，但使用更精簡的程式碼和更高效的數據處理
```

#### 實作改進
- 使用 `switch` 語句使代碼更加簡潔清晰
- 明確處理空堆疊的邊界情況
- 整體邏輯更加清晰，易於閱讀和理解

#### 複雜度分析
- **時間複雜度**: O(n)，與暴力解法相同
- **空間複雜度**: O(n)，與暴力解法相同

#### 解法評估
- 這個優化解法與暴力解法在效率上基本相同
- 主要改進在於程式碼的簡潔性和可讀性
- 在面試中，這種簡潔的實作方式會給面試官留下更好的印象

### 方法 3: 最佳解法（進一步優化）

#### 突破性思考
- 基本算法已經很高效，進一步優化可以從邊界情況和小細節入手
- 可以在分割路徑時就移除連續的斜線，減少後續處理的工作量

#### 最佳算法
```
1. 使用更高效的方式處理路徑分割
2. 更精確地處理邊界情況
3. 確保程式碼的簡潔性和效率
```

#### 實作卓越性
- 使用單次遍歷完成路徑處理，避免了額外的字串分割操作
- 巧妙處理路徑結尾，確保算法的一致性
- 更直接地構建最終路徑，減少中間步驟

#### 複雜度分析
- **時間複雜度**: O(n)，實際上可能比前面的方法稍快，因為避免了額外的字串分割
- **空間複雜度**: O(n)，與前面的方法相同

#### 從暴力到最佳的思維演進
- 從基本的堆疊方法開始，我們逐步改進了實作的簡潔性和效率
- 每一步優化都關注於特定的問題：首先是基本算法，然後是代碼簡潔性，最後是處理細節
- 這種漸進式的改進展示了如何從一個基本的解法逐步演進到最佳解法
- 這種思維模式可以應用於其他問題：先確保基本解法正確，然後關注實作細節和效率

## 6. 使用 Go 實作的實例演示

### 完整示例追蹤
追蹤範例輸入："/a/./b/../../c/" 使用最佳解法：

1. 初始狀態：
    - 輸入：`"/a/./b/../../c/"`
    - 添加尾部斜線（已有）
    - 堆疊 `stack` = []

2. 遍歷路徑：
    - 找到 '/'，提取目錄 "a"
    - 將 "a" 推入堆疊
    - 堆疊 `stack` = ["a"]

3. 繼續遍歷：
    - 找到 '/'，提取目錄 "."
    - 跳過 "."
    - 堆疊 `stack` = ["a"]

4. 繼續遍歷：
    - 找到 '/'，提取目錄 "b"
    - 將 "b" 推入堆疊
    - 堆疊 `stack` = ["a", "b"]

5. 繼續遍歷：
    - 找到 '/'，提取目錄 ".."
    - 彈出堆疊頂部元素 "b"
    - 堆疊 `stack` = ["a"]

6. 繼續遍歷：
    - 找到 '/'，提取目錄 ".."
    - 彈出堆疊頂部元素 "a"
    - 堆疊 `stack` = []

7. 繼續遍歷：
    - 找到 '/'，提取目錄 "c"
    - 將 "c" 推入堆疊
    - 堆疊 `stack` = ["c"]

8. 最終狀態：
    - 組合路徑："/" + "c" = "/c"
    - 輸出：`"/c"`

### 所有方法的效能比較
```
| 方法             | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|-----------------|------------|-----------|------------|
| 暴力解法（堆疊）  | O(n)       | O(n)      | 0 ms       |
| 優化解法         | O(n)       | O(n)      | 0 ms       |
| 最佳解法         | O(n)       | O(n)      | 0 ms       |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我們的解法遵循了 Go 的慣用方式，使用切片作為堆疊
- 使用 Go 標準庫中的 `strings` 包處理字串操作
- 程式碼簡潔、清晰，易於理解和維護

### 錯誤處理與邊界情況
- 我們處理了各種邊界情況，如空路徑、僅有根目錄的路徑等
- 確保了遇到 '..' 時不會超出根目錄
- 實作考慮了所有可能的輸入情況，使解法更加穩健

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初步解法提出：~5 分鐘
- 優化討論：~5-7 分鐘
- 代碼編寫：~10-15 分鐘
- 測試與調試：~5 分鐘

### 面試官互動模擬
- 我會首先解釋問題的本質：簡化 Unix 風格的檔案路徑
- 然後說明我的解法策略：使用堆疊來處理目錄層次
- 接著分析時間和空間複雜度，並說明為什麼這個方法是高效的
- 最後討論可能的邊界情況和錯誤處理

潛在問題和引導：
- 面試官可能會問：「如果路徑中包含非法字元怎麼辦？」
    - 回答：根據問題約束，路徑只包含英文字母、數字、'.', '/' 或 '_'。如果需要處理非法字元，可以添加驗證步驟。
- 「你能解釋一下為什麼選擇堆疊而不是其他資料結構？」
    - 回答：堆疊的「後進先出」特性正好符合處理目錄層次的需求，特別是處理 '..' 時需要返回上一層目錄。

### 潛在後續問題
- 如果輸入規模大幅增加，如何修改你的 Go 代碼？
    - 現有算法已經是 O(n) 的時間複雜度，這是理論上的最優解。但可以考慮使用緩衝區處理非常長的路徑。
- 如果記憶體受限，你會應用哪些 Go 特定的優化？
    - 可以使用字符串生成器（strings.Builder）而不是直接連接字符串，減少內存分配。
- 如何擴展你的解法以處理相關但更複雜的問題，如相對路徑？
    - 需要添加對相對路徑的支持，特別是處理不以 '/' 開頭的路徑，可能需要結合當前目錄來解析。

## 9. 知識整合與學習

### 問題解決洞察
- 這個問題教會了我使用堆疊處理路徑結構的技巧
- 深入理解了 Go 中字串處理和切片操作的使用
- 需要進一步加強的領域：更深入了解 Go 的性能優化技巧

### 心智模型構建
- 從這個問題中，我學到了處理層次結構資料的通用框架
- 這種框架可以應用於其他類似的問題，如表達式解析、XML/HTML 標籤匹配等
- 將這種經驗內化為直覺，有助於快速識別使用堆疊解決的問題模式

### 錯誤模式識別
- 在實作過程中需要注意的常見錯誤：
    - 忘記處理空路徑或僅有根目錄的邊界情況
    - 忘記檢查堆疊是否為空就進行彈出操作
    - 字串處理的索引錯誤
- 這些錯誤提醒我在實作時需要更加細心，並加強對邊界情況的考慮

### 知識圖譜擴展
- 相關 Go 編程資源：
    - Go 官方文檔中關於字串處理的部分
    - Go 標準庫中堆疊和佇列的實作方式
- 進階 Go 模式和技巧：
    - 使用 `strings.Builder` 提升字串操作效率
    - Go 1.18+ 中的泛型實作堆疊