# LeetCode 97: 交錯字串 (Interleaving String)

## 1. 問題定義

### 原始問題 (英文)
```
Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that:
- s = s1 + s2 + ... + sn
- t = t1 + t2 + ... + tm
- |n - m| <= 1
- The interleaving is s1 + t1 + s2 + t2 + ... or t1 + s1 + t2 + s2 + ...

Note: a + b is the concatenation of strings a and b.
```

### 問題翻譯 (繁體中文)
```
給定字串 s1、s2 和 s3，判斷 s3 是否由 s1 和 s2 交錯組成。

兩個字串 s 和 t 的交錯是一種配置，其中 s 和 t 分別被分成 n 個和 m 個子字串，使得：
- s = s1 + s2 + ... + sn
- t = t1 + t2 + ... + tm
- |n - m| <= 1
- 交錯的結果是 s1 + t1 + s2 + t2 + ... 或 t1 + s1 + t2 + s2 + ...

注意：a + b 是字串 a 和 b 的連接。
```

### 範例與約束
- **範例 1:**
  ```
  輸入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
  輸出: true
  解釋: s3 可以由 s1 = "aabcc" 和 s2 = "dbbca" 交錯組成
  ```
- **範例 2:**
  ```
  輸入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
  輸出: false
  解釋: s3 不能由 s1 = "aabcc" 和 s2 = "dbbca" 交錯組成
  ```
- **範例 3:**
  ```
  輸入: s1 = "", s2 = "", s3 = ""
  輸出: true
  解釋: 兩個空字串的交錯結果也是空字串
  ```

- **約束:**
    - 0 <= s1.length, s2.length <= 100
    - 0 <= s3.length <= 200
    - s1、s2 和 s3 由小寫英文字母組成

## 2. 問題理解

### 初始反應與心智模型
- 第一反應：這是一個字串匹配問題，可能需要使用動態規劃或遞迴來解決
- 我可以將範例視為：在 s3 中的每個位置，我們需要決定是從 s1 還是 s2 中取字
- 輸入是兩個字串 s1 和 s2，輸出是一個布林值，表示 s3 是否可以由 s1 和 s2 交錯組成
- 我可以想像成兩個指針分別在 s1 和 s2 上移動，我們需要決定在每一步選擇哪個指針前進

### 問題分解
- 核心子問題：在 s3 的每個位置，我們需要決定從 s1 或 s2 中取下一個字
- 基本操作：比較字、移動指針、做出選擇
- 邊緣情況：任一字串為空的情況
- 我可以將問題分解為：是否存在一種方式，讓 s1 和 s2 的字按特定順序組合成 s3

### 視覺表示
```
例如 s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"

s1: a a b c c
    ↑   ↑   ↑
    |   |   |
s3: a a d b b c b c a c
        ↑ ↑ ↑   ↑ ↑
        | | |   | |
s2:     d b b c a
```
- 這個視覺化幫助我理解，每次我們從 s1 或 s2 中取一個字添加到結果中，直到形成 s3
- 從這個模型中，我可以看出需要在每個位置做出選擇，這可能導致需要回溯或使用動態規劃

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [ ] 數組/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜索/二分答案
    - [X] 深度優先搜索 (DFS)
    - [ ] 廣度優先搜索 (BFS)
    - [X] 回溯
    - [X] 動態規劃 (DP)
    - [ ] 貪心算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 棧/隊列
    - [ ] 優先隊列/堆
    - [ ] 哈希映射/集合
    - [ ] 排序算法
    - [ ] 位操作
    - [ ] 其他: ________

- 識別依據：
    - 問題要求判斷是否存在一種組合方式，這種"存在性"問題通常可以用DFS或DP解決
    - 需要在每個位置做出選擇（從s1取字或從s2取字），並且這些選擇會影響後續的選擇，這符合DP或回溯的特徵
    - 類似的字串匹配問題通常可以用動態規劃高效解決

### 知識連接
- 涉及的基本CS概念：字串操作、動態規劃、狀態轉移、記憶化搜索
- 這個問題與子序列和字串匹配問題相關，如最長公共子序列(LCS)
- 需要應用的理論知識：動態規劃中的狀態定義和轉移方程

### 類似問題比較
- LeetCode 72: 編輯距離 (Edit Distance) - 需要判斷兩個字串的相似性
- LeetCode 115: 不同的子序列 (Distinct Subsequences) - 涉及到字串匹配
- LeetCode 10: 正則表達式匹配 (Regular Expression Matching) - 同樣使用DP解決字串匹配問題
- 差異在於本題需要考慮兩個源字串如何交錯組成目標字串

## 4. 算法直覺發展

### 直覺建立
- 直覺上，我們可以嘗試從s1和s2中逐個選擇字來組成s3
- 如果s3的長度不等於s1和s2的長度之和，那麼一定不可能由它們交錯組成
- 當我們在選擇時，如果當前s1和s2的字都可以匹配s3的下一個字，則需要嘗試兩種可能性

### 多角度思考
- 自頂向下思考：使用遞迴+記憶化搜索，從頭開始選擇字
- 自底向上思考：使用迭代方式填充動態規劃表格
- 狀態轉移視角：定義DP[i][j]表示s1的前i個字和s2的前j個字是否能交錯組成s3的前i+j個字

## 5. 解決方案開發過程

### 方法1：暴力解法（遞迴回溯）

#### 思考過程
- 最直接的方法是使用遞迴回溯
- 從s1和s2的開頭開始，嘗試所有可能的選擇
- 如果當前s1或s2的字匹配s3的下一個字，我們可以選擇它並繼續

#### 算法設計
```
遞迴函數 isInterleave(s1, i, s2, j, s3, k):
    如果 i = s1的長度 且 j = s2的長度 且 k = s3的長度:
        返回 true（所有字都匹配完成）
    
    如果 k = s3的長度:
        返回 false（s3已經遍歷完，但s1或s2還有剩餘）
    
    result = false
    
    如果 i < s1的長度 且 s1[i] = s3[k]:
        result = result 或 isInterleave(s1, i+1, s2, j, s3, k+1)
    
    如果 j < s2的長度 且 s2[j] = s3[k]:
        result = result 或 isInterleave(s1, i, s2, j+1, s3, k+1)
    
    返回 result
```

#### 實現細節
- 使用Go的閉包函數作為遞迴幫助器
- 在每個步驟中，我們嘗試從s1或s2中選擇下一個字
- 如果兩個選擇都不匹配，則不可能形成交錯

#### 複雜度分析
- **時間複雜度**: O(2^(m+n)) — 最壞情況下，每一步都有兩種選擇，可能需要嘗試所有可能的組合
- **空間複雜度**: O(m+n) — 遞迴調用棧的深度，其中m和n分別是s1和s2的長度

#### 解法評估
- 優點：簡單直觀，容易理解
- 缺點：存在大量重複計算，時間複雜度高，對於較長的字串可能會導致超時
- 在面試環境中，這是一個合理的起點，但需要進一步優化

### 方法2：優化解法（記憶化遞迴）

#### 關鍵見解
- 暴力解法中存在大量重複計算，我們可以使用記憶化技術避免重複工作
- 關鍵洞察：如果我們已經知道 s1 的前 i 個字和 s2 的前 j 個字能否交錯形成 s3 的前 i+j 個字，就不需要重複計算

#### 優化策略
```
使用記憶化數組 memo[i][j]，表示 s1 的前 i 個字和 s2 的前 j 個字是否能交錯形成 s3 的前 i+j 個字：
- -1 表示尚未計算
- 0 表示不能交錯
- 1 表示能交錯
```

#### 實現改進
- 使用二維記憶化數組避免重複計算
- 每個狀態只計算一次，大大減少了計算量
- 維持了遞迴解法的思路，但顯著提高了效率

#### 複雜度分析
- **時間複雜度**: O(m*n) — 每個狀態 (i,j) 只計算一次，總共有 m*n 個可能的狀態
- **空間複雜度**: O(m*n) — 記憶化數組的大小，以及遞迴調用棧的深度

#### 解法評估
- 優點：顯著改善了暴力解法的效率，避免重複計算
- 缺點：仍然使用遞迴，可能在極端情況下導致棧溢出
- 在面試中，這展示了你能識別並解決效率問題的能力

### 方法3：最優解法（動態規劃）

#### 突破性思考
- 最優解法是使用動態規劃的自底向上方法
- 關鍵洞察：我們可以定義 dp[i][j] 表示 s1 的前 i 個字和 s2 的前 j 個字是否能交錯形成 s3 的前 i+j 個字
- 這完全消除了遞迴調用，進一步提高了效率

#### 最優算法
```
1. 創建一個二維DP表格 dp[m+1][n+1]，其中 m 和 n 分別是 s1 和 s2 的長度
2. dp[i][j] 表示 s1 的前 i 個字和 s2 的前 j 個字是否能交錯形成 s3 的前 i+j 個字
3. 初始化：dp[0][0] = true（兩個空字串可以交錯形成空字串）
4. 狀態轉移：
   - 如果 s1[i-1] == s3[i+j-1]，則 dp[i][j] = dp[i][j] || dp[i-1][j]
   - 如果 s2[j-1] == s3[i+j-1]，則 dp[i][j] = dp[i][j] || dp[i][j-1]
5. 最終結果：dp[m][n]
```

#### 實現卓越性
- 使用自底向上的動態規劃方法完全消除了遞迴
- 使用二維布林數組來存儲中間結果
- 代碼結構清晰，狀態轉移邏輯易於理解

#### 複雜度分析
- **時間複雜度**: O(m*n) — 填充整個DP表格需要的時間
- **空間複雜度**: O(m*n) — DP表格的大小

#### 從暴力到最優的思考演變
- 暴力解法：嘗試所有可能的選擇，但存在大量重複計算
- 記憶化解法：保持遞迴結構，但使用記憶化避免重複計算
- 動態規劃解法：完全消除遞迴，自底向上構建解決方案
- 這種思考模式可以應用於其他字串匹配和動態規劃問題

## 6. 使用Go實現的完整示例演練

### 完整示例追蹤
追蹤範例輸入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"，使用我們的最優解法：

1. 初始狀態：
    - 創建一個 (len(s1)+1) x (len(s2)+1) 的DP表格
    - dp[0][0] = true（兩個空字串可以交錯形成空字串）

2. 初始化第一行和第一列：
    - dp[1][0] = true（"a" 可以形成 "a"）
    - dp[2][0] = true（"aa" 可以形成 "aa"）
    - dp[3][0] = false（"aab" 不能形成 "aad"）
    - ...
    - dp[0][1] = true（"d" 可以形成 "d"）
    - dp[0][2] = false（"db" 不能形成 "aa"）
    - ...

3. 填充表格（部分關鍵步驟）：
    - dp[1][1] = true（"a" + "d" 可以交錯形成 "ad"）
    - dp[2][1] = true（"aa" + "d" 可以交錯形成 "aad"）
    - dp[2][2] = true（"aa" + "db" 可以交錯形成 "aadb"）
    - ...
    - dp[3][2] = true（"aab" + "db" 可以交錯形成 "aadbb"）
    - ...

4. 最終狀態：
    - dp[5][5] = true，表示 "aabcc" 和 "dbbca" 可以交錯形成 "aadbbcbcac"

### 所有方法的性能比較
```
| 方法           | 時間複雜度    | 空間複雜度    | 範例執行時間   |
|---------------|-------------|-------------|--------------|
| 暴力解法       | O(2^(m+n))  | O(m+n)      | >> 1000 ms   |
| 記憶化解法     | O(m*n)      | O(m*n)      | ~5-10 ms     |
| 動態規劃       | O(m*n)      | O(m*n)      | ~2-5 ms      |
```

## 7. Go最佳實踐與測試

### Go慣用解法
- 我的解決方案遵循了Go的最佳實踐，包括明確的變數命名和清晰的代碼結構
- 使用了Go的閉包函數來實現遞迴和記憶化
- 使用二維切片來實現動態規劃表格，這是處理此類問題的標準方法

### 錯誤處理與邊緣情況
- 在所有解法中，我們首先檢查了s3的長度是否等於s1和s2的長度之和，這是一個重要的提前退出條件
- 處理了空字串的特殊情況
- 使用清晰的邊界檢查避免索引越界

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3分鐘
- 初始解法提案：~5分鐘
- 優化討論：~5-7分鐘
- 代碼編寫：~10-15分鐘
- 測試與調試：~5分鐘

### 面試官互動模擬
- 如何向面試官解釋我的Go實現：
  "我首先檢查s3的長度是否等於s1和s2的長度之和。然後，我使用動態規劃方法，創建一個二維表格，其中dp[i][j]表示s1的前i個字和s2的前j個字是否能交錯形成s3的前i+j個字。我從空字串開始，逐步填充表格，考慮從s1或s2取字的兩種可能性。"

- 可能的提示和引導問題：
    - 如果不使用dp，你如何解決這個問題？
    - 你如何將空間複雜度優化到O(min(m,n))？
    - 如果s3非常長，有沒有更有效的方法？

### 潛在的後續問題
- 如果輸入規模顯著增加，你如何修改你的Go代碼？
- 如果記憶受限，你會如何應用Go特定的優化？
- 如何將你的解決方案擴展到處理相關但更複雜的問題，例如判斷k個字串是否可以交錯？

## 9. 知識整合與學習

### 問題解決見解
- 這個問題教會了我如何在Go中高效實現動態規劃算法
- 我更深入地理解了如何在Go中使用閉包和二維切片
- 我需要進一步加強Go中對記憶化遞迴的實現技巧

### 心智模型構建
- 我從這個問題中抽象出的解決框架是：首先嘗試暴力解法，識別重複子問題，然後應用記憶化或動態規劃
- 這個框架可以應用於其他字串匹配和動態規劃問題
- 將這種經驗內化為直覺，可以幫助我在未來更快地識別和解決類似問題

### 錯誤模式識別
- 在實現過程中，我可能在處理字串索引時出錯，特別是當涉及到dp[i][j]和s3[i+j-1]之間的關係
- 這揭示了我在Go中處理字串索引時的盲點
- 通過更仔細地追蹤示例和使用單元測試，我可以避免類似錯誤