# LeetCode 64: 最小路徑和 (Minimum Path Sum)

## 1. 問題定義

### 原始問題 (英文)
```
Given a m x n grid filled with non-negative integers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.
```

### 問題翻譯 (繁體中文)
```
給定一個填滿非負整數的 m x n 網格，找出一條從左上角到右下角的路徑，使得路徑上所有數字總和最小。

注意：你每次只能向下或向右移動。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: grid = [[1,3,1],[1,5,1],[4,2,1]]
  輸出: 7
  解釋: 因為路徑 1→3→1→1→1 的總和最小。
  ```
- **範例 2:**
  ```
  輸入: grid = [[1,2,3],[4,5,6]]
  輸出: 12
  ```

- **限制條件:**
    - m == grid.length
    - n == grid[i].length
    - 1 <= m, n <= 200
    - 0 <= grid[i][j] <= 100

## 2. 問題理解

### 初始反應與心智模型
- 這是一個經典的路徑問題，需要找到從起點到終點的最小代價路徑。
- 由於每次只能向下或向右移動，所以路徑的選擇是有限的。
- 初步感覺這是一個動態規劃問題，因為我們需要考慮到達每個格子的最小累計和。

### 問題分解
- 核心子問題：如何確定到達每個格子的最小路徑和？
- 我們需要對網格中的每個位置，判斷是從上方還是從左方到達當前位置的路徑和更小。
- 邊界情況：特別注意第一行和第一列的處理，因為它們只有一種到達方式。

### 視覺表示
```
以範例 1 為例，網格 [[1,3,1],[1,5,1],[4,2,1]]

原始網格:
1 3 1
1 5 1
4 2 1

到達每個位置的最小路徑和:
1 4 5
2 7 6
6 8 7
```
- 這個視覺化幫助我們理解在每個位置，最小路徑和是如何累積計算的。
- 我們可以看到，最終右下角的值 7 正是所需的最小路徑和。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式:
    - [x] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 深度優先搜索 (DFS)
    - [ ] 廣度優先搜索 (BFS)

- 識別基礎:
    - 問題具有明顯的重疊子問題特性，即到達某個格子的最小路徑和依賴於到達其上方和左方格子的最小路徑和。
    - 問題要求一個全局最優解（最小路徑和），而非局部最優解。

### 知識連接
- 這個問題與最短路徑演算法（如 Dijkstra）有關，但因路徑限制（只能向下或向右），簡化為動態規劃問題。
- 核心理論是動態規劃中的狀態轉移方程式，用於表示當前狀態與之前狀態的關係。

### 相似問題比較
- LeetCode 62: Unique Paths (不同路徑) - 計算從左上到右下的不同路徑數量。
- LeetCode 63: Unique Paths II (不同路徑 II) - 在有障礙物的情況下計算路徑數量。
- LeetCode 120: Triangle (三角形) - 找出三角形從頂到底的最小路徑和。

## 4. 演算法直覺發展

### 直覺建立
- 如果只能向下或向右移動，那麼到達任何一個格子，只有兩種可能的前一步：從上方或從左方。
- 要最小化總和，應該選擇從這兩個方向來的路徑中總和較小的那一個。
- 這自然導向一個動態規劃解法，我們可以建立一個二維數組來保存到達每個位置的最小路徑和。

### 多重視角
- 自頂向下與自底向上：
    - 自頂向下：使用遞迴加記憶化，從終點開始思考問題。
    - 自底向上：迭代建立動態規劃表格，從起點開始填充。
- 這個問題使用自底向上的迭代方法更加直觀和高效。

## 5. 解法發展歷程

### 方法 1: 暴力遞迴解法

#### 思考過程
- 最直觀的方式是使用遞迴探索所有可能的路徑。
- 從起點 (0,0) 開始，每次可以選擇向右或向下移動。
- 遞迴終止條件是到達終點 (m-1, n-1)。

#### 演算法設計
```
function minPathSum(grid, i, j):
    if i == m-1 and j == n-1:  // 到達終點
        return grid[i][j]
    
    if i == m-1:  // 最後一列，只能向右移動
        return grid[i][j] + minPathSum(grid, i, j+1)
    
    if j == n-1:  // 最後一行，只能向下移動
        return grid[i][j] + minPathSum(grid, i+1, j)
    
    // 可以向右或向下移動，選擇路徑和較小的方向
    return grid[i][j] + min(minPathSum(grid, i+1, j), minPathSum(grid, i, j+1))
```

#### 實作細節
- 使用遞迴解決問題，透過分解為更小的子問題處理。
- 考慮了邊界情況（最後一行和最後一列）。
- 使用輔助函數 `min` 取得兩個值的較小值。

#### 複雜度分析
- **時間複雜度**: O(2^(m+n)) — 每個位置有兩種選擇（向右或向下），路徑長度為 m+n-2，所以時間複雜度為 O(2^(m+n-2))，簡化為 O(2^(m+n))。
- **空間複雜度**: O(m+n) — 遞迴調用堆疊深度最大為 m+n-1，簡化為 O(m+n)。

#### 解法評估
- 這個解法非常直觀，但效率極低，因為存在大量重複計算。
- 對於較大的網格，會導致超時。
- 在面試中，應該只作為起點，迅速進行優化。

### 方法 2: 記憶化遞迴解法

#### 關鍵洞察
- 暴力遞迴解法中存在大量重疊子問題，即多次計算同一個位置的最小路徑和。
- 使用記憶化技術（緩存已計算過的結果）可以顯著減少重複計算。

#### 優化策略
```
使用一個二維數組 memo 來存儲已計算過的結果：
memo[i][j] 表示從位置 (i,j) 到達終點的最小路徑和。

首先檢查 memo[i][j] 是否已有值，若有則直接返回。
否則，計算並存儲結果。
```

#### 實作改進
- 使用 `memo` 二維陣列儲存已計算過的結果，避免重複計算。
- 在計算之前，先檢查 `memo` 是否已有該位置的值。
- 使用 -1 作為初始值，表示該位置尚未計算。

#### 複雜度分析
- **時間複雜度**: O(m*n) — 每個格子只計算一次，總共有 m*n 個格子。
- **空間複雜度**: O(m*n) — 使用 m*n 大小的記憶化數組，加上遞迴調用堆疊 O(m+n)，主導項為 O(m*n)。

#### 解法評估
- 這個解法顯著改進了暴力解法的效率，消除了重複計算。
- 記憶化技術保留了遞迴思路的清晰性，同時解決了效率問題。
- 在中等大小的網格上表現良好，但遞迴仍然帶來一定的開銷。

### 方法 3: 動態規劃解法（最優解）

#### 突破性思考
- 我們可以完全避免遞迴，使用自底向上的動態規劃。
- 創建一個 DP 表格，dp[i][j] 表示從起點 (0,0) 到達位置 (i,j) 的最小路徑和。
- 使用以下狀態轉移方程：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

#### 最佳演算法
```
1. 創建一個與 grid 相同大小的 dp 數組。
2. 初始化 dp[0][0] = grid[0][0]。
3. 填充第一行：dp[0][j] = dp[0][j-1] + grid[0][j]，j > 0
4. 填充第一列：dp[i][0] = dp[i-1][0] + grid[i][0]，i > 0
5. 填充其餘位置：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
6. 返回 dp[m-1][n-1]。
```

#### 實作卓越性
- 這個實作完全迭代，避免了遞迴帶來的額外開銷。
- 清晰地處理了邊界情況（第一行和第一列）。
- 使用動態規劃表格有效儲存和重用中間結果。

#### 複雜度分析
- **時間複雜度**: O(m*n) — 需要填充 m*n 個 DP 表格的單元格。
- **空間複雜度**: O(m*n) — 使用 m*n 大小的 DP 表格。

#### 從暴力到最優的思考演進
- 暴力解法：自然的遞迴思路，但有大量重複計算。
- 記憶化解法：保留遞迴思路，同時消除重複計算。
- 動態規劃解法：完全迭代，自底向上構建解，避免遞迴開銷。
- 思考模式從「我該如何遞迴探索所有路徑」演進到「我可以重用已計算的結果」再到「我可以用表格系統地構建解」。

### 方法 4: 空間優化的動態規劃解法

#### 關鍵優化
- 觀察發現，計算當前行時，只需要用到上一行的結果和當前行的前一列結果。
- 可以將空間優化至 O(n)，只使用一個一維數組

#### 複雜度分析
- **時間複雜度**: O(m*n) — 仍需遍歷整個網格。
- **空間複雜度**: O(n) — 只使用一個長度為 n 的一維數組。

## 6. 範例演示

### 詳細範例追蹤
追蹤範例輸入：grid = [[1,3,1],[1,5,1],[4,2,1]] 使用我們的最優解法：

1. 初始狀態：
    - 網格: [[1,3,1],[1,5,1],[4,2,1]]
    - dp: [[0,0,0],[0,0,0],[0,0,0]]

2. 初始化：
    - dp[0][0] = grid[0][0] = 1
    - dp: [[1,0,0],[0,0,0],[0,0,0]]

3. 填充第一行：
    - dp[0][1] = dp[0][0] + grid[0][1] = 1 + 3 = 4
    - dp[0][2] = dp[0][1] + grid[0][2] = 4 + 1 = 5
    - dp: [[1,4,5],[0,0,0],[0,0,0]]

4. 填充第一列：
    - dp[1][0] = dp[0][0] + grid[1][0] = 1 + 1 = 2
    - dp[2][0] = dp[1][0] + grid[2][0] = 2 + 4 = 6
    - dp: [[1,4,5],[2,0,0],[6,0,0]]

5. 填充剩餘位置：
    - dp[1][1] = grid[1][1] + min(dp[0][1], dp[1][0]) = 5 + min(4, 2) = 5 + 2 = 7
    - dp[1][2] = grid[1][2] + min(dp[0][2], dp[1][1]) = 1 + min(5, 7) = 1 + 5 = 6
    - dp[2][1] = grid[2][1] + min(dp[1][1], dp[2][0]) = 2 + min(7, 6) = 2 + 6 = 8
    - dp[2][2] = grid[2][2] + min(dp[1][2], dp[2][1]) = 1 + min(6, 8) = 1 + 6 = 7
    - dp: [[1,4,5],[2,7,6],[6,8,7]]

6. 最終結果：
    - dp[2][2] = 7

### 所有方法的性能比較
```
| 方法              | 時間複雜度     | 空間複雜度   | 範例執行時間   |
|-------------------|-------------|-------------|--------------|
| 暴力遞迴           | O(2^(m+n))   | O(m+n)      | 過長 (TLE)   |
| 記憶化遞迴         | O(m*n)       | O(m*n)      | ~10ms        |
| 動態規劃           | O(m*n)       | O(m*n)      | ~5ms         |
| 空間優化動態規劃    | O(m*n)       | O(n)        | ~5ms         |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 以上實作遵循 Go 的慣用寫法，如使用多重賦值初始化多個變數。
- 函數命名清晰明確，如 `minPathSum`、`min` 等。
- 使用循環和迭代而非 Go 不那麼常用的遞迴，優化性能。

### 錯誤處理與邊界情況
- 檢查 grid 是否為空。
- 對第一行和第一列進行特殊處理，避免索引越界。
- 在計算最小值時使用 `min` 輔助函數

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2-3 分鐘
- 初始解法提案: ~5 分鐘
- 優化討論: ~5-7 分鐘
- 程式碼撰寫: ~10-15 分鐘
- 測試與除錯: ~5 分鐘

### 面試官互動模擬
- 可能的解釋：「這是一個典型的二維動態規劃問題，我會先建立 DP 表格，並遵循狀態轉移方程 dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])。對於第一行和第一列，由於只有一種到達方式，需要特別處理...」
- 面試官可能問：「你能解釋為什麼這個問題適合用動態規劃而非其他方法嗎？」
- 回應：「這個問題具有明顯的重疊子問題和最優子結構。每個位置的最小路徑和依賴於其上方和左方格子的最小路徑和，這種依賴關係使得動態規劃非常適合。貪婪法不適用，因為局部最優不一定導致全局最優...」

### 可能的後續問題
- 如果網格非常大，以至於無法將整個 DP 表格存儲在記憶體中，你如何調整你的解法？
- 如果不只能向右和向下移動，而是可以向所有四個方向移動，你如何修改你的算法？
- 如果網格中有障礙物（無法通過的格子），你如何調整你的解法？

## 9. 知識整合與學習

### 問題解決洞察
- 這個問題強化了動態規劃的核心思想：將問題分解為子問題，並重用子問題的解。
- 空間優化技巧展示了如何從 O(m*n) 空間降至 O(n)，這在記憶體受限的情境下很重要。

### 心智模型建構
- 解決路徑問題的框架：識別移動限制，確定狀態定義，建立狀態轉移方程。
- 這種模式可以應用到網格中其他路徑問題，如最長路徑、唯一路徑數量等。

### 錯誤模式識別
- 初學者常見錯誤：忽略邊界條件（第一行和第一列）。
- 優化相關錯誤：直接嘗試空間優化而沒有先理解基本動態規劃解法。

### 知識圖譜擴展
- 相關 Go 資源：《Go 語言圖解演算法》
- 延伸閱讀：《演算法導論》中的動態規劃章節
- 類似問題：其他格子路徑問題，如「不同路徑」、「帶有障礙物的路徑」等