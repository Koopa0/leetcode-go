# LeetCode 72：編輯距離（Edit Distance）

## 1. 問題定義

### 原始問題（英文）
```
Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

You have the following three operations permitted on a word:
- Insert a character
- Delete a character
- Replace a character
```

### 問題翻譯（繁體中文）
```
給定兩個字串 word1 和 word2，請返回將 word1 轉換為 word2 所需的最少操作數。

你可以對一個字串進行以下三種操作：
- 插入一個字元
- 刪除一個字元
- 替換一個字元
```

### 範例與限制條件
- **範例 1：**
  ```
  輸入：word1 = "horse", word2 = "ros"
  輸出：3
  解釋：
  horse -> rorse (將 'h' 替換為 'r')
  rorse -> rose (刪除 'r')
  rose -> ros (刪除 'e')
  ```
- **範例 2：**
  ```
  輸入：word1 = "intention", word2 = "execution"
  輸出：5
  解釋：
  intention -> inention (刪除 't')
  inention -> enention (將 'i' 替換為 'e')
  enention -> exention (將 'n' 替換為 'x')
  exention -> exection (將 'n' 替換為 'c')
  exection -> execution (插入 'u')
  ```

- **限制條件：**
    - 0 ≤ word1.length, word2.length ≤ 500
    - word1 和 word2 由小寫英文字母組成

## 2. 問題理解

### 初步反應與心智建模
- 這是一個經典的字串編輯距離問題，也被稱為 Levenshtein 距離
- 我需要找出將一個字串轉換為另一個字串所需的最少操作次數
- 看起來這是一個需要優化決策的問題，每一步都有多種可能的操作選擇
- 我的第一反應是這可能需要用動態規劃來解決，因為它涉及到最優子結構

### 問題分解
- 核心問題：在每個字元位置，決定是插入、刪除還是替換，以最小化總操作數
- 如果兩個字元相同，則不需要任何操作
- 如果不同，則需要決定採取哪種操作是最優的
- 需要考慮所有可能的轉換路徑，找出最短的一條

### 視覺表示
```
問題可視化（以 "horse" 到 "ros" 為例）：

     | "" | r  | o  | s  |
-----|----|----|----|----|
 ""  | 0  | 1  | 2  | 3  |
-----|----|----|----|----|
 h   | 1  | 1  | 2  | 3  |
-----|----|----|----|----|
 o   | 2  | 2  | 1  | 2  |
-----|----|----|----|----|
 r   | 3  | 2  | 2  | 2  |
-----|----|----|----|----|
 s   | 4  | 3  | 3  | 2  |
-----|----|----|----|----|
 e   | 5  | 4  | 4  | 3  |
-----|----|----|----|----|
```
- 這個表格展示了從空字串開始，逐步構建第一個字串到第二個字串的轉換過程
- 每個單元格代表從 word1 的前 i 個字元轉換到 word2 的前 j 個字元所需的最小操作數
- 右下角的值就是最終答案

## 3. 模式識別與知識映射

### 演算法模式分類
- [x] 動態規劃 (DP)
- [ ] 陣列/字串操作
- [ ] 雙指針/滑動窗口
- [ ] 二分搜尋/二分答案
- [ ] 深度優先搜尋 (DFS)
- [ ] 廣度優先搜尋 (BFS)
- [ ] 回溯法
- [ ] 貪婪演算法
- [ ] 分治法
- [ ] 圖演算法
- [ ] 樹問題
- [ ] 堆疊/佇列
- [ ] 優先佇列/堆
- [ ] 雜湊表/集合
- [ ] 排序演算法
- [ ] 位元操作
- [ ] 其他: ________

- 識別依據:
    - 問題涉及到尋找最少操作數，這通常是最優化問題
    - 我們可以將問題分解為重疊的子問題（計算子字串之間的編輯距離）
    - 子問題的解決方案可以被重複使用來解決更大的問題

### 知識連結
- 這個問題是字串處理中的基礎問題之一
- 它與序列比對、DNA比對、拼字檢查、自然語言處理等領域有關
- 它屬於編輯距離家族問題，使用動態規劃解決

### 相似問題比較
- LeetCode 161: One Edit Distance (判斷兩個字串是否只相差一個編輯操作)
- LeetCode 583: Delete Operation for Two Strings (只允許刪除操作)
- LeetCode 712: Minimum ASCII Delete Sum for Two Strings (刪除操作有不同的成本)
- 這些問題都涉及到字串的編輯操作，但有不同的限制或成本模型

## 4. 演算法直覺發展

### 直覺建立
- 想像我們在比較兩個字串的每一個字元
- 當字元相同時，我們不需要做任何操作，直接進入下一對字元的比較
- 當字元不同時，我們有三種選擇（插入、刪除、替換），需要選擇使總操作數最少的一種
- 直覺上，這種「在每一步選擇最優解」的問題適合用動態規劃解決

### 多角度思考
- 從頭到尾處理 vs 從尾到頭處理：這個問題是對稱的，可以從任一方向處理
- 遞迴 vs 迭代：雖然可以用遞迴思考，但實際實現通常使用迭代方式以避免堆疊溢出
- 自頂向下（記憶化搜尋）vs 自底向上（表格填充）：兩種方法都可行，但自底向上通常更高效

## 5. 解決方案發展歷程

### 方法一：暴力解法（遞迴）

#### 思考過程
- 最直觀的方法是使用遞迴
- 對於每對字元，我們可以嘗試所有可能的操作，然後選擇成本最低的一個
- 這是一個窮舉方法，但會有大量重複計算

#### 演算法設計
```
編輯距離(s1, s2, i, j):
    # 基本情況
    如果 i == 0: 返回 j  # 需要 j 次插入操作
    如果 j == 0: 返回 i  # 需要 i 次刪除操作
    
    # 如果字元相同，不需要操作
    如果 s1[i-1] == s2[j-1]:
        return 編輯距離(s1, s2, i-1, j-1)
    
    # 否則，選擇成本最低的操作（插入、刪除或替換）
    return 1 + min(
        編輯距離(s1, s2, i, j-1),    # 插入
        編輯距離(s1, s2, i-1, j),    # 刪除
        編輯距離(s1, s2, i-1, j-1)   # 替換
    )
```

#### Go 實作
```go
// 暴力解法 - 遞迴
func minDistanceRecursive(word1 string, word2 string) int {
    return editDistRecursive(word1, word2, len(word1), len(word2))
}

func editDistRecursive(s1 string, s2 string, m int, n int) int {
    // 基本情況
    if m == 0 {
        return n // 如果第一個字串為空，需要 n 次插入操作
    }
    if n == 0 {
        return m // 如果第二個字串為空，需要 m 次刪除操作
    }
    
    // 如果最後一個字元相同，不需要額外操作
    if s1[m-1] == s2[n-1] {
        return editDistRecursive(s1, s2, m-1, n-1)
    }
    
    // 否則，取三種操作中的最小值
    // 1. 插入：將字元插入到 s1
    // 2. 刪除：從 s1 刪除字元
    // 3. 替換：將 s1 中的字元替換為 s2 中的字元
    insert := editDistRecursive(s1, s2, m, n-1)
    delete := editDistRecursive(s1, s2, m-1, n)
    replace := editDistRecursive(s1, s2, m-1, n-1)
    
    return 1 + min(insert, min(delete, replace))
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 實作細節
- 使用遞迴函數來實現編輯距離計算
- 基本情況處理兩個字串其中之一為空的情況
- 遞迴地比較字元，並在需要時選擇最佳操作
- 使用輔助函數 min() 來找出最小值

#### 複雜度分析
- **時間複雜度**: O(3^(m+n)) — 因為每一步都有三種可能的選擇，遞迴樹的深度為 m+n
- **空間複雜度**: O(m+n) — 由於遞迴調用棧的深度

#### 解決方案評估
- 優點：直觀，容易理解
- 缺點：效率極低，有大量重複計算，不適用於長字串
- 在實際面試中不太可能被接受，除非作為思考的起點

### 方法二：優化解法（記憶化遞迴）

#### 關鍵洞察
- 暴力遞迴中有大量重複計算
- 我們可以使用記憶化技術（備忘錄）來避免重複計算
- 將已計算的結果存儲在表格中，需要時直接查找

#### 優化策略
```
建立一個 m+1 x n+1 的表格 memo
如果 memo[i][j] 已計算，直接返回
否則計算 memo[i][j] 並存儲結果
```

#### 實作改進
- 使用二維陣列作為備忘錄儲存已計算的子問題結果
- 每次計算前先檢查備忘錄中是否已有結果
- 保持遞迴結構，但大幅減少重複計算

#### 複雜度分析
- **時間複雜度**: O(m*n) — 每個子問題只計算一次，總共有 m*n 個不同的子問題
- **空間複雜度**: O(m*n) — 備忘錄的大小，加上遞迴棧的深度 O(m+n)

#### 解決方案評估
- 優點：顯著提升了執行效率，避免了重複計算
- 缺點：仍然使用遞迴，對於非常大的輸入可能會有堆疊溢出的風險
- 在實際面試中可以接受，展示了對動態規劃問題的理解

### 方法三：最佳解法（動態規劃 - 自底向上）

#### 突破性思考
- 捨棄遞迴，改用迭代方式自底向上填表
- 完全消除遞迴調用棧的開銷
- 直接在表格中構建解決方案

#### 最佳演算法
```
建立一個 (m+1) x (n+1) 的表格 dp
初始化第一行和第一列
對於每個單元格 dp[i][j]，計算：
    如果 s1[i-1] == s2[j-1]，則 dp[i][j] = dp[i-1][j-1]
    否則，dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
返回 dp[m][n]
```

#### 實作優點
- 完全迭代的方法，沒有遞迴調用的開銷
- 按照依賴關係順序填表，確保每個子問題在需要時已解決
- 程式碼簡潔，易於理解和實現

#### 複雜度分析
- **時間複雜度**: O(m*n) — 需要填充 m*n 大小的表格
- **空間複雜度**: O(m*n) — 需要 m*n 大小的表格來儲存中間結果

#### 從暴力到最佳的思考演進
- 暴力解法：直接根據問題定義進行遞迴，但效率極低
- 記憶化：認識到有重複計算，使用備忘錄避免重複
- 動態規劃：完全改變解決方式，自底向上構建解決方案，消除遞迴開銷
- 這種演進展示了對問題理解的深化和演算法優化的過程

## 6. 使用 Go 實作的範例演練

### 完整範例追蹤
以輸入 word1 = "horse", word2 = "ros" 為例追蹤最佳解法：

1. 初始狀態：
    - 初始化 dp 表格（6x4 大小）
    - 填充第一行：`dp[0][0...3] = [0, 1, 2, 3]`
    - 填充第一列：`dp[0...5][0] = [0, 1, 2, 3, 4, 5]`

2. 填充表格：
    - 比較 'h' 和 'r'：不相等，dp[1][1] = 1 + min(1, 1, 0) = 1
    - 比較 'h' 和 'o'：不相等，dp[1][2] = 1 + min(2, 1, 1) = 2
    - 繼續填充...

3. 最終表格：
   ```
        | "" | r  | o  | s  |
   -----|----|----|----|----|
    ""  | 0  | 1  | 2  | 3  |
   -----|----|----|----|----|
    h   | 1  | 1  | 2  | 3  |
   -----|----|----|----|----|
    o   | 2  | 2  | 1  | 2  |
   -----|----|----|----|----|
    r   | 3  | 2  | 2  | 2  |
   -----|----|----|----|----|
    s   | 4  | 3  | 3  | 2  |
   -----|----|----|----|----|
    e   | 5  | 4  | 4  | 3  |
   -----|----|----|----|----|
   ```

4. 最終結果：
    - dp[5][3] = 3，即將 "horse" 轉換為 "ros" 需要 3 步操作

### 所有方法的效能比較
```
| 方法            | 時間複雜度     | 空間複雜度    | 範例執行時間    |
|-----------------|----------------|---------------|-----------------|
| 暴力遞迴        | O(3^(m+n))     | O(m+n)        | > 1000 ms       |
| 記憶化遞迴      | O(m*n)         | O(m*n)        | ~10 ms          |
| 動態規劃        | O(m*n)         | O(m*n)        | ~5 ms           |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我們使用切片來實現二維表格，這是 Go 中常見的做法
- 使用了輔助函數 min() 來提高程式碼的可讀性
- 避免使用全域變數，保持函數的獨立性和可測試性

### 錯誤處理與邊緣情況
- 我們處理了一個或兩個字串為空的情況
- 程式碼不需要特殊的錯誤處理，因為所有操作都在合法範圍內
- 對於非常長的字串，我們的解決方案在時間和空間上都是高效的

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初步解法提案：~5 分鐘（從暴力解法開始）
- 優化討論：~5-7 分鐘（解釋記憶化和動態規劃的優化）
- 程式碼撰寫：~10 分鐘（專注於動態規劃解法）
- 測試與偵錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的解決方案：
  "這是一個經典的編輯距離問題，我們可以使用動態規劃來解決。核心思想是建立一個表格，記錄從 word1 的前 i 個字元轉換到 word2 的前 j 個字元所需的最少操作數。在填表過程中，我們考慮當前字元是否相同，以及三種可能的操作（插入、刪除、替換）。"

- 可能的提示和引導問題：
    - "如何處理字元相同的情況？"
    - "為什麼我們需要比較三種操作？"
    - "如何優化此算法的空間複雜度？"

### 潛在的後續問題
- 如果輸入規模大幅增加，如何優化你的 Go 程式碼？
    - 回答：可以考慮使用空間優化的版本，只保留兩行 DP 表格，將空間複雜度降至 O(n)

- 如果記憶體受限，如何修改你的解決方案？
    - 回答：可以只保留前一行和當前行的數據，將空間複雜度從 O(m*n) 降至 O(min(m,n))

- 如果問題擴展到允許更多種類的操作（例如交換相鄰字元），如何修改算法？
    - 回答：需要增加新的狀態轉移方程，考慮新操作的成本

## 9. 知識整合與學習

### 問題解決洞察
- 編輯距離問題是動態規劃的經典應用
- 它教會我如何將複雜問題分解為子問題，並建立狀態轉移方程
- 這種自底向上構建解決方案的思路適用於許多其他動態規劃問題

### 心智模型構建
- 動態規劃問題的一般框架：
    1. 定義狀態（通常是一個表格）
    2. 找出基本情況（初始值）
    3. 建立狀態轉移方程
    4. 按正確順序計算所有狀態
    5. 從最終狀態得出答案

### 錯誤模式識別
- 在實作過程中容易忽略基本情況的處理
- 初始化 DP 表格時可能出錯
- 狀態轉移方程可能考慮不全面

### 知識圖譜擴展
- 相關資源：
    - 《動態規劃精講》
    - 《算法導論》中的編輯距離章節
    - Go 中的記憶體管理和性能優化