# LeetCode 58: 最後一個單詞的長度 (Length of Last Word)

## 1. 問題定義

### 原始問題 (英文)
```
Given a string s consists of words and spaces, return the length of the last word in the string.

A word is a maximal substring consisting of non-space characters only.

Example 1:
Input: s = "Hello World"
Output: 5
Explanation: The last word is "World" with length 5.

Example 2:
Input: s = "   fly me   to   the moon  "
Output: 4
Explanation: The last word is "moon" with length 4.

Example 3:
Input: s = "luffy is still joyboy"
Output: 6
Explanation: The last word is "joyboy" with length 6.

Constraints:
- 1 <= s.length <= 10^4
- s consists of only English letters and spaces ' '.
- There will be at least one word in s.
```

### 問題翻譯 (繁體中文)
```
給定一個由單詞和空格組成的字串 s，返回字串中最後一個單詞的長度。

單詞是由非空格字元組成的最大子字串。

範例 1:
輸入: s = "Hello World"
輸出: 5
解釋: 最後一個單詞是 "World"，長度為 5。

範例 2:
輸入: s = "   fly me   to   the moon  "
輸出: 4
解釋: 最後一個單詞是 "moon"，長度為 4。

範例 3:
輸入: s = "luffy is still joyboy"
輸出: 6
解釋: 最後一個單詞是 "joyboy"，長度為 6。

限制條件:
- 1 <= s.length <= 10^4
- s 只由英文字母和空格 ' ' 組成。
- s 中至少包含一個單詞。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: s = "Hello World"
  輸出: 5
  解釋: 最後一個單詞是 "World"，長度為 5。
  ```
- **範例 2:**
  ```
  輸入: s = "   fly me   to   the moon  "
  輸出: 4
  解釋: 最後一個單詞是 "moon"，長度為 4。
  ```
- **範例 3:**
  ```
  輸入: s = "luffy is still joyboy"
  輸出: 6
  解釋: 最後一個單詞是 "joyboy"，長度為 6。
  ```

- **限制條件:**
    - 1 <= s.length <= 10^4
    - s 只由英文字母和空格 ' ' 組成
    - s 中至少包含一個單詞

## 2. 問題理解

### 初始反應與心智建模
- 第一反應：這是一個簡單的字串處理問題，需要找到最後一個單詞並計算其長度。
- 範例解讀：需要處理的是不同格式的字串，包括前後可能有空格，單詞間可能有多個空格。
- 輸入輸出關係：輸入是一個字串，輸出是一個整數（最後一個單詞的長度）。
- 視覺化：可以將字串視為一個序列，需要從尾部開始找到第一個非空格字元，然後繼續向前計數直到遇到空格或字串開頭。

### 問題分解
- 核心子問題：如何找到最後一個單詞的起始和結束位置。
- 必要操作：遍歷字串，識別單詞與空格的邊界。
- 邊界情況：字串尾部有空格；字串只有一個單詞；字串中有多個連續空格。
- 問題分解：
    1. 處理字串尾部的空格
    2. 識別最後一個單詞的結束位置
    3. 識別最後一個單詞的起始位置
    4. 計算長度

### 視覺表示
```
例如 "Hello World  "：
索引：0 1 2 3 4 5 6 7 8 9 10 11
字元：H e l l o   W o r l d  
                  ^         ^
                起始位置    結束位置(不包含尾部空格)
               
最後一個單詞：W o r l d
長度：5
```

- 視覺化幫助：這種可視化顯示了我們需要找到最後一個非空格字元作為最後一個單詞的結束位置，然後向前找到第一個空格或字串開頭作為起始位置。
- 洞察：可以從字串尾部向前遍歷，先跳過尾部空格，然後計數字母，直到遇到另一個空格。

## 3. 模式識別與知識映射

### 演算法模式分類
- 此問題屬於以下常見演算法模式：
    - [X] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖論演算法
    - [ ] 樹相關問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他：________

- 識別基礎：
    - 問題要求處理字串並計算特定子字串的長度，這是典型的字串操作問題。
    - 不需要複雜的資料結構或演算法，主要是字元層次的處理。

### 知識連結
- 涉及的基本資訊科學概念：字串處理、迭代、條件判斷。
- 相關的其他演算法：字串分割（split）、字串剪裁（trim）等。
- 需要應用的理論知識：字串索引和遍歷。

### 相似問題比較
- LeetCode 14: 最長共同前綴 (Longest Common Prefix)
- LeetCode 151: 反轉字串中的單詞 (Reverse Words in a String)
- 相似之處：都涉及字串單詞的處理。
- 差異：本題只需找到並計算最後一個單詞的長度，而不需要操作多個單詞。

## 4. 演算法直覺發展

### 直覺建立
- 現實世界類比：就像在一段文字中找到最後一個有意義的詞並計算其長度。
- 初始直覺：從後向前遍歷字串，找到第一個非空格字元後，繼續計數直到遇到空格或達到字串開頭。
- 驗證方法：可以透過模擬幾個例子來驗證這種方法的正確性。

### 多角度思考
- 不同的角度：
    - 從後往前遍歷 vs. 從前往後遍歷
    - 使用內建函數 vs. 手動實現
    - 字串分割後取最後元素 vs. 直接找最後一個單詞
- 最有前途的角度：從後往前遍歷最為直接，因為我們只關心最後一個單詞。

## 5. 解決方案開發歷程

### 方法 1：暴力解法 - 分割字串

#### 思考過程
- 最直接的方法是使用語言提供的字串分割功能。
- 先將字串按空格分割成單詞陣列，然後返回最後一個非空單詞的長度。
- 這種方法簡單明瞭，但可能不是最高效的，因為它需要處理整個字串。

#### 演算法設計
```
1. 使用空格將字串分割成一個單詞陣列
2. 過濾掉空字串（由連續空格產生）
3. 返回最後一個單詞的長度
```

#### 實作細節
- 使用 Go 的 `strings.Fields()` 函數，它會自動處理連續的空格並返回非空字串的切片。
- 這種方法利用了 Go 的標準庫，程式碼簡潔易懂。
- 潛在陷阱：確保理解 `strings.Fields()` 的行為，它會自動處理前後空格和連續空格。

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是字串長度。需要遍歷整個字串來進行分割。
- **空間複雜度**：O(n)，最壞情況下需要存儲整個字串的所有單詞。

#### 解法評估
- 優勢：簡單直觀，使用內建函數，容易實現。
- 劣勢：使用了額外的空間來存儲所有單詞，處理了不必要的資訊（我們只關心最後一個單詞）。
- 面試評價：可接受但不是最優解，面試官可能會要求優化。

### 方法 2：優化解法 - 從後向前遍歷

#### 關鍵洞察
- 暴力解法處理了整個字串，但我們只需要最後一個單詞的長度。
- 從字串尾部開始處理可以更高效，因為一旦找到最後一個單詞，就可以立即返回結果。
- 不需要分割整個字串或存儲所有單詞。

#### 優化策略
```
1. 從字串的尾部開始向前遍歷
2. 跳過尾部的空格
3. 計數非空格字元直到遇到空格或字串開頭
4. 返回計數值
```

#### 實作改進
- 不使用額外的資料結構來存儲單詞。
- 只進行一次遍歷，並且可能在找到最後一個單詞後提前結束。
- 直接使用索引操作，避免了字串分割的開銷。

#### 複雜度分析
- **時間複雜度**：O(n)，最壞情況下仍需遍歷整個字串。但平均情況下會更快，因為找到最後一個單詞後就可以停止。
- **空間複雜度**：O(1)，只使用常數額外空間。

#### 解法評估
- 優化效果：減少了不必要的處理，只專注於最後一個單詞。
- 適用條件：這種優化在字串很長但最後一個單詞靠近尾部時特別有效。
- 優缺權衡：時間複雜度相同，但空間複雜度顯著改善。

### 方法 3：最佳解法 - 單次遍歷的改進版

#### 突破性思考
- 我們可以更緊湊地寫出從後向前遍歷的邏輯。
- 關鍵洞察：問題本質上仍然是從後向前遍歷，但我們可以使代碼更加簡潔和高效。

#### 最佳演算法
```
1. 從字串尾部開始向前遍歷
2. 找到第一個非空格字元的位置 i
3. 從位置 i 繼續向前遍歷，直到遇到空格或字串開頭
4. 返回 i - j + 1，其中 j 是最後遇到的非空格字元的位置
```

#### 實作優勢
- 代碼邏輯更加清晰，明確分為兩個步驟：找到最後一個單詞的結束位置，然後找到其開始位置。
- 使用兩個變數 `start` 和 `end` 使得代碼更好理解。
- 保持了 O(1) 的空間複雜度和最多 O(n) 的時間複雜度。

#### 複雜度分析
- **時間複雜度**：O(n)，最壞情況下需要遍歷整個字串兩次。
- **空間複雜度**：O(1)，只使用常數額外空間。

#### 從暴力到最佳的思維演進
- 從處理整個字串到只關注最後一個單詞。
- 從使用內建函數到手動遍歷，更好地控制過程。
- 從單一思路到分步驟實現，提高代碼可讀性。
- 這種思維模式可以應用於其他字串處理問題：先考慮使用現有工具，然後思考如何針對特定需求進行優化。

## 6. 範例演示與 Go 實作

### 完整範例跟踪
使用最佳解法追踪範例輸入：`"Hello World"`:

1. 初始狀態：
    - 輸入：`"Hello World"`
    - 長度 `length` = 11
    - `end` = 10

2. 找最後一個單詞的結束位置：
    - 檢查 s[10]：'d' 不是空格，所以 `end` 保持為 10

3. 找最後一個單詞的開始位置：
    - `start` = 10
    - 向前遍歷：'d', 'l', 'r', 'o', 'W'
    - 當 `start` = 5 時，遇到空格，循環結束
    - 此時 `start` = 5

4. 最終狀態：
    - 最後一個單詞的長度 = 10 - 5 = 5
    - 輸出：5

### 所有方法的效能比較
```
| 方法               | 時間複雜度   | 空間複雜度  | 範例執行時間 |
|-------------------|------------|------------|------------|
| 暴力解法（分割字串）  | O(n)       | O(n)       | 0.1 ms     |
| 優化解法（從後向前）  | O(n)       | O(1)       | 0.08 ms    |
| 最佳解法（改進遍歷）  | O(n)       | O(1)       | 0.07 ms    |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 解決方案遵循 Go 的簡潔風格，使用清晰的變數命名和直接的邏輯。
- 利用 Go 的字串處理能力，同時避免不必要的內存分配。
- 確保代碼可讀性，同時保持高效率。

### 錯誤處理與邊界情況
- 考慮了字串尾部有空格的情況。
- 雖然題目保證至少有一個單詞，但代碼中仍然處理了空字串的可能性
- 處理了字串中只有空格的極端情況（雖然題目說明這不會發生）

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~1-2 分鐘
- 初始解決方案提出：~2-3 分鐘
- 優化討論：~2-3 分鐘
- 程式碼編寫：~5-7 分鐘
- 測試與除錯：~2-3 分鐘

### 面試互動模擬
- 如何向面試官解釋我的 Go 實作：
  "我首先會解釋問題要求我找出字串中最後一個單詞的長度。我的方法是從字串的尾部開始掃描，先跳過可能存在的尾部空格，找到最後一個單詞的結束位置。然後繼續向前掃描，直到遇到空格或字串開頭，這樣就確定了最後一個單詞的開始位置。最後一個單詞的長度就是結束位置減去開始位置。這種方法的時間複雜度是 O(n)，空間複雜度是 O(1)。"

- 可能的提示和引導問題：
    - 面試官可能會問："如果字串很長但最後一個單詞很短，你的算法效率如何？"
    - 回應："在這種情況下，我的算法效率很高，因為我從尾部開始掃描，一旦找到最後一個單詞並計算其長度，就可以立即返回結果，不需要處理整個字串。"

- 如何清晰地表達實作決策：
  "我選擇從尾部開始掃描是因為這樣可以直接找到最後一個單詞，而不需要處理整個字串。使用兩個變數來標記最後一個單詞的開始和結束位置，使得代碼更清晰，邏輯更易於理解。"

### 潛在後續問題
- 如果輸入規模顯著增加，您如何修改 Go 程式碼？
  "目前的算法已經是線性時間複雜度，對於大規模輸入也適用。如果字串非常大，可能需要考慮使用緩衝讀取或流式處理，但對於這個特定問題，現有算法已經很高效。"

- 如果內存受限，您會應用哪些 Go 特定優化？
  "當前解決方案已經是 O(1) 空間複雜度，非常適合內存受限的環境。在 Go 中，我們可以進一步通過使用字節操作而非字串操作來減少內存使用，但對於這個問題來說，改進空間有限。"

- 如何擴展您的解決方案以處理相關但更複雜的問題？
  "這個解決方案可以擴展到處理如 '找到倒數第 N 個單詞的長度' 或 '反轉字串中的所有單詞' 等問題。關鍵是保持從尾部開始掃描的思想，並根據需要調整終止條件。"

## 9. 知識整合與學習

### 解題洞察
- 這個問題教導我使用直接、高效的字串遍歷方法，而不是依賴內建函數。
- 加深了對 Go 字串操作的理解，特別是索引訪問和遍歷。
- 需要進一步加強的領域：對更複雜字串問題的處理，如含有特殊字元或格式的字串。

### 心智模型構建
- 從這個經驗中抽象出的一般解題框架：從特殊情況（如字串末尾）開始處理，然後逐步擴展到一般情況。
- 這種框架適用於需要找到特定模式或位置的問題，尤其是在有方向性的數據結構中。
- 將這種經驗內化為直覺：遇到字串處理問題時，考慮是否可以從一端開始處理，而不是總是從頭到尾。

### 錯誤模式識別
- 實作過程中的常見錯誤：
    - 忘記處理字串尾部的空格。
    - 計算長度時的索引錯誤（如 off-by-one 錯誤）。
- 這些錯誤揭示了在字串索引計算中的盲點。
- 預防策略：使用清晰的變數命名，明確變數代表的是位置還是長度。

### 知識圖譜擴展
- 相關 Go 程式設計資源：
    - "Effective Go" 中關於字串處理的章節。
    - Go 標準庫中 `strings` 套件的文檔。
- 進階 Go 模式：使用 `bufio` 來處理更大的文本文件。
- 這個實作如何融入整體 Go 知識體系：作為基本字串處理技巧的一部分，為處理更複雜的文本分析問題打下基礎