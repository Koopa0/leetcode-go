## 1. Original Problem

**Reverse Integer**

Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

**Examples:**
- Input: x = 123
- Output: 321

- Input: x = -123
- Output: -321

- Input: x = 120
- Output: 21

**Constraints:**
- `-2^31 <= x <= 2^31 - 1`

**翻轉整數**

給定一個有符號的 32 位元整數 `x`，傳回 `x` 的數字反轉。如果反轉 `x` 導致值超出有符號 32 位元整數範圍 [-2^31, 2^31 - 1]，則傳回 0。

假設環境不允許儲存 64 位元整數（有符號或無符號）。

**範例：**
- 輸入：x = 123
- 輸出：321

- 輸入：x = -123
- 輸出：-321

- 輸入：x = 120
- 輸出：21

**限制條件：**
- `-2^31 <= x <= 2^31 - 1`

## 2. 問題理解

這個問題要求將一個整數的數字順序反轉，同時保持其符號。關鍵要點包括：

1. 需要保留數字的符號（正數或負數）
2. 需要移除前導零（例如：120 反轉後為 21，而不是 021）
3. 如果反轉後的數字超出 32 位元整數的範圍，應該返回 0
4. 不能使用 64 位元整數進行計算（這是一個重要的限制）

輸入特徵：
- 一個 32 位元的整數，可正可負
- 範圍在 [-2^31, 2^31 - 1] 內，即 [-2,147,483,648, 2,147,483,647]

輸出特徵：
- 數字反轉後的整數
- 如果反轉後超出範圍，則為 0

邊緣案例：
- 處理零：0 反轉後仍為 0
- 處理負數：-123 反轉後為 -321
- 處理末尾有零的數字：120 反轉後為 21
- 處理可能溢出的數字：例如 1,534,236,469 反轉後會超出範圍

主要挑戰是在不使用 64 位元整數的情況下檢測溢位。

## 3. 視覺解釋

讓通過一個例子來視覺化這個過程：

反轉 x = 12345 的步驟：

```
初始狀態: x = 12345, result = 0

步驟 1: 取出 x 的最後一位數字 5
         x = 1234, result = 5
         
步驟 2: 取出 x 的最後一位數字 4
         x = 123, result = 5*10 + 4 = 54
         
步驟 3: 取出 x 的最後一位數字 3
         x = 12, result = 54*10 + 3 = 543
         
步驟 4: 取出 x 的最後一位數字 2
         x = 1, result = 543*10 + 2 = 5432
         
步驟 5: 取出 x 的最後一位數字 1
         x = 0, result = 5432*10 + 1 = 54321
         
最終結果: 54321
```

對於負數，例如 x = -123：

```
初始狀態: x = -123, result = 0

步驟 1: 取出 x 的最後一位數字 3
         x = -12, result = 3
         
步驟 2: 取出 x 的最後一位數字 2
         x = -1, result = 3*10 + 2 = 32
         
步驟 3: 取出 x 的最後一位數字 1
         x = 0, result = 32*10 + 1 = 321
         
最終結果: -321 (保持原始符號)
```

溢出檢查的視覺化：

當計算 `result = result * 10 + digit` 時，如果 result 已經大於 INT_MAX/10 或 result 等於 INT_MAX/10 但 digit 大於 INT_MAX%10，則會發生溢出：

```
INT_MAX = 2,147,483,647

如果 result > 214,748,364，那麼 result*10 + 任何數字 > INT_MAX
如果 result = 214,748,364 且 digit > 7，那麼 result*10 + digit > INT_MAX
```

類似地對於負數：

```
INT_MIN = -2,147,483,648

如果 result < -214,748,364，那麼 result*10 + 任何數字 < INT_MIN
如果 result = -214,748,364 且 digit < -8，那麼 result*10 + digit < INT_MIN
```

## 4. 思考過程

對於這個問題，可以考慮幾種解決方案：

**方法 1：字串轉換法**
將整數轉換為字串，反轉字串，然後轉回整數。這種方法簡單明瞭，但在 Go 中不是最有效的方式，且需要額外處理溢出問題。

**方法 2：數學運算法**
使用數學運算來反轉數字：
- 重複提取數字的最後一位（x % 10）
- 將結果乘以 10 並加上提取的數字（result = result * 10 + digit）
- 將原數字除以 10（x /= 10）
- 直到原數字變為 0

數學運算法的優點是不需要額外的空間，且可以在提取過程中檢查溢出。

**方法 3：遞迴法**
利用遞迴反轉數字，但這會增加額外的空間複雜度，且不是最直觀的解法。

考慮到問題的限制和效率，方法 2（數學運算法）是最適合的。它不需要額外空間，操作簡單，且可以有效處理溢出檢查。

## 5. 最佳解決方案開發

將採用數學運算法來解決這個問題。關鍵思路是：
1. 檢查輸入數字的符號，並將其轉換為正數進行處理（使計算更簡單）
2. 使用模運算（%）和除法（/）提取各個位的數字
3. 在每次迭代時檢查是否會發生溢出
4. 最後根據原始符號返回結果

讓用具體的例子說明：

例子：x = 123

```
初始狀態：
x = 123, result = 0

第 1 次迭代：
digit = 123 % 10 = 3
result = 0 * 10 + 3 = 3
x = 123 / 10 = 12

第 2 次迭代：
digit = 12 % 10 = 2
result = 3 * 10 + 2 = 32
x = 12 / 10 = 1

第 3 次迭代：
digit = 1 % 10 = 1
result = 32 * 10 + 1 = 321
x = 1 / 10 = 0

x 已經為 0，結束迭代
最終結果：321
```

關鍵洞察：
- 使用模運算和除法可以有效地提取和移除數字
- 在每一步檢查溢出可以確保結果在 32 位元整數範圍內
- 這種方法不需要額外的空間，時間複雜度與數字的位數成正比

## 7. 複雜度分析

**時間複雜度**：
- 最佳情況：O(log₁₀(x))，當 x 只有一位數字時
- 平均情況：O(log₁₀(x))，其中 x 是輸入整數的絕對值
- 最壞情況：O(log₁₀(x))，當 x 有多位數字時

這裡的 log₁₀(x) 表示 x 的位數。例如，一個 10 位數的整數需要 10 次迭代。

**空間複雜度**：
- O(1)，只使用了常數個變數，不管輸入大小如何，空間使用量都是固定的。

**為什麼複雜度不能進一步優化**：
時間複雜度已經是最優的，因為必須至少檢查整數的每一位才能反轉它。空間複雜度也已經是最優的，因為只使用了常數空間。