## 1. Original Problem

### English Version:
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

### 繁體中文版：
給定一個只包含 '(' 和 ')' 的字符串，找出最長有效（格式正確）括號子串的長度。

### Examples:
- **Example 1:**
    - Input: s = "(()"
    - Output: 2
    - Explanation: The longest valid parentheses substring is "()".

- **Example 2:**
    - Input: s = ")()())"
    - Output: 4
    - Explanation: The longest valid parentheses substring is "()()".

- **Example 3:**
    - Input: s = ""
    - Output: 0

### Constraints:
- 0 ≤ s.length ≤ 3 * 10^4
- s[i] is '(', or ')'.

## 2. 問題理解

這個問題要求我們找出給定字符串中最長的有效括號子串長度。有效括號意味著每個開括號 '(' 都有一個對應的閉括號 ')'，且它們按照正確的順序配對。

**核心要求：**
- 找出最長的有效括號子串
- 返回其長度（而非子串本身）

**輸入/輸出特性：**
- 輸入是一個只包含 '(' 和 ')' 的字符串
- 輸出是一個整數，表示最長有效括號子串的長度

**邊界情況：**
- 空字符串：返回 0
- 沒有有效括號：返回 0
- 整個字符串都是有效括號：返回字符串長度

**主要挑戰：**
1. 識別何為有效括號子串
2. 在可能存在多個有效子串的情況下找出最長的一個
3. 處理諸如 "())()" 這樣的情況，其中有多個不連續的有效子串

## 3. 視覺解釋

讓我們通過一個例子來可視化這個問題：")()())"

```
位置索引:  0 1 2 3 4 5
字符串:    ) ( ) ( ) )
```

我們來分析每個位置開始的子串：

```
位置 0: ")" - 不是有效括號
位置 1: "()())" - 包含 "()()" 這個有效子串，長度為 4
位置 2: ")" - 不是有效括號
位置 3: "())" - 包含 "()" 這個有效子串，長度為 2
位置 4: ")" - 不是有效括號
位置 5: ")" - 不是有效括號
```

所以最長有效括號子串是 "()()"，長度為 4。

現在讓我們可視化算法的執行流程（使用堆疊方法）：

```
索引: 0 1 2 3 4 5
字串: ) ( ) ( ) )
```

1. 初始化堆疊，放入 -1 作為基準點：堆疊 = [-1]
2. 遍歷字符串：
    - 位置 0: ')' → 彈出 -1，堆疊為空，放入 0: 堆疊 = [0]
    - 位置 1: '(' → 放入 1: 堆疊 = [0, 1]
    - 位置 2: ')' → 彈出 1，計算長度 2-0=2，最大長度 = 2，堆疊 = [0]
    - 位置 3: '(' → 放入 3: 堆疊 = [0, 3]
    - 位置 4: ')' → 彈出 3，計算長度 4-0=4，最大長度 = 4，堆疊 = [0]
    - 位置 5: ')' → 彈出 0，堆疊為空，放入 5: 堆疊 = [5]
3. 最終結果：最大長度 = 4

## 4. 思考過程

對於這個問題，我們可以考慮幾種不同的解決方案：

### 方法一：暴力法
我們可以遍歷所有可能的子串，然後檢查每個子串是否是有效的括號序列。但這種方法的時間複雜度為 O(n³)，效率較低。

### 方法二：動態規劃
我們可以定義 dp[i] 為以第 i 個字符結尾的最長有效括號子串的長度。
- 如果 s[i] = '('，那麼 dp[i] = 0，因為不可能以 '(' 結尾
- 如果 s[i] = ')'，我們需要檢查 s[i-1]：
    - 如果 s[i-1] = '('，那麼 dp[i] = dp[i-2] + 2
    - 如果 s[i-1] = ')'，我們需要檢查 s[i-1-dp[i-1]] 是否為 '('：
        - 如果是，dp[i] = dp[i-1] + 2 + dp[i-2-dp[i-1]]（如果 i-2-dp[i-1] ≥ 0）

### 方法三：堆疊法
使用堆疊來跟踪括號的配對情況。遍歷字符串，對於：
- '('：將索引推入堆疊
- ')'：彈出堆疊頂部元素，如果堆疊為空，將當前索引推入；否則，計算當前索引與堆疊頂部元素之間的距離作為有效括號的長度

對於這個問題，堆疊法是最直觀且高效的方法，時間和空間複雜度都為 O(n)。

## 5. 最佳解決方案開發

我們將採用堆疊法作為最佳解決方案。讓我們一步步開發這個方案：

1. 初始化一個堆疊，並放入 -1 作為基準點
2. 遍歷字符串的每個字符：
    - 如果是 '('，將其索引推入堆疊
    - 如果是 ')'：
        - 彈出堆疊頂部元素
        - 如果堆疊為空，將當前索引推入（作為新的基準點）
        - 如果堆疊不為空，計算當前索引與堆疊頂部元素之間的距離，更新最大長度
3. 返回最大長度

這種方法的優點是：
- 只需遍歷字符串一次
- 可以處理所有可能的情況，包括連續和不連續的有效括號子串
- 時間複雜度為 O(n)，空間複雜度為 O(n)

## 6. 實例演示

讓我們以 ")()())" 為例詳細演示這個算法的執行過程：

1. 初始化：堆疊 = [-1]，maxLength = 0
2. 遍歷字符串：
    - 索引 0，字符 ')'：
        - 彈出 -1，堆疊為空
        - 將 0 推入堆疊：堆疊 = [0]
        - maxLength = 0

    - 索引 1，字符 '('：
        - 將 1 推入堆疊：堆疊 = [0, 1]
        - maxLength = 0

    - 索引 2，字符 ')'：
        - 彈出 1，堆疊 = [0]
        - 計算長度：2 - 0 = 2
        - 更新 maxLength = 2

    - 索引 3，字符 '('：
        - 將 3 推入堆疊：堆疊 = [0, 3]
        - maxLength = 2

    - 索引 4，字符 ')'：
        - 彈出 3，堆疊 = [0]
        - 計算長度：4 - 0 = 4
        - 更新 maxLength = 4

    - 索引 5，字符 ')'：
        - 彈出 0，堆疊為空
        - 將 5 推入堆疊：堆疊 = [5]
        - maxLength = 4

3. 最終結果：maxLength = 4

這證明了該算法能夠正確找出最長有效括號子串的長度，即 "()()".

## 7. Golang 實現

```go
func longestValidParentheses(s string) int {
    // 初始化堆疊，放入 -1 作為基準點
    stack := []int{-1}
    maxLength := 0

    // 遍歷字符串
    for i := 0; i < len(s); i++ {
        if s[i] == '(' {
            // 如果是開括號，將索引推入堆疊
            stack = append(stack, i)
        } else {
            // 如果是閉括號，彈出堆疊頂部元素
            stack = stack[:len(stack)-1]
            
            if len(stack) == 0 {
                // 如果堆疊為空，將當前索引推入作為新的基準點
                stack = append(stack, i)
            } else {
                // 計算當前有效括號子串的長度，並更新最大長度
                curLength := i - stack[len(stack)-1]
                if curLength > maxLength {
                    maxLength = curLength
                }
            }
        }
    }
    
    return maxLength
}
```

## 8. 實現執行演示

讓我們使用示例 ")()())" 逐步執行上面的代碼：

```
初始化：stack = [-1], maxLength = 0

位置 0，字符 ')'：
- 彈出 -1，stack = []
- stack 為空，將 0 推入：stack = [0]
- maxLength = 0

位置 1，字符 '('：
- 將 1 推入：stack = [0, 1]
- maxLength = 0

位置 2，字符 ')'：
- 彈出 1，stack = [0]
- 計算長度：2 - 0 = 2
- 更新 maxLength = 2

位置 3，字符 '('：
- 將 3 推入：stack = [0, 3]
- maxLength = 2

位置 4，字符 ')'：
- 彈出 3，stack = [0]
- 計算長度：4 - 0 = 4
- 更新 maxLength = 4

位置 5，字符 ')'：
- 彈出 0，stack = []
- stack 為空，將 5 推入：stack = [5]
- maxLength = 4

最終結果：maxLength = 4
```

## 9. 複雜度分析

### 時間複雜度
- 我們只遍歷字符串一次，所以時間複雜度是 O(n)，其中 n 是字符串的長度。
- 堆疊的操作（推入和彈出）都是 O(1) 的操作。

### 空間複雜度
- 我們使用一個堆疊來存儲索引，最壞情況下（如全部是開括號），堆疊的大小為 O(n)。
- 因此，空間複雜度為 O(n)，其中 n 是字符串的長度。

## 10. 優化和改進

堆疊法已經是這個問題的最優解之一，但還有一個可能的優化是使用常量空間的解法：

### 改進方案：雙指針技術

我們可以使用兩次掃描來解決這個問題，分別從左到右和從右到左：

1. 從左到右掃描：
    - 維護左括號和右括號的計數
    - 當右括號數量等於左括號數量時，計算當前有效長度
    - 當右括號數量大於左括號數量時，重置計數

2. 從右到左掃描（處理類似 "(()" 的情況）：
    - 維護左括號和右括號的計數
    - 當左括號數量等於右括號數量時，計算當前有效長度
    - 當左括號數量大於右括號數量時，重置計數

這種方法的時間複雜度仍為 O(n)，但空間複雜度降為 O(1)。

## 11. 測試策略

這個測試包括多種情況：
- 普通測試案例（來自問題描述）
- 邊界情況（空字符串、全部無效）
- 特殊情況（全部有效、嵌套括號、混合括號）
- 性能測試（長字符串）
- 極端情況（只有左括號或右括號）