# Jump Game II

## 1. Original Problem:

Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**
```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**
```
Input: nums = [2,3,0,1,4]
Output: 2
```

**Constraints:**
- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 1000

## 問題描述：

給定一個非負整數數組 `nums`，你最初位於數組的第一個索引處。數組中的每個元素代表你在該位置可以跳躍的最大長度。你的目標是使用最少的跳躍次數到達數組的最後一個索引。

你可以假設總是可以到達數組的最後一個索引。

**示例 1：**
```
輸入: nums = [2,3,1,1,4]
輸出: 2
解釋: 到達最後一個索引的最少跳躍次數是 2。從索引 0 跳躍 1 步到索引 1，然後跳躍 3 步到達最後一個索引。
```

**示例 2：**
```
輸入: nums = [2,3,0,1,4]
輸出: 2
```

**約束條件：**
- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 1000

## 2. 初步問題解析與心智模型建立：

當我第一次看到這個問題時，我會先梳理關鍵信息：

- 我們從數組的第一個元素開始
- 每個數字代表在該位置可以向前跳躍的**最大**距離
- 我們的目標是用最少的跳躍次數到達最後一個位置
- 可以確定一定能夠到達終點（這是一個重要的前提）

讓我們來解讀示例 1 `[2,3,1,1,4]`：
- 從位置 0 開始，值為 2，意味著我們可以跳到位置 1 或位置 2
- 如果跳到位置 1，值為 3，意味著可以再跳 1、2 或 3 步，即可以到達位置 2、3 或 4
- 如果從位置 1 跳 3 步，就直接到達位置 4（終點），總共跳躍 2 次

問題的輸入是一個整數數組，輸出是一個表示最小跳躍次數的整數。在思考解法前，我先將問題建立成一個心智模型：把每個位置看作一個節點，從該位置可以到達的其他位置由連接的邊表示。我們的任務是找到從起點到終點的最短路徑。

## 3. 問題理解與核心挑戰：

這個問題的核心挑戰是：

- 在每一步，我們需要決定跳多遠才能最終用最少的跳躍次數到達終點
- 每個位置可能有多種跳躍選擇（從 1 到當前位置的值）
- 我們需要全局最優化而不僅僅是局部最優

輸入特性：
- 數組可能很長（高達 10^4 個元素）
- 值域範圍也很大（0 到 1000）
- 數組中可能有值為 0 的元素，代表在該位置無法跳躍
- 題目保證我們總能到達終點（這是解題的重要線索）

在本質上，這是一個路徑最優化問題，可以用圖的最短路徑思維或貪心算法來解決。

## 4. 問題的視覺表示：

讓我們將問題視覺化。以 `[2,3,1,1,4]` 為例：

```
索引:  0    1    2    3    4
值:    2    3    1    1    4
      / \   |\ \  |    |
     /   \  | \ \  \    \
    1     2 2  3 4  3    4
```

這個圖表示：
- 從索引 0（值為 2），可以跳到索引 1 或 2
- 從索引 1（值為 3），可以跳到索引 2、3 或 4
- 從索引 2（值為 1），可以跳到索引 3
- 從索引 3（值為 1），可以跳到索引 4

我們需要找到從索引 0 到索引 4 的最短路徑（最少跳躍次數）。

## 5. 問題模式識別：

分析這個問題，我可以將其歸類為：

- 貪心算法問題
- 圖的最短路徑問題
- 可能的動態規劃問題

觀察到數組大小可能很大（10^4），這暗示我們需要一個高效的算法，最好是線性時間複雜度 O(n)。

最關鍵的線索是「總是可以到達最後一個索引」。這使得我們可以放心使用貪心策略，不必擔心跳到某個位置後無法繼續前進。

## 6. 策略性解題框架：

對於這類跳躍最優化問題，我建議以下思考框架：

1. 考慮最直觀的方法：廣度優先搜索（BFS）或動態規劃
2. 觀察問題特性，判斷是否可以使用更高效的貪心算法
3. 對於每個位置，思考「我能跳到哪裡」和「從哪裡可以跳到這裡」兩個角度
4. 不要只考慮「跳多遠」，而要考慮「跳到哪裡後能再跳得最遠」

核心原則：在當前可到達的範圍內，選擇下一步能夠到達最遠位置的跳躍點。

## 7. 算法設計（編碼前）：

經過分析，我決定使用貪心算法解決這個問題。算法思路如下：

1. 初始化跳躍次數 `jumps = 0`
2. 初始化當前能到達的最遠位置 `currEnd = 0`
3. 初始化下一步能到達的最遠位置 `farthest = 0`
4. 從索引 0 開始遍歷數組（不需要遍歷最後一個元素）：
   a. 更新 `farthest = max(farthest, i + nums[i])`
   b. 如果 `i == currEnd`（已經到達當前跳躍的邊界）：
   i. 跳躍次數加一 `jumps++`
   ii. 更新 `currEnd = farthest`
5. 返回 `jumps`

這個算法的核心思想是：在每次跳躍可到達的範圍內，找出下一步能夠到達最遠位置，然後進行一次跳躍。

## 8. 視覺化解釋：

讓我們使用示例 `[2,3,1,1,4]` 來視覺化算法執行過程：

初始狀態：
- jumps = 0
- currEnd = 0（當前能到達的最遠位置）
- farthest = 0（下一步能到達的最遠位置）

```
索引:  0    1    2    3    4
值:    2    3    1    1    4
狀態:  i
      currEnd
```

第一次迭代（i = 0）：
- 更新 farthest = max(0, 0+2) = 2
- i == currEnd，所以 jumps = 1，currEnd = 2

```
索引:  0    1    2    3    4
值:    2    3    1    1    4
狀態:       i         
                currEnd
```

第二次迭代（i = 1）：
- 更新 farthest = max(2, 1+3) = 4
- i != currEnd，繼續

```
索引:  0    1    2    3    4
值:    2    3    1    1    4
狀態:            i     
                currEnd
       farthest = 4
```

第三次迭代（i = 2）：
- 更新 farthest = max(4, 2+1) = 4（不變）
- i == currEnd，所以 jumps = 2，currEnd = 4

```
索引:  0    1    2    3    4
值:    2    3    1    1    4
狀態:                 i
                           currEnd
```

現在 currEnd 已經到達或超過了終點，所以算法結束，返回 jumps = 2。

## 9. 解決方案發展歷程：

讓我們從最基本的思路開始，逐步優化：

**方法一：動態規劃**
我們可以定義 dp[i] 為到達位置 i 所需的最少跳躍次數：
- 初始化 dp[0] = 0，其他位置為無窮大
- 對於每個位置 i，遍歷所有可以到達 i 的位置 j，更新 dp[i] = min(dp[i], dp[j] + 1)
- 時間複雜度：O(n²)

**方法二：BFS（廣度優先搜索）**
將問題視為圖的最短路徑問題：
- 使用隊列存儲當前可以到達的位置
- 每一輪 BFS 代表一次跳躍
- 時間複雜度：O(n)，空間複雜度：O(n)

**方法三：貪心算法（最優解）**
關鍵洞見：我們不需要考慮所有可能的跳躍路徑，只需要在當前可到達的範圍內，找出能夠使下一步到達最遠位置的跳躍點。
- 維護當前可到達的最遠位置和下一步可到達的最遠位置
- 時間複雜度：O(n)，空間複雜度：O(1)

這種從複雜到簡單的思考過程幫助我們找到了最優解。

## 10. 實例演算步驟：

讓我們使用示例 `[2,3,1,1,4]` 詳細演示貪心算法的執行過程：

初始狀態：
- jumps = 0
- currEnd = 0
- farthest = 0

**第 1 步（處理索引 0）：**
- nums[0] = 2，表示可以跳到索引 1 或 2
- 更新 farthest = max(0, 0+2) = 2
- i == currEnd，我們需要進行一次跳躍
- jumps = 1
- currEnd = 2（下一步能到達的最遠位置）

**第 2 步（處理索引 1）：**
- nums[1] = 3，表示可以跳到索引 2、3 或 4
- 更新 farthest = max(2, 1+3) = 4
- i != currEnd，繼續

**第 3 步（處理索引 2）：**
- nums[2] = 1，表示可以跳到索引 3
- 更新 farthest = max(4, 2+1) = 4（不變）
- i == currEnd，我們需要進行另一次跳躍
- jumps = 2
- currEnd = 4

現在 currEnd 已經到達終點，所以算法結束，返回 jumps = 2。

關鍵洞見：即使我們從索引 0 跳到索引 1，而不是直接跳到索引 2，最終的跳躍次數也是一樣的，因為從索引 1 可以直接跳到終點。這說明了貪心策略的有效性。

## 11. Golang 實現：

```go
func jump(nums []int) int {
    // 如果數組長度為 1，直接返回 0（不需要跳躍）
    if len(nums) == 1 {
        return 0
    }
    
    jumps := 0        // 跳躍次數
    currEnd := 0      // 當前能到達的最遠位置
    farthest := 0     // 下一步能到達的最遠位置
    
    // 遍歷數組（注意：不需要遍歷最後一個元素）
    for i := 0; i < len(nums)-1; i++ {
        // 更新下一步能到達的最遠位置
        farthest = max(farthest, i + nums[i])
        
        // 如果已經到達當前跳躍能到達的邊界
        if i == currEnd {
            // 進行一次跳躍
            jumps++
            // 更新當前能到達的最遠位置
            currEnd = farthest
            
            // 優化：如果已經能到達終點，提前結束
            if currEnd >= len(nums)-1 {
                break
            }
        }
    }
    
    return jumps
}

// Go 1.13+ 中需要自己實現 max 函數
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 12. 實現執行過程：

讓我們使用示例 `[2,3,1,1,4]` 來追蹤代碼的執行：

起始狀態：
- jumps = 0
- currEnd = 0
- farthest = 0

**進入 for 循環，i = 0：**
- nums[0] = 2
- 更新 farthest = max(0, 0+2) = 2
- i == currEnd，所以執行跳躍：jumps = 1，currEnd = 2
- currEnd < len(nums)-1，繼續循環

**i = 1：**
- nums[1] = 3
- 更新 farthest = max(2, 1+3) = 4
- i != currEnd，不執行跳躍

**i = 2：**
- nums[2] = 1
- 更新 farthest = max(4, 2+1) = 4（不變）
- i == currEnd，所以執行跳躍：jumps = 2，currEnd = 4
- currEnd >= len(nums)-1，break 跳出循環

返回 jumps = 2。

注意觀察代碼中的提前結束條件：一旦我們發現當前可到達的位置已經能夠到達或超過終點，就可以提前結束循環，這是一個重要的優化。

## 13. 複雜度分析：

**時間複雜度：** O(n)
- 我們只需要遍歷數組一次，每個元素最多被處理一次
- 在最壞情況下，我們需要檢查數組中的每個元素（除了最後一個）

**空間複雜度：** O(1)
- 我們只使用了常數額外空間來存儲 jumps、currEnd 和 farthest 變量

這個解法是最優的，因為：
- 我們必須至少檢查每個元素一次以確定最短路徑，所以時間複雜度不可能低於 O(n)
- 我們只使用了常數級別的額外空間，空間複雜度已經是最優的

## 14. 優化與改進：

我們已經使用了最優的貪心算法解決了這個問題。還有一些值得思考的變體：

**可能的優化點：**
- 如果輸入數組非常長，可以考慮並行處理不同區段（雖然對於這個特定問題幫助不大）
- 在某些特殊情況下（如全是相同值的數組），可以進行數學計算而不是遍歷

**相關問題變體：**
- 如果不保證能到達終點，如何判斷是否可以到達？（LeetCode 55: Jump Game）
- 如果要求輸出所有可能的最短路徑，而不僅僅是最短路徑的長度，如何修改算法？
- 如果數組元素可以是負數，表示可以向後跳，問題會變得更複雜

## 15. 一般解題智慧：

從這個問題中，我們可以總結出以下重要的解題思路：

1. **識別問題類型**：許多看似複雜的問題可以轉化為經典問題（如最短路徑問題）。

2. **分析問題約束**：「總是可以到達終點」這一約束讓我們可以安全地使用貪心策略。

3. **漸進式思考**：從簡單的解法開始（如暴力法或DP），逐步優化到最優解。

4. **反向思考**：有時候從終點往回思考比從起點出發更容易找到解法。

5. **尋找不變量**：在這個問題中，關鍵不變量是「在當前可到達的範圍內找出能夠使下一步到達最遠位置的跳躍點」。

這些思路不僅適用於跳躍遊戲問題，也適用於許多其他算法問題，特別是那些可以轉化為圖問題或需要找出最優策略的問題。

## 16. 測試策略：

這個測試策略包括：
- 官方提供的示例
- 邊界情況（只有一個元素的數組）
- 特殊情況（每步只能跳 1、第一步可直達終點）
- 較大的數組測試

這些測試案例能夠全面驗證我們的解決方案在各種情況下的正確性和穩健性。