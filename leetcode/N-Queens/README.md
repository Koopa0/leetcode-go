# LeetCode 51: N-Queens (N皇后問題)

## 1. 問題定義

### Original Problem (English)
```
The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.

Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' indicates a queen and '.' indicates an empty space.
```

### Problem Translation (Traditional Chinese)
```
N皇后問題是在一個 n x n 的棋盤上放置 n 個皇后，使得沒有兩個皇后能夠互相攻擊。

給定一個整數 n，返回 N 皇后問題的所有不同解法。你可以以任何順序返回答案。

每個解法包含一個明確的 N 皇后放置方案，其中 'Q' 表示皇后，'.' 表示空格。
```

### Examples & Constraints
- **Example 1:**
  ```
  Input: n = 4
  Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
  Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
  ```
- **Example 2:**
  ```
  Input: n = 1
  Output: [["Q"]]
  ```

- **Constraints:**
    - 1 <= n <= 9

## 2. 問題理解

### 初始反應與心智模型
- 看到這個問題時，我的第一反應是需要使用回溯法（Backtracking）來嘗試所有可能的皇后放置方式。
- 國際象棋中，皇后可以攻擊同一行、同一列或同一對角線上的其他棋子。
- 這意味著我們需要確保每行、每列和每條對角線上只能有一個皇后。
- 這個問題可以視為在 n×n 的棋盤上，找出所有符合條件的 n 個皇后的放置方式。

### 問題分解
- 核心子問題：確定皇后的放置方式，使它們不能互相攻擊。
- 必要操作：檢查每個位置是否安全（不受其他已放置皇后攻擊）。
- 需處理的邊界情況：空棋盤（n=0）、只有一個格子的棋盤（n=1）。
- 問題可分解為：逐行放置皇后，確保新放置的皇后不與之前已放置的皇后互相衝突。

### 視覺表示
```
以 n=4 為例，兩個解法的視覺表示：

解法 1：
. Q . .
. . . Q
Q . . .
. . Q .

解法 2：
. . Q .
Q . . .
. . . Q
. Q . .
```

- 透過視覺化，我們可以清楚看到每個皇后都位於不同的行、列和對角線上。
- 這種視覺模型幫助我們理解問題的約束條件，並指導演算法設計。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見的演算法模式：
    - [x] 回溯法（Backtracking）
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋（DFS）
    - [ ] 廣度優先搜尋（BFS）
    - [ ] 動態規劃（DP）
    - [ ] 貪心演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別基礎：
    - 問題需要找出所有可能的解法，而非僅一個解法
    - 需要試探性地放置皇后，若發現衝突則回溯到上一步
    - 問題具有約束條件，需要在探索過程中維持這些條件

### 知識連結
- 涉及的基本電腦科學概念：回溯法、組合優化、狀態空間搜尋
- 與其他演算法或資料結構的關聯：DFS 的一種特殊形式，但加入了「撤銷決策」的步驟
- 需要應用的理論知識：棋盤問題的約束條件處理、搜尋樹的剪枝技術

### 相似問題比較
- 類似的 LeetCode 問題：
    - Sudoku Solver (37)：同樣使用回溯法在網格中放置元素
    - Permutations (46)：使用回溯法生成所有可能的排列
    - Combination Sum (39)：使用回溯法找出所有可能的組合
- 相似之處：都需要探索所有可能的解空間並回溯
- 不同之處：N 皇后問題有特殊的對角線約束條件

## 4. 演算法直覺發展

### 直覺構建
- 現實世界類比：像是在安排會議室，確保有衝突的人不會同時出現在同一個會議室
- 初始直覺：逐行放置皇后，並檢查每個位置是否安全
- 驗證直覺：手動模擬 n=4 的情況，確認回溯法能找到所有解法

### 多角度思考
- 不同角度的思考方式：
    - 行優先 vs. 列優先：由於每行必須恰好有一個皇后，採用行優先放置更為自然
    - 迭代式 vs. 遞迴式：遞迴實現更符合回溯法的思維模式
    - 狀態空間搜尋 vs. 約束滿足問題：可以視為在狀態空間中搜尋滿足所有約束的路徑
- 最有希望的角度：將問題視為逐行放置皇后的遞迴回溯過程

## 5. 解決方案發展歷程

### 方法一：基本回溯法

#### 思考過程
- 最直接的方法是嘗試在每一行放置一個皇后，然後檢查是否與之前放置的皇后衝突
- 從第一行開始，依次嘗試每個列位置
- 如果當前位置安全，則放置皇后並遞迴解決剩餘行
- 如果發現無法放置，則回溯到上一行並嘗試新的位置

#### 演算法設計
```
function solveNQueens(n):
    result = []
    board = 創建一個 n×n 的棋盤，初始化為全部 '.'
    backtrack(board, 0, result)
    return result

function backtrack(board, row, result):
    if row == board.length:
        將當前棋盤配置添加到 result
        return
    
    for col = 0 to board.length-1:
        if isSafe(board, row, col):
            在 (row, col) 放置皇后
            backtrack(board, row + 1, result)
            移除 (row, col) 的皇后（回溯）

function isSafe(board, row, col):
    檢查同一列上是否有其他皇后
    檢查左上到右下對角線上是否有其他皇后
    檢查右上到左下對角線上是否有其他皇后
    return 如果安全則為 true，否則為 false
```

#### 複雜度分析
- **時間複雜度**：O(N!)，因為第一行有 N 個選擇，第二行有 N-1 個選擇（最壞情況），以此類推
- **空間複雜度**：O(N²)，用於存儲棋盤，加上遞迴調用棧的 O(N) 空間

#### 解決方案評估
- 優點：直接實現回溯法的思想，容易理解
- 缺點：每次放置皇后時都需要檢查是否安全，效率較低
- 面試環境評估：基本回溯法已經是一個可接受的解法，但可以進一步優化

### 方法二：優化的回溯法

#### 關鍵洞見
- 在基本方法中，每次放置皇后都需要檢查整個棋盤，這是冗餘的
- 我們可以使用三個集合來跟踪已經被占用的列、正對角線和反對角線
- 正對角線特性：row + col 相同
- 反對角線特性：row - col 相同

#### 優化策略
```
function solveNQueens(n):
    result = []
    cols = 空集合（用於跟踪已占用的列）
    posDiag = 空集合（用於跟踪已占用的正對角線，row + col）
    negDiag = 空集合（用於跟踪已占用的反對角線，row - col）
    board = 創建一個 n×n 的棋盤，初始化為全部 '.'
    backtrack(0, cols, posDiag, negDiag, board, result)
    return result

function backtrack(row, cols, posDiag, negDiag, board, result):
    if row == n:
        將當前棋盤配置添加到 result
        return
    
    for col = 0 to n-1:
        if col not in cols and 
           (row + col) not in posDiag and 
           (row - col) not in negDiag:
            
            cols.add(col)
            posDiag.add(row + col)
            negDiag.add(row - col)
            在 (row, col) 放置皇后
            
            backtrack(row + 1, cols, posDiag, negDiag, board, result)
            
            cols.remove(col)
            posDiag.remove(row + col)
            negDiag.remove(row - col)
            移除 (row, col) 的皇后（回溯）
```

#### 複雜度分析
- **時間複雜度**：O(N!)，雖然我們優化了安全檢查，但最壞情況下的分支因子仍為 N!
- **空間複雜度**：O(N²)，用於存儲棋盤配置，加上三個集合的 O(N) 空間

#### 解決方案評估
- 優化的有效性：不再需要逐個檢查位置是否安全，直接通過集合判斷，大大提高了效率
- 這種優化在大型棋盤上特別有價值，因為安全檢查的成本從 O(N) 降低到 O(1)

### 方法三：位元操作進一步優化

#### 突破性思考
- 關鍵洞見：可以使用位元操作來表示已被攻擊的列、正對角線和反對角線
- 這種表示法不僅節省空間，還能通過位元操作實現更高效的檢查和更新
- 位元操作可以在常數時間內完成安全檢查和狀態更新

#### 最佳演算法
```
function solveNQueens(n):
    result = []
    board = 創建一個 n×n 的棋盤，初始化為全部 '.'
    backtrack(0, 0, 0, 0, board, result)
    return result

function backtrack(row, cols, posDiag, negDiag, board, result):
    if row == n:
        將當前棋盤配置添加到 result
        return
    
    // 計算所有可以放置皇后的位置
    // 1 表示可放置，0 表示不可放置
    availablePositions = ~(cols | posDiag | negDiag) & ((1 << n) - 1)
    
    while availablePositions != 0:
        // 獲取最右邊的 1（最右邊可放置的位置）
        position = availablePositions & -availablePositions
        // 計算對應的列索引
        col = 計算 position 中 1 的位置
        
        // 放置皇后
        在 (row, col) 放置皇后
        
        // 更新約束條件並遞迴
        backtrack(row + 1, 
                 cols | position, 
                 (posDiag | position) << 1, 
                 (negDiag | position) >> 1, 
                 board, result)
        
        // 移除皇后（回溯）
        移除 (row, col) 的皇后
        
        // 移除當前位置，嘗試下一個位置
        availablePositions &= ~position
```

#### 複雜度分析
- **時間複雜度**：O(N!)，分支因子仍為 N!，但單步操作更高效
- **空間複雜度**：O(N²)，用於存儲結果，但工作空間僅需 O(N)

#### 從暴力法到最佳法的思想演變
- 初始方法：依賴於顯式檢查每個位置
- 第一階段優化：使用集合跟踪約束條件，避免重複檢查
- 最終優化：使用位元操作表示狀態，實現高效的檢查和更新
- 這種演變體現了從直觀理解到抽象優化的過程

## 6. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解法提案：~5 分鐘
- 優化討論：~5-7 分鐘
- 程式碼編寫：~10-15 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 我會首先解釋問題的約束條件：皇后不能在同一行、同一列或同一對角線
- 然後提出回溯法作為解決方案，並解釋逐行放置皇后的策略
- 可能的提示和引導問題：
    - 面試官可能會問：「能否優化皇后放置的安全檢查？」
    - 我會回應：「可以使用集合或位元操作跟踪已被攻擊的位置，將檢查時間從 O(N) 優化到 O(1)」
- 清晰地溝通思考過程：先從基本回溯開始，然後逐步引入優化

### 潛在的後續問題
- 如果輸入規模顯著增加（例如 n=100），如何優化算法？
- 如果問題條件改變（例如，允許部分皇后攻擊對方），如何調整算法？
- 如何擴展解法來處理相關但更複雜的問題，如最小皇后覆蓋問題？

## 7. Golang 實現

### 完整解決方案

我已經創建了一個包含 N-Queens 問題兩種解法的 Golang 實現：基本回溯法和位元操作優化版本。您可以在「N-Queens Golang 實現」的程式碼片段中查看。

### 程式碼執行追蹤

以輸入 n=4 為例，追蹤基本回溯法的執行過程：

1. 初始狀態：
    - 創建一個 4×4 的空棋盤，全部初始化為 '.'
    - 創建三個空集合：cols, posDiag, negDiag

2. 第一步 (row=0, col=0)：
    - 嘗試在 (0,0) 放置皇后
    - 這個位置是安全的，放置皇后 'Q'
    - 更新集合: cols={0}, posDiag={0}, negDiag={0}
    - 遞迴到 row=1

3. 第二步 (row=1)：
    - 嘗試在 (1,0) 放置皇后 -> 不安全，列 0 已被使用
    - 嘗試在 (1,1) 放置皇后 -> 不安全，主對角線 2 已被使用
    - 嘗試在 (1,2) 放置皇后：安全
    - 放置皇后，更新集合: cols={0,2}, posDiag={0,3}, negDiag={0,-1}
    - 遞迴到 row=2

4. 繼續處理剩餘行，直到找到所有解法...

### 程式碼最佳實踐
- 程式碼可讀性：使用清晰的變數名稱和註釋說明每個步驟
- Go 語言特性利用：使用 map 作為集合、閉包函數實現回溯
- 錯誤處理：處理 n=0 和 n=1 等邊界情況
- 位元操作優化：展示了如何使用位元操作來優化回溯過程

## 8. 知識整合與學習

### 解題洞見
- 這個問題教會我利用問題的結構特性（如對角線特性）來優化解法
- 加深了對回溯法剪枝策略的理解
- 學習了如何使用位元操作優化集合操作，特別是在約束滿足問題中

### 心智模型建構
- 這個問題建立了一個通用的回溯框架：找出所有可能的放置位置，逐一嘗試，發現不合適就回溯
- 這個框架可以應用於其他組合優化問題，如數獨、排列與組合問題
- 將模板化的知識內化為直覺，加速解決類似問題

### 錯誤模式識別
- 回溯時忘記重置狀態是常見錯誤，必須確保徹底清除之前的選擇
- 對角線檢查容易出錯，需要仔細理解斜線的數學表示
- 位元操作邏輯錯誤可能導致解法不完整，需要詳細測試驗證

### 知識圖譜擴展
- 相關學習資源：「演算法導論」中的回溯法章節、「編程珠璣」中的位元操作技巧
- 進階探索：約束滿足問題（CSP）的其他解法，如舞蹈鏈（Dancing Links）
- 這個問題是經典組合優化問題的代表，與圖著色問題、旅行推銷員問題等有關聯

### 面試相關性
- 這個問題反映了面試重視的特質：系統性思考和優化能力
- 解題過程需要逐步優化的思維方式
- 在實際面試中，應該先提出基本解法，然後主動提出優化方向，展示解決複雜問題的能力

## 9. 間隔重複計劃

### 弱點識別與強化
- 識別的弱點：位元操作在解題中的應用不夠熟練
- 強化計劃：
    1. 學習更多位元操作技巧，特別是在集合表示和狀態壓縮方面
    2. 練習 5-10 個使用位元操作的問題，如位元計數、子集生成等
    3. 重新實現 N-Queens 問題的位元操作版本，不參考任何資料
- 進度追蹤：每週回顧一次實現，持續改進位元操作技巧

N-Queens 問題是一個展示回溯法精髓的經典問題，通過逐步優化從基本回溯到位元操作。