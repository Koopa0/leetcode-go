# 1. Original Problem: Combination Sum

## English Version
Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.

The **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

**Example 1:**
```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

**Example 2:**
```
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
```

**Example 3:**
```
Input: candidates = [2], target = 1
Output: []
```

**Constraints:**
- 1 <= candidates.length <= 30
- 2 <= candidates[i] <= 40
- All elements of `candidates` are distinct.
- 1 <= target <= 40

## 繁體中文版本
給定一個**無重複元素**的整數數組 `candidates` 和一個目標整數 `target`，返回所有可以使數字和為目標數 `target` 的**唯一組合**。數字可以以任何順序返回。

**同一個**數字可以從 `candidates` 中**無限制重複選取**。如果至少一個所選數字的頻率不同，則兩種組合是唯一的。

**示例 1:**
```
輸入: candidates = [2,3,6,7], target = 7
輸出: [[2,2,3],[7]]
解釋:
2 和 3 是候選數，2 + 2 + 3 = 7。注意 2 可以使用多次。
7 是一個候選數，7 = 7。
這是唯一的兩種組合。
```

**示例 2:**
```
輸入: candidates = [2,3,5], target = 8
輸出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3:**
```
輸入: candidates = [2], target = 1
輸出: []
```

**約束條件:**
- 1 <= candidates.length <= 30
- 2 <= candidates[i] <= 40
- `candidates` 中的所有元素都是不同的。
- 1 <= target <= 40

# 2. 初始問題解析與心智建模

## 初步解析
當我第一次看到這個問題時，首先需要理解的關鍵信息：
1. 我們有一個不含重複元素的整數數組 `candidates`
2. 我們需要找出所有可能的組合，使得選取的數字和等於 `target`
3. 我們可以重複使用 `candidates` 中的每個數字任意次

## 問題視覺化
讓我們用例子來具體化這個抽象問題。以示例 1 為例：
- 候選數字：[2, 3, 6, 7]
- 目標：7

如果把這個問題想象成一個「湊零錢」的問題，我們有面值為 2、3、6、7 的硬幣，無限量供應，需要湊出總額 7。

## 輸入輸出理解
- 輸入：候選數組和目標值
- 輸出：所有可能的組合（每個組合是一個數組）
- 轉換需求：找出所有加起來等於目標值的數字組合

## 心智模型建立
我可以將這個問題視覺化為一棵決策樹：
- 在每一個節點，我可以選擇使用或不使用某個候選數字
- 如果使用，可以選擇使用 1 次、2 次或更多次
- 當累計和等於目標值時，我們找到了一個有效組合
- 當累計和超過目標值時，該路徑不再有效

# 3. 問題理解與核心挑戰

## 核心要求與約束
1. 組合中的數字必須來自 `candidates` 數組
2. 每個數字可以重複使用任意次
3. 所有組合必須是唯一的
4. 所有數字和必須等於 `target`

## 輸入/輸出特性和邊界情況
- 如果 `target` 小於 `candidates` 中的最小值，則無解
- 如果 `candidates` 只有一個元素且不能整除 `target`，則無解
- 所有輸入數字都是正整數，所以不會有負數或零的複雜情況

## 基本挑戰
這個問題的核心挑戰在於如何系統地探索所有可能的組合，而不重複計算或遺漏。由於元素可以重複使用，我們不能使用簡單的子集生成方法。

## 本質操作
本質上，這是一個「組合求和」問題，需要使用回溯法（Backtracking）來系統性地嘗試所有可能的組合。回溯是處理這類「窮舉所有可能性」問題的標準技術。

# 4. 視覺問題表示

## 決策樹表示
讓我們以 `candidates = [2, 3]` 和 `target = 7` 為例，繪製一個決策樹：

```
                    開始(剩餘目標=7)
                   /              \
          選擇 2 (剩餘=5)        選擇 3 (剩餘=4)
           /        \            /        \
    選擇 2 (剩餘=3) 選擇 3 (剩餘=2) 選擇 2 (剩餘=2) 選擇 3 (剩餘=1)
     /      \        /      \       /      \       /      \
  選2(剩1) 選3(剩0)  選2(剩0) 選3(剩-1) 選2(剩0) 選3(剩-1) 選2(剩-1) 選3(剩-2)
```

當剩餘目標為 0 時，我們找到了一個有效組合。當剩餘目標小於 0 時，該路徑不再有效。

## 視覺輔助理解
在這棵樹中，每條從根到剩餘為 0 的葉子的路徑代表一個有效組合：
- 選擇 [2,2,3]：7 - 2 = 5, 5 - 2 = 3, 3 - 3 = 0 ✓
- 選擇 [2,3,2]：7 - 2 = 5, 5 - 3 = 2, 2 - 2 = 0 ✓
- 選擇 [3,2,2]：7 - 3 = 4, 4 - 2 = 2, 2 - 2 = 0 ✓

但注意，上面三條路徑實際上是相同的組合，因為順序不重要。為了避免重複計算相同的組合，我們需要在遞歸過程中施加一個重要的約束：只考慮當前或之後的候選數，而不回頭考慮之前的候選數。

# 5. 問題模式識別

## 問題類型識別
觀察這個問題的特點：
1. 需要找出所有可能的組合
2. 每個元素可以重複使用
3. 需要計算總和是否等於目標值

這明顯是一個「回溯（Backtracking）」問題。回溯是解決組合問題的標準技術，特別是當我們需要窮舉所有可能性時。

## 關鍵指標
- 需要找"所有可能的組合"（而非一個最優解）是回溯問題的典型特徵
- 可以重複使用元素的特點使其成為「組合總和」而非簡單的「組合」問題
- 候選集合較小（<=30）但可以重複使用，暗示了指數級的解空間

## 與已知問題模式的比較
這個問題類似於：
- 「硬幣找零」問題，但要求列出所有可能的組合而非最少硬幣數
- 「0-1 背包」的變體，但物品可以取多次（無限背包問題）

# 6. 戰略性問題解決框架

## 總體方法
對於這類回溯問題，我們通常採用以下框架：
1. 定義一個回溯函數，該函數嘗試在當前狀態下構建有效組合
2. 在每一步，嘗試所有可能的選擇（加入一個候選數）
3. 如果選擇導致有效組合，保存該組合
4. 如果選擇導致無效路徑，回溯到上一狀態
5. 設置適當的終止條件

## 思考策略
解決這類問題的關鍵是「深度優先搜索」結合「狀態管理」：
- 使用遞歸來實現深度優先搜索
- 在每次遞歸中，維護當前累計的組合和剩餘目標值
- 當剩餘目標為 0 時，我們找到了一個有效組合
- 當剩餘目標小於 0 時，該路徑不再有效，進行回溯

## 系統性分解
將問題分解為以下步驟：
1. 排序候選數組（雖然非必須，但可以提早剪枝）
2. 從空組合開始，遞歸地構建所有可能的組合
3. 在每一步，嘗試添加一個候選數
4. 跟踪剩餘目標值，當它變為 0 時保存組合
5. 避免重複計算：只考慮當前或之後的候選數

# 7. 編碼前的算法設計

## 算法描述（偽代碼）
```
function combinationSum(candidates, target):
    sort(candidates)  // 排序以便優化
    result = []
    backtrack(candidates, target, 0, [], result)
    return result

function backtrack(candidates, remain, start, combination, result):
    if remain < 0:
        // 超過目標，無效路徑
        return
    else if remain == 0:
        // 找到有效組合
        result.add(copy of combination)
        return
    
    // 嘗試所有可能的選擇
    for i from start to candidates.length - 1:
        // 加入當前候選數
        combination.add(candidates[i])
        
        // 關鍵：我們可以重複使用同一元素，所以下一層的起始索引仍為i
        backtrack(candidates, remain - candidates[i], i, combination, result)
        
        // 回溯：移除最後加入的元素
        combination.remove_last()
```

## 算法驗證
手動驗證 `candidates = [2,3,6,7], target = 7` 的運行過程：

1. 首先嘗試使用 2：
    - 加入 2，剩餘目標為 5
    - 再次嘗試 2：加入 2，剩餘目標為 3
    - 再次嘗試 2：加入 2，剩餘目標為 1
    - 嘗試 2：剩餘目標為 -1，無效路徑，回溯
    - 嘗試 3：加入 3，剩餘目標為 -2，無效路徑，回溯
    - 回溯到 [2,2]，嘗試 3：加入 3，剩餘目標為 0，找到組合 [2,2,3]
    - 回溯到 [2,2]，嘗試 6,7：都會導致剩餘目標為負，無效路徑

依此類推...最終我們會找到所有可能的組合。

# 8. 視覺解釋

讓我通過 `candidates = [2,3,6,7], target = 7` 的樹狀圖來示範算法的執行：

```
                        []
                        |
                        v
                        [2]
                       /|  \
                      / |   \
                     /  |    \
               [2,2] [2,3] [2,6] [2,7]
               /  \    |     |     |
              /    \   |     |     |
        [2,2,2] [2,2,3] X     X     X
           |       |
           |       |
            X     成功
```

注：X 表示超過目標，不再繼續展開。

同樣地，從 [3], [6], [7] 開始的分支也會被探索：
- [3] → [3,3] → [3,3,3] 超過了目標 7，無效
- [6] → [6,6] 超過了目標 7，無效
- [7] → 恰好等於目標 7，找到了組合 [7]

最終找到所有有效組合：[[2,2,3], [7]]

# 9. 解決方案發展過程

## 初始直覺方法
最直觀的方法是使用回溯算法，嘗試所有可能的組合。但如果不加優化，我們可能會重複計算許多情況。

## 核心優化洞察
1. **排序候選數組**：雖然不是必須的，但排序可以讓我們更早地剪枝無效路徑
2. **使用起始索引**：通過傳遞起始索引，我們確保不會生成重複的組合
3. **提前剪枝**：當剩餘目標小於當前候選數時，不再繼續該路徑

## 從暴力法到最優解的演進
1. 暴力法：枚舉所有可能的組合，包括重複的（不可行）
2. 基本回溯：使用回溯框架，但可能生成重複組合
3. 優化回溯：通過跟踪起始索引避免重複組合
4. 進一步優化：添加剪枝操作，減少無效路徑的探索

# 10. 實際例子演練

以 `candidates = [2,3,6,7], target = 7` 為例，詳細追踪算法的執行過程：

1. 初始狀態：combination = [], remain = 7, start = 0

2. 第一層遞歸：嘗試 candidates[0] = 2
    - 添加 2：combination = [2], remain = 5, start = 0

    3. 第二層遞歸：再次嘗試 2
        - 添加 2：combination = [2,2], remain = 3, start = 0

        4. 第三層遞歸：再次嘗試 2
            - 添加 2：combination = [2,2,2], remain = 1, start = 0

            5. 第四層遞歸：嘗試 2
                - 添加 2：combination = [2,2,2,2], remain = -1 < 0，無效路徑
                - 回溯：combination = [2,2,2]

               嘗試 3
                - 添加 3：combination = [2,2,2,3], remain = -2 < 0，無效路徑
                - 回溯：combination = [2,2,2]

               由於 6,7 更大，同樣會導致無效路徑，不再嘗試

            - 回溯：combination = [2,2]

       嘗試 3
        - 添加 3：combination = [2,2,3], remain = 0，找到有效組合
        - 保存組合 [2,2,3]
        - 回溯：combination = [2,2]

       嘗試 6
        - 添加 6：combination = [2,2,6], remain = -5 < 0，無效路徑
        - 回溯：combination = [2,2]

       嘗試 7
        - 添加 7：combination = [2,2,7], remain = -6 < 0，無效路徑
        - 回溯：combination = [2,2]

        - 返回上一層：combination = [2]

   嘗試 3
    - 添加 3：combination = [2,3], remain = 2, start = 1

   (省略中間步驟，最終沒有找到新的有效組合)

    - 回溯：combination = [2]

   (省略嘗試 6,7 的步驟，都會導致無效路徑)

    - 回溯：combination = []

3. 第一層遞歸：嘗試 candidates[1] = 3
    - 添加 3：combination = [3], remain = 4, start = 1

   (省略中間步驟)

    - 回溯：combination = []

4. 第一層遞歸：嘗試 candidates[2] = 6
    - 添加 6：combination = [6], remain = 1, start = 2

   (嘗試繼續添加 6,7 都會導致無效路徑)

    - 回溯：combination = []

5. 第一層遞歸：嘗試 candidates[3] = 7
    - 添加 7：combination = [7], remain = 0，找到有效組合
    - 保存組合 [7]
    - 回溯：combination = []

6. 所有可能都已嘗試，算法結束

最終結果：[[2,2,3], [7]]

# 12. 代碼實現執行演練

讓我們以 `candidates = [2,3,6,7], target = 7` 為例，追踪代碼的執行過程：

1. 初始調用：`combinationSum([2,3,6,7], 7)`
    - 排序 candidates（已排序）
    - 初始化空結果集 result = []
    - 調用 backtrack(0, 7, [])

2. backtrack(0, 7, [])
    - remaining != 0，進入循環
    - i = 0, candidates[0] = 2 <= remaining，可選
    - 選擇 2：current = [2]
    - 遞歸調用 backtrack(0, 5, [2])

3. backtrack(0, 5, [2])
    - remaining != 0，進入循環
    - i = 0, candidates[0] = 2 <= remaining，可選
    - 選擇 2：current = [2,2]
    - 遞歸調用 backtrack(0, 3, [2,2])

4. backtrack(0, 3, [2,2])
    - remaining != 0，進入循環
    - i = 0, candidates[0] = 2 <= remaining，可選
    - 選擇 2：current = [2,2,2]
    - 遞歸調用 backtrack(0, 1, [2,2,2])

5. backtrack(0, 1, [2,2,2])
    - remaining != 0，進入循環
    - i = 0, candidates[0] = 2 > remaining，剪枝
    - 循環結束，回溯到上一層

6. 回到 backtrack(0, 3, [2,2])
    - i = 1, candidates[1] = 3 == remaining，可選
    - 選擇 3：current = [2,2,3]
    - 遞歸調用 backtrack(1, 0, [2,2,3])

7. backtrack(1, 0, [2,2,3])
    - remaining == 0，找到有效組合
    - 將 [2,2,3] 加入 result
    - 返回上一層

（省略後續步驟...）

最終，經過完整的遞歸回溯過程，結果集將包含 [[2,2,3], [7]]。

# 13. 複雜度分析

## 時間複雜度
分析回溯算法的時間複雜度較為複雜，因為它依賴於解的數量和結構。

在最壞情況下，時間複雜度為 O(N^(T/M))，其中：
- N 是候選數的數量
- T 是目標值
- M 是候選數組中的最小值

解釋：
- 決策樹的最大深度為 T/M（當我們每次都選擇最小值時）
- 在每層，我們最多有 N 個選擇
- 因此，最壞情況下的時間複雜度為 O(N^(T/M))

## 空間複雜度
- 遞歸調用棧的深度最大為 O(T/M)
- 存儲臨時組合的空間為 O(T/M)
- 存儲結果的空間取決於有效組合的數量和大小，最壞情況下為 O(T/M * 2^(T/M))

綜合來看，空間複雜度為 O(T/M)。

## 複雜度為什麼不能進一步改進
這個問題本質上需要枚舉所有可能的組合，是一個 NP 問題。沒有多項式時間的解法，回溯算法已經是最優的方法。

# 14. 優化與改進

## 潛在優化方向
1. **排序與剪枝**：雖然我們已經實現了基本的剪枝，但可以進一步優化：
    - 如果候選數組特別大，可以考慮只排序前 target/min(candidates) 個元素
    - 在確定無解的情況下提前返回

2. **記憶化**：對於更複雜的變體，可以使用記憶化來避免重複計算相同的子問題

## 不同解法的比較
1. **回溯法**（我們使用的方法）：
    - 優點：直接、易於理解、適用於找所有解
    - 缺點：指數級時間複雜度

2. **動態規劃**：
    - 優點：可以計算解的數量
    - 缺點：不容易列出所有具體的解，需要額外的回溯步驟

3. **BFS/層次遍歷**：
    - 優點：可以找到長度最短的解
    - 缺點：空間消耗較大，不適合找所有解

# 15. 一般問題解決智慧

## 核心教訓
1. **問題識別**：識別問題類型（如回溯、動態規劃）是解決算法問題的關鍵第一步
2. **系統性探索**：回溯是一種系統性探索解空間的技術，適用於找所有可能解
3. **剪枝優化**：及早識別無效路徑可以顯著提高效率
4. **正確的狀態管理**：在遞歸和回溯過程中，正確管理狀態（如當前組合、剩餘目標）至關重要

## 類似問題與思路拓展
這種回溯框架可以應用於許多類似問題：
- Combination Sum II（候選數不可重複使用）
- Subsets（找所有子集）
- Permutations（找所有排列）
- N-Queens（N 皇后問題）

## 培養算法直覺
要培養解決這類問題的直覺：
1. 識別出問題是「求所有可能解」還是「求最優解」
2. 對於「求所有可能解」的問題，考慮回溯框架
3. 對於有重複元素的情況，思考如何去重
4. 總是考慮如何通過剪枝來提高效率

# 16. 測試策略

這個測試方法涵蓋了：
1. 基本功能測試（示例1-3）
2. 邊界情況（空數組、零目標）
3. 性能測試（較大的數字）