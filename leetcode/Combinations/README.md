# LeetCode 77: 組合 (Combinations)

## 1. 問題定義

### Original Problem (English)
```
Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].

You may return the answer in any order.
```

### 問題翻譯 (繁體中文)
```
給定兩個整數 n 和 k，返回範圍 [1, n] 中所有可能的 k 個數字的組合。

你可以以任何順序返回答案。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: n = 4, k = 2
  輸出: [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]
  ```
- **範例 2:**
  ```
  輸入: n = 1, k = 1
  輸出: [[1]]
  ```

- **限制條件:**
    - 1 <= n <= 20
    - 1 <= k <= n

## 2. 問題理解

### 初步反應與心智模型
- 這是一個組合問題，我們需要從 n 個數字中選擇 k 個不同的數字。
- 數學上，這是 C(n,k) 的組合問題，總共會有 n!/(k!(n-k)!) 種可能的組合。
- 該問題要求我們列舉所有可能的組合，而非僅計算組合的數量。
- 可以將問題視為「決策樹」，每個節點代表是否選擇某個數字。

### 問題拆解
- 核心問題：如何系統性地生成所有可能的組合？
- 需要確保每個組合都是唯一的，且包含確切的 k 個元素。
- 需要確保我們不會重複選擇同一個數字。
- 可以使用回溯法來系統性地嘗試所有可能的組合。

### 視覺表示
```
以 n=4, k=2 為例，決策樹如下：

                  []
        /     /     \      \
      [1]    [2]    [3]    [4]
    / | \    / \     \
[1,2][1,3][1,4][2,3][2,4][3,4]
```
- 這個視覺化模型顯示了如何通過遞迴決策來建構所有可能的組合。
- 每一層我們都在做「選擇下一個數字」的決策。
- 當組合達到 k 個元素時，我們將其添加到結果中。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [X] 回溯法 (Backtracking)
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜索/二分答案
    - [ ] 深度優先搜索 (DFS)
    - [ ] 廣度優先搜索 (BFS)
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作

- 識別依據：
    - 問題要求找出所有可能的組合，這是回溯法的典型應用場景。
    - 需要系統性地嘗試所有可能性，且在產生目標長度的組合後停止。
    - 類似問題如「子集」、「排列」等都使用回溯法解決。

### 知識連結
- 組合數學：理解 C(n,k) 組合的概念和計算方法。
- 回溯法：一種系統性地嘗試所有可能解並在不滿足條件時「回溯」的技術。
- 遞迴：使用函數遞迴調用來實現回溯過程。

### 相似問題比較
- LeetCode 39：組合總和 (Combination Sum)
- LeetCode 40：組合總和 II (Combination Sum II)
- LeetCode 46：全排列 (Permutations)
- LeetCode 78：子集 (Subsets)
- 這些問題都使用回溯法，差別在於選擇的條件和約束不同。

## 4. 演算法直覺發展

### 直覺建立
- 可以將問題想像成從一組編號為 1 到 n 的人中選出 k 人組成一個委員會。
- 我們可以從第一個人開始，決定是否將其納入委員會。
- 對於每個人，我們有兩個選擇：選擇或不選擇。
- 當委員會人數達到 k 時，我們記錄這個組合，然後回溯嘗試其他可能性。

### 多視角分析
- 自頂向下 vs. 自底向上：
    - 自頂向下：從空組合開始，逐步添加元素。
    - 自底向上：從完整集合開始，逐步移除元素（較不適用於本問題）。
- 迭代 vs. 遞迴：
    - 遞迴實現更直觀，每層遞迴處理一個元素的選擇問題。
    - 迭代實現可能需要使用堆疊模擬遞迴過程，較為複雜。

## 5. 解決方案發展歷程

### 方法 1：回溯法（基本實現）

#### 思考過程
- 最直觀的解決方案是使用回溯法。
- 從空組合開始，逐步嘗試添加數字。
- 當組合達到 k 個元素時，將其添加到結果中。
- 使用遞迴來系統性地探索所有可能的組合。

#### 演算法設計
```
function combine(n, k):
    結果列表 = []
    
    function backtrack(start, 目前組合):
        如果 目前組合的長度 == k:
            將目前組合加入結果列表
            返回
        
        對於每個數字 i 從 start 到 n:
            將 i 加入目前組合
            backtrack(i + 1, 目前組合)
            從目前組合中移除 i
    
    backtrack(1, [])
    返回結果列表
```

#### 實現細節
- 使用 Go 的切片（slice）來存儲當前組合和最終結果。
- 注意在將當前組合加入結果前需要創建一個副本，避免後續修改影響已存儲的結果。
- 使用閉包定義回溯函數，保持代碼結構清晰。

#### 複雜度分析
- **時間複雜度**: O(C(n,k) * k) — 需要生成 C(n,k) 個組合，每個組合需要 O(k) 時間來構建和複製。
- **空間複雜度**: O(k) — 遞迴調用棧的深度最多為 k，加上暫存當前組合需要的 O(k) 空間。

#### 解決方案評估
- 優點：直觀易懂，實現簡單，能夠系統性地生成所有可能的組合。
- 缺點：對於大型輸入可能效率較低，存在潛在的冗餘計算。
- 在面試環境中，這是一個可接受的基礎解決方案。

### 方法 2：優化的回溯法

#### 關鍵見解
- 我們可以通過剪枝優化回溯過程，減少不必要的遞迴調用。
- 觀察：如果剩餘可選數字不足以湊齊 k 個元素，可以提前結束。

#### 優化策略
```
function combine(n, k):
    結果列表 = []
    
    function backtrack(start, 目前組合):
        如果 目前組合的長度 == k:
            將目前組合加入結果列表
            返回
        
        // 剪枝：確保還有足夠的數字可供選擇
        for i from start to n - (k - len(目前組合)) + 1:
            將 i 加入目前組合
            backtrack(i + 1, 目前組合)
            從目前組合中移除 i
    
    backtrack(1, [])
    返回結果列表
```

#### 實現改進
- 通過計算剩餘所需元素數量來優化遍歷範圍。
- 例如，如果我們需要 3 個元素，但當前只有 1 個元素，且已經遍歷到 n-1，那麼即使選擇 n-1 和 n，也只能得到 3 個元素，無法滿足要求。
- 這種剪枝可以顯著減少不必要的遞迴調用。

#### 複雜度分析
- **時間複雜度**: O(C(n,k) * k) — 儘管我們減少了不必要的遞迴調用，但時間複雜度的上界仍然不變。
- **空間複雜度**: O(k) — 與基本實現相同。

#### 解決方案評估
- 此優化減少了不必要的遞迴調用，特別是在 k 接近 n/2 時效果顯著。
- 在大型輸入情況下，剪枝可以大幅提高效率。
- 剪枝策略不會改變結果的正確性。

### 方法 3：字典序迭代實現

#### 突破性思考
- 我們可以用迭代而非遞迴的方式生成組合，避免遞迴調用的開銷。
- 採用字典序演算法生成組合，這是一種系統性地生成所有組合的非遞迴方法。

#### 最佳演算法
```
function combine(n, k):
    // 初始組合：[1,2,...,k]
    combination = [1,2,...,k]
    結果列表 = [combination的副本]
    
    while true:
        i = k - 1
        while i >= 0 且 combination[i] == n - (k - 1 - i):
            i--
        
        if i < 0:
            break  // 已生成所有組合
        
        combination[i]++
        for j = i + 1 to k - 1:
            combination[j] = combination[i] + (j - i)
        
        將combination的副本加入結果列表
    
    返回結果列表
```

#### 實現卓越性
- 此實現避免了遞迴調用，減少了函數調用的開銷。
- 通過系統性地生成字典序的下一個組合，確保不會有重複。
- 空間使用效率高，只需要一個固定大小的切片來存儲當前組合。

#### 複雜度分析
- **時間複雜度**: O(C(n,k) * k) — 仍需生成所有 C(n,k) 個組合，每個組合需要 O(k) 時間處理。
- **空間複雜度**: O(k) — 只需要 O(k) 額外空間來存儲當前組合。

#### 從暴力解法到最優解法的思考演進
- 從基本的回溯法，我們認識到問題的本質是生成所有可能的組合。
- 通過引入剪枝策略，我們減少了不必要的搜索路徑。
- 最後，我們發現可以避開遞迴，使用迭代方法按字典序生成所有組合，進一步提高效率。
- 這種思考過程體現了從直觀解法到優化解法的演進，可以應用於其他組合生成問題。

## 6. 範例執行追蹤與 Go 實現

### 完整範例追蹤
以輸入 n=4, k=2 追蹤我們的最佳解法：

1. 初始狀態：
    - 輸入：`n=4, k=2`
    - 初始組合：`[1, 2]`
    - 結果：`[[1, 2]]`

2. 第一次迭代：
    - `i = 1`（最右邊可遞增的位置）
    - `comb[1]` 從 2 增加到 3
    - 新組合：`[1, 3]`
    - 結果：`[[1, 2], [1, 3]]`

3. 第二次迭代：
    - `i = 1`（最右邊可遞增的位置）
    - `comb[1]` 從 3 增加到 4
    - 新組合：`[1, 4]`
    - 結果：`[[1, 2], [1, 3], [1, 4]]`

4. 第三次迭代：
    - `i = 0`（最右邊可遞增的位置，因為 comb[1] 已達最大值）
    - `comb[0]` 從 1 增加到 2
    - 重置 `comb[1] = 3`
    - 新組合：`[2, 3]`
    - 結果：`[[1, 2], [1, 3], [1, 4], [2, 3]]`

5. 第四次迭代：
    - `i = 1`（最右邊可遞增的位置）
    - `comb[1]` 從 3 增加到 4
    - 新組合：`[2, 4]`
    - 結果：`[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4]]`

6. 第五次迭代：
    - `i = 0`（最右邊可遞增的位置，因為 comb[1] 已達最大值）
    - `comb[0]` 從 2 增加到 3
    - 重置 `comb[1] = 4`
    - 新組合：`[3, 4]`
    - 結果：`[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]`

7. 第六次迭代：
    - 無可遞增的位置（`i < 0`），跳出循環

8. 最終狀態：
    - 輸出：`[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]`

### 所有方法的性能比較
```
| 方法             | 時間複雜度      | 空間複雜度   | 範例執行時間 |
|-----------------|---------------|------------|------------|
| 基本回溯法        | O(C(n,k) * k) | O(k)       | X ms       |
| 優化回溯法        | O(C(n,k) * k) | O(k)       | Y ms       |
| 字典序迭代實現     | O(C(n,k) * k) | O(k)       | Z ms       |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 使用 Go 的切片操作進行組合的生成和操作，符合 Go 語言的風格。
- 使用閉包函數實現回溯，保持代碼結構清晰。
- 避免使用全局變數，將所有狀態作為參數傳遞或在函數內部管理。

### 錯誤處理與邊緣情況
- 處理邊界情況：當 k=0 或 k>n 時，返回空結果。
- 確保在複製組合到結果列表時創建新的切片，避免因共享引用導致的意外修改。
- 注意整數範圍：根據問題的限制條件，整數範圍在 Go 的 int 範圍內，無需特殊處理

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初始解法提出：~3 分鐘
- 優化討論：~5 分鐘
- 代碼編寫：~10 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現：
    - "我將使用回溯法來解決這個組合問題。首先，我會創建一個輔助函數來系統性地生成所有可能的組合..."
    - "我注意到我們可以透過剪枝來優化這個解法，具體來說，如果剩餘的數字不足以構成所需的組合大小，我們可以提前停止探索..."
    - "最後，我們可以考慮使用字典序的迭代方法，這樣可以避免遞迴調用的開銷..."

### 可能的後續問題
- 如果輸入規模增大（例如 n=1000, k=500），如何修改你的 Go 代碼？
- 你能否實現一個分批生成組合的解決方案，以處理結果集非常大的情況？
- 如何修改你的算法來生成從 n 個元素中選 k 個的所有排列（而非組合）？

## 9. 知識整合與學習

### 問題解決洞見
- 回溯法是解決組合問題的強大工具，特別適合需要列舉所有可能解的情況。
- 剪枝策略可以顯著提高回溯算法的效率，避免不必要的探索。
- 迭代算法有時可以替代遞迴，減少函數調用開銷並簡化實現。

### 心智模型建構
- 解決組合問題的一般框架：識別問題類型、設計回溯策略、應用剪枝優化、考慮迭代替代。
- 這個框架可應用於其他排列、組合、子集等問題，只需調整選擇條件和終止條件。

### 錯誤模式識別
- 常見錯誤：未正確處理回溯時的狀態恢復，導致解不正確。
- 盲點：未考慮在將當前組合加入結果時創建新的切片副本，導致所有結果指向同一個被修改的切片。
- 預防方法：仔細追蹤狀態變化，使用 `make` 和 `copy` 創建切片副本。

### 知識圖譜擴展
- 相關資源：
    - [組合數學基礎](https://en.wikipedia.org/wiki/Combinatorics)
    - [回溯法詳解](https://en.wikipedia.org/wiki/Backtracking)
    - [LeetCode 組合問題集](https://leetcode.com/tag/backtracking/)
- 這個實現強化了對回溯法的理解，以及如何在 Go 中高效實現組合生成算法