# 1. Original Problem

## Zigzag Conversion (LeetCode 6)

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this:
```
P   A   H   N
A P L S I I G
Y   I   R
```
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows.

**Example 1:**
```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```

**Example 2:**
```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**Example 3:**
```
Input: s = "A", numRows = 1
Output: "A"
```

**Constraints:**
- 1 <= s.length <= 1000
- s consists of English letters (lower-case and upper-case), ',' and '.'.
- 1 <= numRows <= 1000

## 題目翻譯（繁體中文）

字串 "PAYPALISHIRING" 在給定的行數下以曲折（zigzag）模式書寫如下：
```
P   A   H   N
A P L S I I G
Y   I   R
```
然後逐行讀取得到："PAHNAPLSIIGYIR"

請編寫一個函數，根據給定的行數，將字串進行上述曲折排列後的結果。

**示例 1:**
```
輸入: s = "PAYPALISHIRING", numRows = 3
輸出: "PAHNAPLSIIGYIR"
```

**示例 2:**
```
輸入: s = "PAYPALISHIRING", numRows = 4
輸出: "PINALSIGYAHRPI"
解釋:
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3:**
```
輸入: s = "A", numRows = 1
輸出: "A"
```

**約束條件:**
- 1 <= s.length <= 1000
- s 由英文字母（大小寫）、',' 和 '.' 組成。
- 1 <= numRows <= 1000

# 2. 問題理解

這個問題要求實現一個「Z字形」或「曲折形」的字串轉換。具體來說：

1. **核心要求**：
    - 將輸入字串按照特定模式重新排列，形成一個「Z字形」或「曲折形」
    - 然後按照從上到下、從左到右的順序讀取字符，形成新的字串

2. **關鍵特性**：
    - 字符的排列遵循先向下移動 `numRows - 1` 步，然後向上移動 `numRows - 1` 步的模式
    - 當 `numRows = 1` 時，沒有曲折，直接返回原字串
    - 當 `numRows >= s.length` 時，所有字符都會在第一列（但仍然需要按照規則排列）

3. **邊界情況**：
    - 空字串：根據約束條件，不會出現
    - 單字符字串：直接返回原字串
    - `numRows = 1`：沒有曲折，直接返回原字串
    - `numRows >= s.length`：所有字符都會在同一列（但排列仍然需要遵循規則）

4. **潛在難點**：
    - 理解字符的排列模式
    - 計算每個字符在「曲折形」中的位置
    - 有效地構建結果字串

理解這個問題的關鍵是認識到，這裡的「曲折」不是真正的「Z」形，而是一種垂直的「之」字形路徑，其中字符按照固定的模式先向下，再向上移動。

# 3. 視覺解釋

上圖展示了字串 "PAYPALISHIRING" 在 numRows = 3 時的曲折排列方式。可以看到以下幾點：

1. 字符的排列遵循先向下，再向上的模式
2. 字符"P"在第一行，然後向下到"A"（第二行），再向下到"Y"（第三行）
3. 達到最底行後，開始向上移動："P"在第二行，再向上到"A"（第一行）
4. 然後再重複這個模式：向下到"L"（第二行），繼續向下到"I"（第三行），然後向上...

接下來，來看看當 numRows = 4 時的情況：



# 4. 思考過程

讓分析幾種可能的解決方案：

## 方法一：直接模擬曲折過程

最直觀的方法是完全模擬曲折過程，先創建一個二維矩陣來存儲字符的位置，然後按照曲折的路徑填充字符。最後，按從上到下、從左到右的順序讀取非空字符，形成結果字串。

**優點**：
- 思路直觀，易於理解
- 與問題描述的視覺化表示直接對應

**缺點**：
- 空間複雜度較高，需要創建大量可能為空的單元格
- 需要額外處理空格判斷

## 方法二：數學映射模型

觀察曲折模式後，可以發現一個數學規律：對於給定的行數 `numRows`，曲折模式的週期是 `2 * (numRows - 1)`。可以根據這個週期，直接計算每個字符應該位於哪一行。

然後，可以為每一行創建一個字串，按照字符的順序將其分配到對應的行，最後將所有行的字串連接起來。

**優點**：
- 空間效率更高，只需要 `numRows` 個字串
- 沒有空字符需要處理
- 計算邏輯清晰

**缺點**：
- 需要理解曲折模式的數學關係

## 方法三：按行填充

也可以反過來思考，直接計算每一行包含哪些原始字串中的字符。根據曲折模式，可以推導出每一行字符的索引模式。

**優點**：
- 避免直接模擬整個曲折路徑
- 可以直接構建結果字串

**缺點**：
- 需要推導每一行的索引模式，有一定的理解難度

## 最適合的解決方案選擇

對於這個問題，方法二「數學映射模型」是最合適的選擇。它既有良好的空間效率，又能直觀地映射曲折模式的數學關係。

將使用以下步驟實現：
1. 如果 `numRows = 1` 或 `s.length <= numRows`，直接返回原字串
2. 創建 `numRows` 個字串，分別對應每一行
3. 遍歷原始字串的每個字符，根據曲折模式的數學關係，決定將其添加到哪一行
4. 最後，將所有行的字串連接起來，形成結果

# 5. 最優解決方案開發

現在讓一步步開發最優解決方案。將採用方法二「數學映射模型」的思路。

首先，需要理解字符在曲折模式中的排列規律：

1. 對於 `numRows = n`，曲折模式的週期為 `2 * (n - 1)`
2. 在一個週期內，字符的行索引先從 0 增加到 n-1，然後再從 n-2 減少到 1

基於這個規律，可以計算原始字串中每個索引 `i` 的字符應該被放在哪一行。

讓用實例來走一遍這個過程：

```
s = "PAYPALISHIRING", numRows = 3
```

週期長度 = 2 * (3 - 1) = 4

創建 3 個字串，對應 3 行：
```
row0 = ""
row1 = ""
row2 = ""
```

現在，遍歷原始字串的每個字符：

1. 字符 'P' (i=0)：
    - i % 4 = 0，小於 numRows，所以在第 0 行
    - row0 = "P"

2. 字符 'A' (i=1)：
    - i % 4 = 1，小於 numRows，所以在第 1 行
    - row1 = "A"

3. 字符 'Y' (i=2)：
    - i % 4 = 2，小於 numRows，所以在第 2 行
    - row2 = "Y"

4. 字符 'P' (i=3)：
    - i % 4 = 3，大於等於 numRows，所以在第 (4 - 3 % 4 - 1) = 0 行（這是上升階段）
    - 實際上，可以直接使用公式：(2 * numRows - 2 - i % (2 * numRows - 2)) = 第 1 行
    - row1 = "AP"

5. 字符 'A' (i=4)：
    - i % 4 = 0，小於 numRows，所以在第 0 行
    - row0 = "PA"

依此類推...

最後，連接所有行的字串：row0 + row1 + row2 = "PA" + "APLSI" + "YIR" = "PAHNAPLSIIGYIR"

這個解決方案的時間複雜度是 O(n)，其中 n 是字串的長度，因為只需要遍歷一次原始字串。空間複雜度是 O(n)，用於存儲結果字串和中間的行字串。

這種方法直接計算每個字符應該在哪一行，不需要模擬整個曲折路徑，效率較高。

# 7. 複雜度分析

讓詳細分析這個解決方案的時間和空間複雜度：

## 時間複雜度

1. 遍歷原始字串的每個字符：O(n)，其中 n 是字串的長度
2. 計算每個字符的行索引：O(1)
3. 將字符添加到對應行的字串：平均情況下是 O(1)
4. 連接所有行的字串：O(n)

總體時間複雜度：O(n)

## 空間複雜度

1. `rows` 數組：O(numRows)，用於存儲每一行的字串
2. 每行字串中存儲的字符總數：O(n)
3. 結果字串：O(n)

總體空間複雜度：O(n)

在最壞情況下，當 numRows 接近 n 時，空間複雜度仍然是 O(n)，因為所有的輔助空間最終都與原始字串的長度成正比。

# 8. 優化與改進

已經實現了一個高效的解決方案，但還有一些可能的優化方向：

1. **預分配空間**：可以預先計算每一行的字符數量，然後為每一行的字串分配足夠的空間，減少字串動態擴容的次數。

2. **使用字節數組而非字串**：對於大型輸入，使用 `[]byte` 可能比使用 `string` 更有效率，因為 `string` 在 Go 中是不可變的。

3. **優化特殊情況**：可以添加更多的特殊情況處理，例如當 `numRows >= len(s)` 時，可以直接返回原始字串。

# 9. 測試策略


這個測試套件包含以下內容：

1. **基本功能測試**：測試標準輸入的正確轉換
2. **邊界情況測試**：測試特殊輸入，如單行、單字符、空字串等
3. **特殊情況測試**：測試行數等於或大於字串長度的情況
4. **複雜輸入測試**：測試包含不同字符的輸入
5. **性能測試**：測試大型輸入的處理效率
6. **基準測試**：評估算法的性能

通過這個全面的測試套件，可以確保的解決方案能夠正確、高效地處理各種輸入情況。