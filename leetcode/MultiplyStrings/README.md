# 1. Original Problem:

## Multiply Strings (LeetCode 43)

Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.

**Example 1:**
```
Input: num1 = "2", num2 = "3"
Output: "6"
```

**Example 2:**
```
Input: num1 = "123", num2 = "456"
Output: "56088"
```

**Constraints:**
- 1 <= num1.length, num2.length <= 200
- num1 and num2 consist of digits only.
- Both num1 and num2 do not contain any leading zero, except the number 0 itself.

## 字串相乘（LeetCode 43）

給定兩個以字串形式表示的非負整數 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘積，也用字串表示。

**注意：** 你不能使用任何內置的 BigInteger 庫或直接將輸入轉換為整數。

**示例 1：**
```
輸入: num1 = "2", num2 = "3"
輸出: "6"
```

**示例 2：**
```
輸入: num1 = "123", num2 = "456"
輸出: "56088"
```

**約束條件：**
- 1 <= num1.length, num2.length <= 200
- num1 和 num2 只包含數字。
- num1 和 num2 都不包含任何前導零，除了數字0本身。

# 2. 初步問題解析與心智建模

首先，讓我們仔細閱讀這個問題，提取關鍵資訊：

- 我們需要將兩個以字串形式表示的數字相乘
- 不能使用內置的大整數庫
- 不能直接將字串轉換為整數（因為可能會溢出）
- 需要以字串形式返回結果

看到這個問題，我們首先想到的是：這是一個在不轉換為整數的情況下進行數學運算的問題。

看看示例：
- "2" * "3" = "6"：這是最簡單的例子，單個數字的相乘
- "123" * "456" = "56088"：這是多位數的相乘

在解決這個問題之前，我們需要思考：我們在紙上是如何進行多位數乘法的？這就是我們需要模擬的過程。

讓我們通過心智模型來理解：當我們進行多位數乘法時，我們是從右到左，將第二個數的每一位與第一個數的每一位相乘，然後根據位置進行累加。

例如，對於 "123" * "456"：
- 首先，6 * 3 = 18，寫下 8，進位 1
- 然後，6 * 2 = 12，加上進位 1，得到 13，寫下 3，進位 1
- 接著，6 * 1 = 6，加上進位 1，得到 7
- 所以 6 * 123 = 738

依此類推，我們計算 5 * 123 和 4 * 123，然後將這些結果根據位置相加得到最終結果。

# 3. 問題理解與核心挑戰

**核心要求與約束：**
- 處理任意長度的數字字串（長度不超過200）
- 不能使用大整數庫或直接轉換為整數
- 需要以字串形式進行乘法運算

**輸入/輸出特徵：**
- 輸入：兩個非負整數的字串表示
- 輸出：一個表示它們乘積的字串
- 邊界情況：當一個數為 0 時，結果為 "0"

**核心挑戰：**
此問題的核心挑戰在於實現「小學乘法」的算法，但不能直接使用整數運算。我們需要：
1. 將字串中的每個字轉換為相應的數字
2. 按位相乘並處理進位
3. 將中間結果累加到最終結果
4. 處理前導零等特殊情況

本質上，這是將乘法運算轉化為字串操作的挑戰，需要精確模擬人工計算乘法的過程。

# 4. 視覺問題表示

讓我們通過視覺化來理解如何手動計算 "123" * "456"：

```
    1 2 3
  × 4 5 6
  -------
    7 3 8  (= 123 × 6)
  6 1 5 0  (= 123 × 50)
4 9 2 0 0  (= 123 × 400)
  -------
5 6 0 8 8  (最終結果)
```

這個過程可以分解為：
1. 計算 6 × 123 = 738
2. 計算 5 × 123 = 615，然後左移一位（表示十位）：6150
3. 計算 4 × 123 = 492，然後左移兩位（表示百位）：49200
4. 將以上結果相加：738 + 6150 + 49200 = 56088

但在實際編程中，我們可以使用另一種更直接的方法：

對於每一對位置 (i, j)，其中 i 來自第一個數字，j 來自第二個數字，我們計算 num1[i] × num2[j]，並將結果累加到位置 [i+j, i+j+1]。

例如，對於 "123" 和 "456"：
- 3(位置2) × 6(位置2) = 18，累加到位置 [4, 5]
- 3 × 5 = 15，累加到位置 [3, 4]
- ...依此類推

# 5. 問題模式識別

這個問題屬於「數學運算模擬」類型的問題，特別是「大數運算」的子類。

這類問題的關鍵特徵是：
- 需要處理超過語言內置數字類型範圍的數值
- 通常使用字串或數組來表示大數
- 需要模擬基本的算術運算（加法、減法、乘法、除法）

這個問題與其他大數問題（如大數加法、大數減法）有相似之處，但乘法運算更為複雜，因為需要處理更多的中間結果和進位。

對於這類問題，通常的解決策略是：
- 模擬手工計算過程
- 使用數組或字串存儲中間結果
- 分步處理每一位的運算和進位

# 6. 策略性問題解決框架

對於字串數學運算類問題，我們可以遵循以下通用方法：

1. **理解運算規則**：首先，確保完全理解所需模擬的數學運算（本例中是乘法）的規則和步驟。

2. **選擇適當的數據結構**：
    - 對於乘法，我們可以使用數組來存儲中間結果
    - 數組的大小應該足以容納最大可能的結果（對於乘法，結果的最大長度是兩個輸入長度之和）

3. **逐位計算策略**：
    - 從右到左（從低位到高位）處理每一位
    - 對於乘法，計算每對位置的乘積並累加到相應位置
    - 正確處理進位

4. **結果處理**：
    - 處理前導零
    - 將最終結果轉換回所需的輸出格式（字串）

5. **邊界情況檢查**：
    - 檢查零和其他特殊輸入
    - 確保處理單個數字的情況

# 7. 算法設計（編碼前）

讓我們設計一個解決這個問題的算法：

```
函數 multiply(num1, num2):
    # 特殊情況處理
    如果 num1 = "0" 或 num2 = "0"，返回 "0"
    
    # 初始化結果數組
    結果長度 = num1的長度 + num2的長度
    結果數組 = 新建一個長度為結果長度的數組，初始值都是0
    
    # 從右到左遍歷兩個數字
    對於 i 從 num1的長度-1 到 0:
        對於 j 從 num2的長度-1 到 0:
            # 計算當前位置的乘積
            乘積 = (num1[i] - '0') * (num2[j] - '0')
            
            # 將乘積加到對應位置
            位置1 = i + j + 1  # 個位
            位置2 = i + j      # 進位
            
            總和 = 乘積 + 結果數組[位置1]
            結果數組[位置1] = 總和 % 10
            結果數組[位置2] += 總和 / 10
    
    # 構建結果字串
    結果字串 = ""
    對於 結果數組 中的每個數字:
        如果 (數字 != 0 或 結果字串不為空):
            將數字添加到結果字串
    
    # 如果結果字串為空，返回 "0"，否則返回結果字串
    如果 結果字串為空，返回 "0"
    否則，返回 結果字串
```

手動驗證：以 "123" 和 "456" 為例：
- 初始化結果數組為 [0, 0, 0, 0, 0, 0]
- 3 * 6 = 18，放置在位置 [4, 5]，數組變為 [0, 0, 0, 0, 1, 8]
- 3 * 5 = 15，放置在位置 [3, 4]，數組變為 [0, 0, 0, 1, 6, 8]
- ...依此類推
- 最終結果數組應為 [0, 5, 6, 0, 8, 8]
- 去掉前導零後結果為 "56088"

# 8. 視覺解釋

讓我們通過圖表來可視化這個算法的執行過程：

對於 "123" * "456"，我們可以將計算過程表示為一個表格：

```
位置索引： 0  1  2  3  4  5
初始數組： [0, 0, 0, 0, 0, 0]

計算 3*6=18:
位置 [4,5] += 18
數組變為：  [0, 0, 0, 0, 1, 8]

計算 3*5=15:
位置 [3,4] += 15
數組變為：  [0, 0, 0, 1, 6, 8]

計算 3*4=12:
位置 [2,3] += 12
數組變為：  [0, 0, 1, 3, 6, 8]

計算 2*6=12:
位置 [3,4] += 12
數組變為：  [0, 0, 1, 4, 8, 8]

計算 2*5=10:
位置 [2,3] += 10
數組變為：  [0, 0, 2, 4, 8, 8]

計算 2*4=8:
位置 [1,2] += 8
數組變為：  [0, 0, 10, 4, 8, 8]
處理進位後： [0, 1, 0, 4, 8, 8]

計算 1*6=6:
位置 [2,3] += 6
數組變為：  [0, 1, 0, 10, 8, 8]
處理進位後： [0, 1, 1, 0, 8, 8]

計算 1*5=5:
位置 [1,2] += 5
數組變為：  [0, 1, 6, 0, 8, 8]

計算 1*4=4:
位置 [0,1] += 4
數組變為：  [0, 5, 6, 0, 8, 8]

最終結果去掉前導零： "56088"
```

# 9. 解決方案開發過程

**方法一：直接模擬乘法過程（暴力解法）**

最直觀的方法是直接模擬手工乘法：對於第二個數的每一位，我們將其與第一個數相乘，然後將結果左移相應的位數，最後將所有中間結果相加。

但這種方法需要實現大數加法，並且需要進行多次加法運算，效率較低。

**方法二：優化的乘法算法（單次遍歷）**

一個更高效的方法是使用我們之前描述的算法：
- 使用一個足夠大的數組來存儲中間結果
- 對於每一對位置 (i, j)，計算 num1[i] * num2[j]，並將結果添加到位置 [i+j, i+j+1]
- 這樣我們只需要一次遍歷就可以得到最終結果

這種方法的優勢在於：
- 避免了多次大數加法操作
- 直接在一個數組中累積所有中間結果
- 只需要一次遍歷就可以得到最終結果

關鍵洞見：通過智能地選擇中間結果的存儲位置，我們可以在一次遍歷中完成所有計算。

**方法三：進一步優化（實時處理進位）**

我們可以在算法中實時處理進位，這樣可以減少後處理的工作量：
- 每次計算完一對位置的乘積後，立即處理進位
- 這樣最終得到的結果數組就不需要額外的進位處理

# 10. 實際示例演練

讓我們用例子 "123" * "456" 詳細跟踪整個算法執行過程：

1. 初始化結果數組 `res = [0, 0, 0, 0, 0, 0]`（長度為 3+3=6）

2. 對於 num1 的每一位和 num2 的每一位進行乘法運算：

    - i=2, j=2 (3*6):
        - 乘積 = 3 * 6 = 18
        - 位置1 = 2+2+1 = 5
        - 位置2 = 2+2 = 4
        - res[5] += 18 % 10 = 8
        - res[4] += 18 / 10 = 1
        - 結果數組： [0, 0, 0, 0, 1, 8]

    - i=2, j=1 (3*5):
        - 乘積 = 3 * 5 = 15
        - 位置1 = 2+1+1 = 4
        - 位置2 = 2+1 = 3
        - res[4] = 1 + 15 % 10 = 1 + 5 = 6
        - res[3] += 15 / 10 = 1
        - 結果數組： [0, 0, 0, 1, 6, 8]

    - i=2, j=0 (3*4):
        - 乘積 = 3 * 4 = 12
        - 位置1 = 2+0+1 = 3
        - 位置2 = 2+0 = 2
        - res[3] = 1 + 12 % 10 = 1 + 2 = 3
        - res[2] += 12 / 10 = 1
        - 結果數組： [0, 0, 1, 3, 6, 8]

    - i=1, j=2 (2*6):
        - 乘積 = 2 * 6 = 12
        - 位置1 = 1+2+1 = 4
        - 位置2 = 1+2 = 3
        - res[4] = 6 + 12 % 10 = 6 + 2 = 8
        - res[3] = 3 + 12 / 10 = 3 + 1 = 4
        - 結果數組： [0, 0, 1, 4, 8, 8]

   繼續這個過程直到處理完所有位...

3. 最終結果數組： [0, 5, 6, 0, 8, 8]

4. 將數組轉換為字串，跳過前導零： "56088"

# 11. Golang 實現

```go
func multiply(num1 string, num2 string) string {
    // 特殊情況處理
    if num1 == "0" || num2 == "0" {
        return "0"
    }
    
    // 初始化結果數組，長度為兩個數字的長度之和
    length := len(num1) + len(num2)
    result := make([]int, length)
    
    // 從右到左遍歷兩個數字
    for i := len(num1) - 1; i >= 0; i-- {
        for j := len(num2) - 1; j >= 0; j-- {
            // 計算當前位置的乘積
            mul := int(num1[i] - '0') * int(num2[j] - '0')
            
            // 結果位置
            p1 := i + j + 1 // 個位位置
            p2 := i + j     // 進位位置
            
            // 將乘積加到對應位置
            sum := mul + result[p1]
            result[p1] = sum % 10
            result[p2] += sum / 10
        }
    }
    
    // 構建結果字串
    var sb strings.Builder
    for _, digit := range result {
        // 跳過前導零
        if sb.Len() == 0 && digit == 0 {
            continue
        }
        sb.WriteByte(byte(digit) + '0')
    }
    
    // 如果結果為空，返回 "0"
    if sb.Len() == 0 {
        return "0"
    }
    
    return sb.String()
}
```

# 12. 實現執行演練

讓我們以 "123" * "456" 為例，詳細追蹤代碼執行過程：

1. 首先檢查特殊情況：兩個輸入都不是 "0"，繼續執行

2. 初始化結果數組：`result = [0, 0, 0, 0, 0, 0]`（長度為 3+3=6）

3. 開始遍歷：
    - i=2 (num1 的最後一位 "3")
        - j=2 (num2 的最後一位 "6")
            - mul = 3 * 6 = 18
            - p1 = 2+2+1 = 5
            - p2 = 2+2 = 4
            - sum = 18 + result[5] = 18 + 0 = 18
            - result[5] = 18 % 10 = 8
            - result[4] += 18 / 10 = 0 + 1 = 1
            - 結果數組： [0, 0, 0, 0, 1, 8]

        - j=1 (num2 的中間一位 "5")
            - mul = 3 * 5 = 15
            - p1 = 2+1+1 = 4
            - p2 = 2+1 = 3
            - sum = 15 + result[4] = 15 + 1 = 16
            - result[4] = 16 % 10 = 6
            - result[3] += 16 / 10 = 0 + 1 = 1
            - 結果數組： [0, 0, 0, 1, 6, 8]

      ... 依此類推

4. 遍歷完成後，結果數組為 [0, 5, 6, 0, 8, 8]

5. 構建結果字串：
    - 跳過前導零
    - 將數組轉換為字串 "56088"

6. 返回結果 "56088"

# 13. 複雜度分析

**時間複雜度分析：**

- 我們遍歷 num1 的每一位（長度為 m）
- 對於 num1 的每一位，我們遍歷 num2 的每一位（長度為 n）
- 在每次迭代中，我們進行常數時間的操作（乘法、加法、取模等）
- 因此，總時間複雜度為 O(m*n)，其中 m 和 n 分別是 num1 和 num2 的長度

**空間複雜度分析：**

- 我們使用一個長度為 m+n 的數組來存儲結果
- 構建結果字串時，我們使用一個長度為 m+n 的字串
- 因此，總空間複雜度為 O(m+n)

這個複雜度是最優的，因為：
- 時間複雜度：我們必須至少處理每對數字一次，所以 O(m*n) 是必要的
- 空間複雜度：結果長度最多為 m+n，所以 O(m+n) 是必要的

# 14. 優化與改進

雖然我們的算法已經相當高效，但還有一些可能的改進方向：

1. **內存優化**：
    - 如果我們確定輸入的範圍，可以使用更小的數據類型來節省內存
    - 例如，對於字串數字，每一位都可以用一個字節表示

2. **算法優化**：
    - 對於非常大的數字，可以考慮使用更高效的乘法算法，如 Karatsuba 算法
    - Karatsuba 算法的時間複雜度為 O(n^log₂3)，約為 O(n^1.585)，比傳統的 O(n²) 更快

3. **並行計算**：
    - 對於非常大的數字，可以考慮使用並行計算來加速乘法
    - 每個線程負責計算一部分結果，然後合併

4. **FFT 優化**：
    - 對於極大的數字，可以考慮使用快速傅里葉變換 (FFT) 來加速乘法
    - FFT 的時間複雜度為 O(n log n)，比傳統算法更快

# 15. 一般問題解決智慧

從這個問題中，我們可以提取以下關鍵教訓：

1. **模擬真實過程**：有時候，最直接的解決方案就是模擬我們手動解決問題的過程。在這個問題中，我們模擬了手工乘法的過程。

2. **數據結構的選擇**：選擇適當的數據結構對於高效解決問題至關重要。在這個問題中，我們使用數組來有效地存儲和操作中間結果。

3. **關注細節**：在處理數學運算時，細節非常重要，例如進位處理、前導零的移除等。

4. **從具體到抽象**：通過具體例子理解問題，然後抽象出一般算法，是有效的問題解決策略。

5. **分而治之**：將大問題分解為小問題（例如，將乘法分解為單位數字之間的乘法）可以簡化解決方案。

對於類似的問題，可以應用以下思考框架：
- 理解問題基本操作（如加法、乘法等）
- 尋找模擬這些操作的方法
- 注意數據類型和範圍限制
- 考慮邊界情況和特殊輸入

# 16. 測試策略

這個測試涵蓋了各種情況：
- 基本的單位數乘法
- 多位數乘法
- 特殊情況（如零乘法）
- 邊界情況（如大數相乘）
- 性能測試（非常大的數字）

通過這些測試，我們可以確保我們的實現在各種情況下都能正確工作。