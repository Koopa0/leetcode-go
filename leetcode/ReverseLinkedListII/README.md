# LeetCode 92: Reverse Linked List II

## 1. 問題定義

### 原始問題 (英文)
```
Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

Implement the solution in-place with O(1) extra memory.
```

### 問題翻譯 (繁體中文)
```
給定單向鏈結串列的表頭 head 以及兩個整數 left 和 right (其中 left <= right)，將鏈結串列中從 left 位置到 right 位置的節點進行反轉，並返回反轉後的鏈結串列。

請以原地算法實現此解法，使用 O(1) 的額外記憶體空間。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: head = [1,2,3,4,5], left = 2, right = 4
  輸出: [1,4,3,2,5]
  解釋: 將位置 2 到位置 4 的節點反轉
  ```
- **範例 2:**
  ```
  輸入: head = [5], left = 1, right = 1
  輸出: [5]
  解釋: 只有一個節點，無需反轉
  ```

- **限制條件:**
    - 鏈結串列中的節點數量在範圍 [1, 500] 內
    - -500 <= Node.val <= 500
    - 1 <= left <= right <= n (n 為鏈結串列長度)

## 2. 問題理解

### 初始反應與心智模型
- 這是一個部分鏈結串列反轉問題，比完整反轉鏈結串列更加複雜
- 我需要找到反轉區段的前一個節點、開始反轉的節點、結束反轉的節點以及反轉區段的後一個節點
- 反轉操作需要特別處理指針的重新連接，確保部分反轉後整個鏈結串列仍然是完整的
- 當 left=1 時需要特別處理，因為這意味著要反轉的部分包含頭節點

### 問題分解
- 找到第 (left-1) 個節點，作為反轉區段的前一個節點
- 找到第 left 個節點，作為反轉開始的節點
- 執行從 left 到 right 的反轉操作
- 將反轉後的區段與原始鏈結串列的其餘部分重新連接起來
- 處理 left=1 的特殊情況（反轉包含頭節點）

### 視覺表示
```
原始鏈結串列:  1 -> 2 -> 3 -> 4 -> 5 -> NULL
              |    |         |    |
           prevL  left      right nextR

反轉後鏈結串列: 1 -> 4 -> 3 -> 2 -> 5 -> NULL
               |                   |
              prevL              nextR
```

- 這個視覺化幫助我們理解需要找到的四個關鍵位置：prevL、left、right、nextR
- 反轉後，left 節點將指向 nextR，prevL 將指向 right 節點

## 3. 模式識別與知識映射

### 演算法模式分類
- [x] 鏈結串列操作
- [ ] 雙指針/滑動窗口
- [ ] 二分搜尋/二分答案
- [ ] 深度優先搜尋 (DFS)
- [ ] 廣度優先搜尋 (BFS)
- [ ] 回溯法
- [ ] 動態規劃 (DP)
- [ ] 貪婪演算法
- [ ] 分治法
- [ ] 圖論演算法
- [ ] 樹問題
- [ ] 堆疊/佇列
- [ ] 優先佇列/堆
- [ ] 雜湊表/集合
- [ ] 排序演算法
- [ ] 位元操作
- [ ] 其他: ________

- 識別依據:
    - 這是一個明顯的鏈結串列操作問題，需要重新安排節點之間的連接關係
    - 解決這類問題的關鍵是正確處理指針的重新連接，並追蹤關鍵節點的位置

### 知識連接
- 這個問題結合了鏈結串列遍歷和鏈結串列反轉的基本操作
- 需要理解指針操作的基本原理，尤其是如何在不丟失引用的情況下修改節點連接
- 需要理解鏈結串列反轉的邏輯，並將其應用於部分區段

### 相似問題比較
- LeetCode 206: Reverse Linked List (完整反轉鏈結串列)
    - 相似點: 都涉及鏈結串列反轉操作
    - 差異點: 本題僅需反轉部分區段，需要處理與未反轉部分的連接
- LeetCode 25: Reverse Nodes in k-Group (每 k 個一組反轉鏈結串列)
    - 相似點: 都需要處理部分反轉
    - 差異點: k-Group 問題需要多次反轉不同的區段

## 4. 演算法直覺發展

### 直覺建立
- 使用迴圈找到反轉起始位置前的節點和反轉起始節點
- 使用類似 Reverse Linked List 的方法反轉指定區段
- 將反轉後的區段與原始鏈結串列的其餘部分重新連接

### 多角度思考
- 迭代解法：逐一反轉節點，維護前後連接關係
    - 優點：直觀，使用 O(1) 額外空間
    - 缺點：需要小心處理各種邊界情況
- 遞迴解法：將問題分解為找到反轉區段，執行反轉，然後重新連接
    - 優點：邏輯清晰
    - 缺點：可能使用 O(n) 的堆疊空間，不符合空間要求
- 對於此問題，迭代方法似乎更符合要求，因為它使用 O(1) 額外空間

## 5. 解法發展過程

### 方法 1: 兩次遍歷解法

#### 思考過程
- 最直接的方法是先找到需要反轉的區段，然後進行反轉
- 第一次遍歷找到反轉區段的前後節點
- 第二次遍歷執行實際的反轉操作
- 這種方法簡單明瞭，容易理解

#### 演算法設計
```
1. 找到第 (left-1) 個節點 prevL
2. 找到第 left 個節點 leftNode
3. 找到第 right 個節點 rightNode
4. 找到第 (right+1) 個節點 nextR
5. 將 leftNode 到 rightNode 之間的節點反轉
6. 重新連接: prevL -> rightNode, leftNode -> nextR
7. 處理 left=1 的特殊情況
```

#### 實作細節
- 使用了虛擬頭節點 (dummy) 來簡化處理，尤其是當 left=1 時
- Go 中使用指針操作進行鏈結串列的修改
- 明確區分反轉前後的節點角色，確保正確連接

#### 複雜度分析
- **時間複雜度**: O(n) — 需要遍歷鏈結串列來找到反轉區段，最壞情況下需要遍歷整個鏈結串列
- **空間複雜度**: O(1) — 僅使用常數額外空間來儲存指針變數

#### 解法評估
- 優點：邏輯清晰，易於理解
- 缺點：需要遍歷整個反轉區段
- 在面試情境中，這是一個可接受的解法，因為它符合時間和空間複雜度要求

### 方法 2: 一次遍歷解法

#### 關鍵見解
- 在前一種方法中，我們需要遍歷整個反轉區段
- 我們可以優化為一次遍歷，同時查找和反轉
- 關鍵是使用移動指針的方式進行反轉，而不是交換節點值

#### 優化策略
```
1. 使用 dummy 節點簡化邊界情況
2. 找到 prevL 節點
3. 設置 curr 為開始反轉的節點 (left 節點)
4. 使用頭插法在遍歷過程中反轉節點
5. 直接重新連接，不需要額外尋找 rightNode 和 nextR
```

#### 實作改進
- 使用頭插法進行反轉，每次將下一個節點移到反轉區段的頭部
- 這種方法減少了變數追蹤的數量，邏輯更加簡潔
- 充分利用了 Go 的指針操作特性

#### 複雜度分析
- **時間複雜度**: O(n) — 雖然仍需要遍歷到反轉區段的末尾，但只需一次遍歷
- **空間複雜度**: O(1) — 只使用常數個額外變數

#### 解法評估
- 優點：更加簡潔，只需一次遍歷就能完成反轉
- 缺點：頭插法的邏輯可能不如標準反轉直觀
- 在面試情境中，這種解法展示了更好的編程技巧和對鏈結串列操作的深入理解

### 方法 3: 最優解法 (頭插法優化)

#### 突破性思考
- 頭插法是解決此問題的最佳方法
- 我們可以進一步優化代碼結構，使其更加清晰
- 使用更直觀的變數命名可以提高代碼可讀性

#### 最優演算法
```
1. 創建虛擬頭節點以簡化邊界情況
2. 找到反轉區段的前一個節點 (prevL)
3. 當前節點設為反轉起始節點 (leftNode)
4. 使用頭插法: 在每次迭代中，將 curr.next 移到反轉區段的開頭
5. 總共需要 (right-left) 次這樣的操作
```

#### 實作精華
- 處理了邊界情況：空鏈結串列或無需反轉的情況
- 使用更具描述性的變數名稱，提高代碼可讀性
- 每個步驟都有明確的目的和邏輯

#### 複雜度分析
- **時間複雜度**: O(n) — 遍歷到反轉區段末尾，最壞情況為 O(n)
- **空間複雜度**: O(1) — 僅使用常數額外空間

#### 從暴力解法到最優解法的思考演進
- 最初的想法是分段處理：找到反轉區段，反轉，然後重新連接
- 優化思路轉向一次遍歷，減少重複操作
- 頭插法提供了最簡潔的解決方案，無需額外的反轉過程
- 每一步優化都顯著簡化了代碼，同時保持時間和空間複雜度不變

## 6. 範例演練與 Go 實作

### 完整範例追蹤
追蹤範例輸入: `[1,2,3,4,5]`, `left=2`, `right=4` 使用最優解法:

1. 初始狀態:
    - 輸入: `[1,2,3,4,5]`, `left=2`, `right=4`
    - 建立 dummy 節點: `dummy -> 1 -> 2 -> 3 -> 4 -> 5`
    - prevL = dummy

2. 找到 prevL (反轉區段前的節點):
    - 移動 prevL 到第 (left-1) 個節點，即節點 1
    - prevL = 1

3. 設置 leftNode (反轉起始節點):
    - leftNode = prevL.Next = 2

4. 第一次頭插法操作 (i=0):
    - nodeToMove = leftNode.Next = 3
    - leftNode.Next = nodeToMove.Next = 4
    - 目前鏈結串列: `dummy -> 1 -> 2 -> 4 -> 5`
    - 將 nodeToMove 插入到 prevL 之後:
        - nodeToMove.Next = prevL.Next = 2
        - prevL.Next = nodeToMove = 3
    - 目前鏈結串列: `dummy -> 1 -> 3 -> 2 -> 4 -> 5`

5. 第二次頭插法操作 (i=1):
    - nodeToMove = leftNode.Next = 4
    - leftNode.Next = nodeToMove.Next = 5
    - 目前鏈結串列: `dummy -> 1 -> 3 -> 2 -> 5`
    - 將 nodeToMove 插入到 prevL 之後:
        - nodeToMove.Next = prevL.Next = 3
        - prevL.Next = nodeToMove = 4
    - 目前鏈結串列: `dummy -> 1 -> 4 -> 3 -> 2 -> 5`

6. 第三次頭插法操作 (i=2):
    - 因為 right-left = 4-2 = 2，所以只需要執行 2 次頭插法操作
    - 反轉完成

7. 最終狀態:
    - 輸出: `[1,4,3,2,5]`

### 所有方法的性能比較
```
| 方法            | 時間複雜度 | 空間複雜度 | 範例執行時間 |
|-----------------|------------|------------|--------------|
| 兩次遍歷解法    | O(n)       | O(1)       | 0 ms        |
| 一次遍歷解法    | O(n)       | O(1)       | 0 ms        |
| 最優解法 (頭插法)| O(n)      | O(1)       | 0 ms        |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 使用虛擬頭節點 (dummy node) 簡化邊界情況處理，特別是處理頭節點的修改
- 明確的變數命名反映了它們的用途和節點在鏈結串列中的位置
- 分解複雜操作為清晰的子步驟，提高代碼可讀性

### 錯誤處理與邊界情況
- 處理空鏈結串列的情況
- 處理 left=right 的情況，即無需反轉
- 使用 dummy 節點簡化 left=1 (反轉包含頭節點) 的特殊情況

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2 分鐘
    - 理解反轉區段的定義和邊界
    - 確認輸入和輸出的格式
- 初始解法提案: ~5 分鐘
    - 提出兩次遍歷的方法
    - 解釋找到反轉區段和執行反轉的步驟
- 優化討論: ~5-7 分鐘
    - 討論如何優化為一次遍歷
    - 介紹頭插法的概念和優勢
- 代碼編寫: ~10-15 分鐘
    - 實作最優解法
    - 確保處理所有邊界情況
- 測試與除錯: ~5 分鐘
    - 使用範例測試代碼
    - 檢查特殊情況：left=1, left=right 等

### 面試互動模擬
- 我會首先解釋問題：「這個問題要求我們反轉鏈結串列中指定區段的節點，同時保持其餘部分的順序不變。」
- 接著說明我的思考過程：「我們需要找到反轉區段的前一個節點，然後使用頭插法逐一移動節點。這種方法只需一次遍歷，使用 O(1) 的額外空間。」
- 強調關鍵點：「使用 dummy 節點可以簡化 left=1 的情況，頭插法可以優雅地完成反轉操作。」
- 解釋程式碼實作：「我們首先找到 prevL 節點，設置 leftNode 為反轉起始節點，然後使用頭插法進行 (right-left) 次節點移動...」

### 潛在追問問題
- 如果輸入規模增大，你的解法如何擴展？
    - 我的解法時間複雜度是 O(n)，空間複雜度是 O(1)，已經是最優解法，可以很好地處理大規模輸入。
- 如果記憶體受限，你會如何優化你的解法？
    - 我的解法已經使用 O(1) 額外空間，是記憶體效率最高的解法。
- 如何延伸你的解法來處理更複雜的問題，例如每 k 個節點一組進行反轉？
    - 可以將此解法作為子程序，重複應用於每個 k 節點組，需要處理好每組之間的連接關係。

## 9. 知識整合與學習

### 問題解決洞見
- 鏈結串列操作中，直接修改指針比交換值更高效
- 虛擬頭節點 (dummy node) 是簡化邊界情況的強大技巧
- 頭插法是鏈結串列反轉的簡潔解法，減少了變數和操作的數量

### 心智模型構建
- 鏈結串列問題通常可以通過追蹤關鍵節點來解決
- 反轉操作可以通過修改指針方向或節點位置實現
- 複雜的鏈結串列操作可以通過圖形化表示來簡化理解

### 錯誤模式識別
- 常見錯誤：丟失節點引用，導致鏈結串列斷裂
- 解決方法：使用臨時變數保存節點引用
- 另一個錯誤：邊界情況處理不當，尤其是反轉包含頭節點的情況

### 知識圖譜擴展
- 相關資源：《Cracking the Coding Interview》中的鏈結串列章節
- 進階技巧：快慢指針、循環檢測、雙向鏈結串列操作
- 這種反轉技術也適用於其他資料結構，如陣列和字串的部分反轉