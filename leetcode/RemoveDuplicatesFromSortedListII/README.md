# LeetCode 82: 移除排序鏈表中的重複元素 II

## 1. 問題定義

### 原始問題 (English)
```
Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.

Example 1:
Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]
Explanation: The linked list has duplicates of values 3 and 4. After removing them, the list becomes [1,2,5].

Example 2:
Input: head = [1,1,1,2,3]
Output: [2,3]
Explanation: The linked list has duplicates of value 1. After removing them, the list becomes [2,3].

Constraints:
- The number of nodes in the list is in the range [0, 300].
- -100 <= Node.val <= 100
- The list is guaranteed to be sorted in ascending order.
```

### 問題翻譯 (繁體中文)
```
給定一個已排序的鏈表的頭節點，刪除所有數字重複的節點，只留下原始鏈表中不重複的數字。返回同樣排序的鏈表。

範例 1：
輸入：head = [1,2,3,3,4,4,5]
輸出：[1,2,5]
解釋：鏈表中有值為 3 和 4 的重複元素。移除後，列表變為 [1,2,5]。

範例 2：
輸入：head = [1,1,1,2,3]
輸出：[2,3]
解釋：鏈表中有值為 1 的重複元素。移除後，列表變為 [2,3]。

限制條件：
- 鏈表中的節點數量範圍是 [0, 300]。
- -100 <= 節點值 <= 100
- 鏈表保證按升序排序。
```

### 範例與限制條件
- **範例 1：**
  ```
  輸入：head = [1,2,3,3,4,4,5]
  輸出：[1,2,5]
  解釋：鏈表中有值為 3 和 4 的重複元素。移除後，列表變為 [1,2,5]。
  ```
- **範例 2：**
  ```
  輸入：head = [1,1,1,2,3]
  輸出：[2,3]
  解釋：鏈表中有值為 1 的重複元素。移除後，列表變為 [2,3]。
  ```

- **限制條件：**
    - 鏈表中的節點數量範圍是 [0, 300]。
    - -100 <= 節點值 <= 100
    - 鏈表保證按升序排序。

## 2. 問題理解

### 初始反應與心智模型
- 我對這個問題的第一反應：這是一個鏈表處理問題，需要我們識別並移除所有重複的節點。
- 核心挑戰在於：我們需要完全移除出現多次的值，而不是像「移除排序鏈表中的重複元素 I」那樣只保留一個。
- 我們需要用某種方式標記出哪些值是重複的，然後在遍歷鏈表時跳過這些值。
- 視覺上，我可以想像一個指針遍歷鏈表，檢查相鄰節點的值是否相同，並在發現重複時標記後進行移除。

### 問題拆解
- 核心子問題：
    1. 如何識別重複的節點？
    2. 如何移除已識別的重複節點？
    3. 如何處理鏈表頭部可能出現的重複節點？
- 本質操作：
    - 鏈表的遍歷
    - 節點值的比較
    - 鏈表的重新連接（移除節點）
- 需要處理的邊界情況：
    - 空鏈表
    - 只有一個節點的鏈表
    - 所有節點都是重複的情況
    - 頭節點就是重複節點的情況

### 視覺表示
```
原始鏈表: 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 -> NULL

步驟 1: 發現 3 重複
1 -> 2 -> [3] -> [3] -> 4 -> 4 -> 5 -> NULL
           ↑      ↑
        將被移除的節點

步驟 2: 移除 3 後
1 -> 2 ----------------> 4 -> 4 -> 5 -> NULL

步驟 3: 發現 4 重複
1 -> 2 ----------------> [4] -> [4] -> 5 -> NULL
                          ↑      ↑
                       將被移除的節點

步驟 4: 最終結果
1 -> 2 -----------------------------> 5 -> NULL
```

這個視覺化幫助我理解在移除重複節點時，我們需要維護一個指向前一個非重複節點的指針，以便在發現重複時可以正確地重新連接鏈表。

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [x] 鏈表操作
    - [x] 雙指針
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/隊列
    - [ ] 優先隊列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據：
    - 題目明確要求對鏈表進行操作，需要刪除特定節點
    - 需要遍歷鏈表並比較相鄰節點，這是典型的鏈表遍歷問題
    - 使用雙指針可以有效地追蹤和移除重複節點

### 知識連結
- 這個問題涉及的基本資訊科學概念：
    - 鏈表數據結構的基本操作（新增、刪除、遍歷）
    - 指針操作和記憶體管理
    - 節點連接和重新連接
- 相關的數據結構知識：
    - 單向鏈表的特性：只能向前訪問
    - 鏈表節點的結構：值和下一節點的指針

### 相似問題比較
- 與 LeetCode 83: 移除排序鏈表中的重複元素 I 相似
    - 相同點：都需要處理排序鏈表中的重複元素
    - 不同點：#83 只需要移除重複元素保留一個，而本題需要完全移除所有重複元素
- 與 LeetCode 203: 移除鏈表元素 相似
    - 相同點：都需要從鏈表中移除特定元素
    - 不同點：#203 是移除指定值的所有節點，本題是移除所有重複的值

## 4. 算法直覺發展

### 直覺建立
- 實際生活類比：想像整理一疊按號碼排序的檔案，如果發現有多份相同號碼的檔案，我們不是保留一份，而是將所有相同號碼的檔案都丟棄。
- 初步感覺：使用一個前導節點（dummy node）可以簡化頭部處理，然後用雙指針遍歷並檢測重複。
- 驗證直覺：透過手動模擬範例，確認這種方法能夠正確處理各種情況，包括頭部重複和連續多個重複序列。

### 多角度思考
- 不同的解題角度：
    - 雙指針迭代方法：使用前置節點和當前節點進行遍歷
    - 遞迴方法：分解為子問題（處理頭節點可能的重複，然後遞迴處理剩餘鏈表）
    - 使用雜湊表記錄出現次數，然後重建鏈表（雖然這對已排序鏈表來說不是最佳解）
- 對於這種鏈表問題，迭代雙指針方法通常最直觀且效率高。

## 5. 解題方案發展歷程

### 方案 1：雙指針迭代（基本方案）

#### 思路過程
- 最直接的方法是使用雙指針遍歷鏈表，檢測相鄰節點是否重複。
- 使用一個前導節點（dummy node）來簡化對頭節點的處理。
- 當發現重複值時，持續前進直到找到不同的值，然後跳過所有重複節點。
- 這個方法簡單明瞭，但需要謹慎處理指針的更新和移動。

#### 算法設計
```
1. 創建一個前導節點 dummy，指向頭節點
2. 使用 prev 指針指向 dummy
3. 使用 curr 指針遍歷鏈表
4. 當 curr 和 curr.next 存在且值相同時：
   a. 記錄這個重複值
   b. 向前移動 curr 直到不再是這個重複值
   c. prev.next = curr（跳過所有重複節點）
5. 如果沒有發現重複：
   a. prev = prev.next（移動到下一個節點）
6. curr = prev.next（從 prev 之後繼續遍歷）
7. 返回 dummy.next
```

#### 實現細節
- 使用了 Go 中的指針操作來重新連接鏈表節點
- 前導節點（dummy node）是處理鏈表問題的常用技巧，可以統一頭節點處理
- 需要注意 nil 檢查，避免空指針異常
- 在發現重複值時，需要持續前進直到找到不同的值，這需要仔細處理指針移動

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是鏈表的長度。我們最多遍歷鏈表兩次（一次查找重複，一次跳過重複）。
- **空間複雜度**：O(1)，只使用了常數額外空間（幾個指針變數）。

#### 解法評估
- 優點：
    - 簡單直觀，容易理解
    - 使用常數額外空間
    - 只需遍歷一次鏈表
- 缺點：
    - 指針操作較複雜，容易出錯
    - 需要特別處理頭節點重複的情況
- 在面試環境中，這個解法是完全可接受的，因為它達到了最優的時間和空間複雜度。

### 方案 2：遞迴解法

#### 關鍵洞察
- 我們可以從不同角度思考：將問題分解為處理頭節點的子問題和處理剩餘鏈表的子問題。
- 如果頭節點是重複的，我們可以跳過所有重複值，然後遞迴處理剩餘部分。
- 如果頭節點不是重複的，我們可以保留它，然後遞迴處理剩餘部分。
- 這種方法簡化了邏輯，但需要理解遞迴思維。

#### 優化策略
```
1. 如果鏈表為空或只有一個節點，直接返回
2. 檢查頭節點和下一個節點的值是否相同：
   a. 如果相同，這是重複值：
      i. 向前移動直到找到不同的值
      ii. 遞迴處理剩餘部分
   b. 如果不同，頭節點不是重複值：
      i. 頭節點的下一個指向遞迴處理剩餘部分的結果
      ii. 返回頭節點
```

#### 實現改進
- 遞迴實現更簡潔，代碼量減少
- 不需要顯式的前導節點，因為遞迴本身處理了邊界情況
- 邏輯更清晰：要麼跳過重複，要麼保留非重複
- 但需要注意函數呼叫堆疊的成本

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是鏈表的長度。雖然有遞迴，但每個節點最多被訪問一次。
- **空間複雜度**：O(n)，最壞情況下的遞迴堆疊深度（如果鏈表中沒有重複元素）。

#### 解法評估
- 優點：
    - 代碼更簡潔，邏輯清晰
    - 不需要特殊處理頭節點
- 缺點：
    - 遞迴調用有額外的空間成本
    - 對於非常長的鏈表可能導致堆疊溢出
- 這個解法在面試中展示了對問題的遞迴思考能力，但需要注意解釋遞迴邏輯和可能的空間成本。

### 方案 3：雙指針優化（最佳方案）

#### 突破性思維
- 核心洞察：我們可以優化迭代方法，使邏輯更清晰並減少特殊情況處理。
- 使用 prev 指向已確認不包含重複的最後一個節點。
- 使用 curr 向前探索，識別重複序列。
- 這種方法減少了指針操作的次數，並簡化了代碼。

#### 最佳算法
```
1. 創建前導節點 dummy 指向頭節點
2. 初始化 prev = dummy, curr = head
3. 遍歷鏈表直到 curr 為空：
   a. 判斷是否有重複節點（curr.next 存在且值相同）：
      i. 如果有重複，記錄重複值
      ii. 向前移動 curr 直到不再是這個重複值
      iii. prev.next = curr（跳過所有重複值）
   b. 如果沒有重複：
      i. prev = curr（移動確認非重複的指針）
      ii. curr = curr.next（繼續前進）
4. 返回 dummy.next
```

#### 實現卓越性
- 這個實現邏輯更加清晰，使用一個標記來判斷是否遇到了重複序列
- 減少了指針操作的複雜性，降低了出錯可能性
- 代碼結構更簡潔，易於理解和維護
- 依然保持了 O(1) 的空間複雜度

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是鏈表的長度。每個節點最多被訪問一次。
- **空間複雜度**：O(1)，只使用了常數額外空間。

#### 從暴力解法到最佳解法的思維演進
- 我們的思維從最直觀的雙指針方法開始，發現它雖然可行但代碼較複雜。
- 然後嘗試用遞迴思考，簡化了代碼結構但引入了額外的空間成本。
- 最後回到迭代方法，但通過引入 isDuplicate 標記來優化邏輯，使代碼更清晰。
- 這種思維演進顯示了對問題從不同角度的分析，最終找到平衡時間和空間複雜度的最佳解法。

## 6. 實例演算與 Go 實現

### 完整實例追踪
以範例輸入 [1,2,3,3,4,4,5] 追踪我們的最佳解決方案：

1. 初始狀態：
    - 鏈表：1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5 -> NULL
    - dummy = 0 (指向 1)
    - prev = dummy
    - curr = 1
    - isDuplicate = false

2. 第一次迭代：
    - curr = 1，curr.next = 2，值不同，isDuplicate 保持 false
    - prev 移動到 1
    - curr 移動到 2

3. 第二次迭代：
    - curr = 2，curr.next = 3，值不同，isDuplicate 保持 false
    - prev 移動到 2
    - curr 移動到 3

4. 第三次迭代：
    - curr = 3，curr.next = 3，值相同！
    - curr 移動到第二個 3
    - isDuplicate = true
    - prev.next（即 2.next）指向 curr.next（即 4），跳過所有 3
    - curr 移動到 4

5. 第四次迭代：
    - curr = 4，curr.next = 4，值相同！
    - curr 移動到第二個 4
    - isDuplicate = true
    - prev.next（即 2.next）指向 curr.next（即 5），跳過所有 4
    - curr 移動到 5

6. 第五次迭代：
    - curr = 5，curr.next = NULL，沒有重複
    - prev 移動到 5
    - curr 移動到 NULL，循環結束

7. 最終狀態：
    - 返回 dummy.next，即 1 -> 2 -> 5 -> NULL

### 所有方案性能比較
```
| 方案          | 時間複雜度   | 空間複雜度   | 範例運行時間   |
|--------------|------------|------------|--------------|
| 雙指針迭代     | O(n)       | O(1)       | 約 0-1ms      |
| 遞迴解法       | O(n)       | O(n)       | 約 0-1ms      |
| 雙指針優化     | O(n)       | O(1)       | 約 0-1ms      |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我的解決方案遵循了 Go 的最佳實踐：
    - 使用指針操作而不是值拷貝
    - 簡潔的函數結構
    - 直觀的變數命名
    - 善用 Go 的零值和 nil 檢查

### 錯誤處理與邊界情況
- 我的解決方案處理了以下邊界情況：
    - 空鏈表
    - 所有節點都是重複的情況
    - 頭節點是重複節點的情況
    - 尾節點是重複節點的情況

## 8. 面試模擬

### 時間管理規劃
- 問題理解：約 2-3 分鐘
    - 閱讀題目，理解需求和限制
    - 確認輸入輸出格式
- 初始解法提案：約 5 分鐘
    - 提出雙指針迭代方法
    - 解釋思路和算法流程
- 優化討論：約 5-7 分鐘
    - 考慮特殊情況和優化可能
    - 比較遞迴和迭代方法的優缺點
- 編寫程式碼：約 10-15 分鐘
    - 實現最佳解法（優化的雙指針方法）
    - 確保處理所有邊界情況
- 測試與除錯：約 5 分鐘
    - 手動追踪範例輸入
    - 檢查可能的錯誤和邊界情況

### 面試官互動模擬
- 我會這樣向面試官解釋我的 Go 實現：
  "我的解決方案使用雙指針方法處理這個問題。首先，我建立一個前導節點指向頭部，這樣可以統一處理所有情況，包括頭節點重複的情況。然後使用兩個指針：prev 指向最後一個確認不包含重複的節點，curr 用於探索和識別重複序列。當發現重複時，我會標記並跳過整個重複序列；當沒有重複時，prev 向前移動。這種方法的時間複雜度是 O(n)，空間複雜度是 O(1)。"

- 可能的提示和引導問題：
    - "如何處理頭節點就是重複節點的情況？"
      回答：使用前導節點（dummy node）可以統一頭節點的處理，無需特殊邏輯。
    - "你為什麼選擇迭代而不是遞迴？"
      回答：迭代方法具有常數空間複雜度，而遞迴可能導致 O(n) 的堆疊使用，對於長鏈表更為高效。

### 可能的後續問題
- 如果輸入規模大幅增加，你會如何修改 Go 代碼？
  回答：現有的解法已經是時間上最優的 O(n)，但可以考慮使用 Go 的並發特性處理非常長的鏈表，例如將鏈表分段並行處理，然後合併結果。

- 如果記憶體受限，你會如何最佳化 Go 解決方案？
  回答：現有解法已經使用 O(1) 的額外空間，這是最佳的。但如果需要進一步優化，可以考慮使用原地修改技術，避免創建新的節點結構。

- 如何擴展你的解決方案來處理更複雜的問題，例如「只移除重複次數超過 k 次的元素」？
  回答：可以修改算法，在遍歷時計算每個值出現的次數，只有當計數超過 k 時才移除。這需要額外的計數邏輯，但基本架構可以保持不變。

## 9. 知識整合與學習

### 解題洞察
- 這個問題教會了我在 Go 中有效處理鏈表的技巧：
    - 善用前導節點簡化邊界情況處理
    - 使用雙指針追踪和修改鏈表結構
    - 仔細處理 nil 檢查和指針移動順序
- 我更深入理解了 Go 的指針操作和記憶體管理。

### 心智模型構建
- 從這個問題中，我可以抽象出一個通用的鏈表處理框架：
    1. 使用前導節點處理頭部特殊情況
    2. 使用雙指針（前後指針）進行鏈表遍歷和操作
    3. 謹慎處理指針更新和 nil 檢查
- 這個框架可以應用於各種鏈表問題，如合併、分割、重排等。

### 錯誤模式識別
- 在實現過程中常見的錯誤：
    - 忘記處理頭節點特殊情況
    - 指針移動順序錯誤導致無限循環或段錯誤
    - nil 檢查不完整導致運行時錯誤
- 這些錯誤提醒我在處理鏈表時需要特別注意指針操作和邊界情況。

### 知識圖譜擴展
- 相關 Go 學習資源：
    - Go 語言程式設計中的指針和結構體
    - Go 中的記憶體管理和垃圾回收
    - Go 常用資料結構實現
- 這個實現在我的 Go 知識體系中強化了鏈表操作和指針管理的部分