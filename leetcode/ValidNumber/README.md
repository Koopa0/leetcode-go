# LeetCode 65: Valid Number（有效數字）

## 1. 問題定義

### 原始問題（英文）
```
A valid number can be split up into these components (in order):
1. A decimal number or an integer.
2. (Optional) An 'e' or 'E', followed by an integer.

A decimal number can be split up into these components (in order):
1. (Optional) A sign character (either '+' or '-').
2. One of the following formats:
   a. One or more digits, followed by a dot '.'.
   b. One or more digits, followed by a dot '.', followed by one or more digits.
   c. A dot '.', followed by one or more digits.

An integer can be split up into these components (in order):
1. (Optional) A sign character (either '+' or '-').
2. One or more digits.

For example, all the following are valid numbers: ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"], while the following are not valid numbers: ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"].

Given a string s, return true if s is a valid number.
```

### 問題翻譯（繁體中文）
```
一個有效數字可以拆分為以下幾個部分（按順序）：
1. 一個小數或整數。
2. （可選）一個 'e' 或 'E'，後跟一個整數。

一個小數可以拆分為以下幾個部分（按順序）：
1. （可選）一個符號字（'+'或'-'）。
2. 下列格式之一：
   a. 一個或多個數字，後跟一個點 '.'。
   b. 一個或多個數字，後跟一個點 '.'，再後跟一個或多個數字。
   c. 一個點 '.'，後跟一個或多個數字。

一個整數可以拆分為以下幾個部分（按順序）：
1. （可選）一個符號字（'+'或'-'）。
2. 一個或多個數字。

例如，以下所有字串都是有效數字：["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]，而以下字串不是有效數字：["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]。

給定一個字串 s，如果 s 是一個有效數字，則返回 true。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: s = "0"
  輸出: true
  解釋: 這是一個有效的整數。
  ```
- **範例 2:**
  ```
  輸入: s = "e"
  輸出: false
  解釋: 這不是一個有效的數字，因為 'e' 必須跟在數字後面。
  ```
- **範例 3:**
  ```
  輸入: s = "."
  輸出: false
  解釋: 這不是一個有效的數字，因為小數點需要至少有一個數字跟在後面。
  ```

- **限制條件:**
    - 1 <= s.length <= 20
    - s 只包含英文字母（大小寫）、數字（0-9）、加號 '+'、減號 '-'、或點 '.'。

## 2. 問題理解

### 初步反應與心智模型
- 這是一個字串驗證問題，需要根據一系列規則來判斷一個字串是否為有效數字。
- 問題的核心是處理各種數值表示方式，包括整數、小數和科學記數法。
- 我需要將驗證邏輯分解為多個部分：符號處理、數字部分驗證、小數點處理以及科學記數法處理。
- 這類問題通常可以使用有限狀態機（Finite State Machine，FSM）或正則表達式來解決。

### 問題分解
- 核心子問題：
    1. 如何驗證整數部分？
    2. 如何驗證小數部分？
    3. 如何處理科學記數法（e/E 後面的整數）？
    4. 如何確保各部分的組合符合有效數字的定義？
- 需要處理的邊緣情況：
    1. 單獨的符號字（如 "+"、"-"）
    2. 單獨的小數點（"."）
    3. 多個符號（如 "--6"、"-+3"）
    4. e/E 後面缺少整數部分（如 "1e"）
    5. e/E 後面的部分不是整數（如 "99e2.5"）

### 視覺表示
```
有效數字的狀態轉換圖：

開始 -> [符號?] -> [數字] -> [小數點?] -> [數字?] -> [e/E?] -> [符號?] -> [數字] -> 結束
                    |                                   
                    v                                   
                [小數點] -> [數字] -------------------->
```
- 這個視覺模型幫助我理解字串驗證過程中的各種狀態轉換。
- 從圖中可以看出，有效數字必須包含數字部分，且科學記數法的指數部分必須是整數。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [x] 字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜索/二分答案
    - [ ] 深度優先搜索（DFS）
    - [ ] 廣度優先搜索（BFS）
    - [ ] 回溯法
    - [ ] 動態規劃（DP）
    - [ ] 貪心演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [x] 其他：有限狀態機（FSM）

- 識別基礎：
    - 這是一個字串解析與驗證問題，需要按照特定的語法規則來判斷有效性。
    - 字串需要按順序解析，每個字的處理取決於之前的字和當前的狀態，這符合有限狀態機的特性。

### 知識連接
- 相關的 CS 基礎概念：
    - 有限狀態機（FSM）：用於字串解析和模式匹配
    - 正則表達式：另一種解決字串模式匹配的方法
    - 字串處理技術
    - 編譯原理中的詞法分析

### 類似問題比較
- 類似的 LeetCode 問題：
    - 8: String to Integer (atoi)
    - 10: Regular Expression Matching
    - 剖析 IP 地址有效性的問題
    - 類似的字串語法驗證問題

## 4. 演算法直覺發展

### 直覺建立
- 實際類比：這個問題類似於編譯器中的詞法分析器如何解析數字字面量。
- 初步想法：使用有限狀態機或線性掃描來進行驗證，通過定義各種狀態和轉換規則來檢查字串。
- 系統性驗證：通過將字串分類為不同的組件（符號、數字、小數點、科學記數法標記），然後驗證這些組件的組合是否有效。

### 多角度思考
- 不同角度的方法：
    - 有限狀態機：明確定義狀態和轉換規則
    - 線性掃描：逐字處理並維護狀態標誌
    - 正則表達式：使用單一模式匹配整個字串
- 對於這個問題，有限狀態機或線性掃描似乎是最直觀的方法，因為它們可以清晰地表示問題中的各種規則和狀態。

## 5. 解決方案開發過程

### 方法一：有限狀態機（FSM）

#### 思考過程
- 我們可以將字串解析問題表示為一個有限狀態機。
- 首先，定義所有可能的狀態，例如初始狀態、符號狀態、數字狀態等。
- 然後，定義每個狀態下接收不同字時的轉換規則。
- 最後，檢查最終狀態是否為有效的終止狀態。

#### 演算法設計
```
1. 定義狀態：
   - 0: 初始狀態
   - 1: 符號後的狀態（+/- 後）
   - 2: 整數部分
   - 3: 小數點後沒有數字
   - 4: 小數點後有數字
   - 5: 'e' 或 'E' 後的狀態
   - 6: 'e' 或 'E' 後的符號狀態（+/- 後）
   - 7: 'e' 或 'E' 後的整數部分

2. 定義各狀態下的轉換規則：
   - 狀態 0 收到 +/- -> 狀態 1
   - 狀態 0 收到 數字 -> 狀態 2
   - 狀態 0 收到 . -> 狀態 3
   - 狀態 1 收到 數字 -> 狀態 2
   - 狀態 1 收到 . -> 狀態 3
   - 狀態 2 收到 數字 -> 保持狀態 2
   - 狀態 2 收到 . -> 狀態 4
   - 狀態 2 收到 e/E -> 狀態 5
   - 狀態 3 收到 數字 -> 狀態 4
   - 狀態 4 收到 數字 -> 保持狀態 4
   - 狀態 4 收到 e/E -> 狀態 5
   - 狀態 5 收到 +/- -> 狀態 6
   - 狀態 5 收到 數字 -> 狀態 7
   - 狀態 6 收到 數字 -> 狀態 7
   - 狀態 7 收到 數字 -> 保持狀態 7

3. 有效的終止狀態：2, 4, 7（分別表示整數、小數和科學記數法）
```

#### 實現細節
- 使用二維數組表示狀態轉換表，行表示當前狀態，列表示輸入字的類型。
- 使用 -1 表示無效的狀態轉換。
- 遍歷字串中的每個字，根據當前狀態和輸入字確定下一個狀態。
- 最後檢查是否處於有效的終止狀態。

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是字串長度。每個字處理一次。
- **空間複雜度**：O(1)，使用固定大小的狀態轉換表和少量變數。

#### 解決方案評估
- 優點：
    - 結構清晰，易於理解和擴展。
    - 可以處理所有規則和邊緣情況。
- 缺點：
    - 實現複雜，需要仔細定義所有狀態和轉換規則。
    - 容易出錯，特別是在處理複雜的轉換規則時。

### 方法二：線性掃描

#### 關鍵洞察
- 我們可以通過跟踪一些標誌變數來簡化狀態機的實現。
- 這些標誌包括：是否已經看到數字、小數點、科學記數法標記（e/E）以及它們後面的符號。
- 線性掃描可以更簡潔地實現，同時保持邏輯清晰。

#### 優化策略
```
1. 使用布爾變數跟踪關鍵元素的出現：
   - seenDigit: 是否已看到數字
   - seenDot: 是否已看到小數點
   - seenE: 是否已看到 'e' 或 'E'
   - signAllowed: 當前位置是否允許符號（+/-）

2. 線性掃描字串：
   - 對於數字：設置 seenDigit 為 true
   - 對於小數點：檢查是否已存在小數點或已經進入指數部分
   - 對於 e/E：檢查是否已經存在 e/E 或沒有前導數字
   - 對於符號（+/-）：檢查是否在合法位置

3. 最後，判斷是否是有效數字：必須至少有一個數字
```

#### 實現改進
- 相比狀態機，這種方法使用更少的代碼來表達相同的邏輯。
- 通過使用布爾標誌來跟踪關鍵狀態，使代碼更加清晰和直觀。
- 特別注意處理符號字的位置限制，它們只能出現在字串開頭或 e/E 後面。

#### 複雜度分析
- **時間複雜度**：O(n)，與方法一相同，每個字只處理一次。
- **空間複雜度**：O(1)，只使用少量布爾變數。

#### 解決方案評估
- 優點：
    - 代碼更簡潔，邏輯更直觀。
    - 容易理解和實現。
- 缺點：
    - 需要仔細考慮各種邊緣情況。
    - 如果規則變更，可能需要大量修改。

### 方法三：正則表達式

#### 突破性思考
- 這個問題本質上是一個模式匹配問題，正則表達式是專門為此設計的工具。
- 我們可以將所有的數字格式規則轉換為一個正則表達式模式。
- 這提供了一個極其簡潔的解決方案，但可能不是所有面試官都期望的方法。

#### 最佳演算法
```
使用正則表達式定義有效數字的模式：
^[+-]?(\d+\.?|\d*\.\d+)([eE][+-]?\d+)?$

解釋：
- ^[+-]? : 可選的符號字（+或-）在開頭
- (\d+\.?|\d*\.\d+) : 整數或小數部分
  - \d+\.? : 一個或多個數字，後面可選跟一個小數點
  - \d*\.\d+ : 零個或多個數字，然後是小數點，後跟一個或多個數字
- ([eE][+-]?\d+)? : 可選的科學記數法部分
  - [eE] : 字e或E
  - [+-]? : 可選的符號字
  - \d+ : 一個或多個數字（指數部分）
- $ : 字串結束
```

#### 實現卓越性
- 這個 Go 實現利用了 `regexp` 包來簡化解決方案。
- 正則表達式模式精確地捕捉了問題中定義的所有有效數字格式。
- 儘管代碼簡短，但表達力強，能夠處理所有情況。

#### 複雜度分析
- **時間複雜度**：O(n)，正則表達式匹配的時間與字串長度成正比。
- **空間複雜度**：O(1)，不考慮正則表達式引擎的內部空間使用。

#### 從暴力到最佳的思考演變
- 從一開始的有限狀態機，我們發現了一種更簡潔的線性掃描方法。
- 最後，我們認識到這個問題的本質是模式匹配，可以使用正則表達式來有效解決。
- 這種演變反映了解決字串處理問題的常見路徑：從手動解析到使用專門的工具。
- 這種思考模式可以應用於其他字串處理問題，尤其是那些涉及語法驗證的問題。

## 6. 使用 Go 實現的示例演練

### 完整示例追蹤
使用我們的最佳解決方案追蹤示例輸入 "+3.14e-10"：

1. 初始狀態：
    - 正則表達式：`^[+-]?(\d+\.?|\d*\.\d+)([eE][+-]?\d+)?$`
    - 輸入："+3.14e-10"

2. 匹配過程：
    - `^[+-]?` 匹配 "+"，捕獲可選的開頭符號。
    - `(\d+\.?|\d*\.\d+)` 匹配 "3.14"，這是一個小數（數字+小數點+數字）。
    - `([eE][+-]?\d+)?` 匹配 "e-10"，這是科學記數法部分，包含 "e"、負號和數字。
    - `$` 成功匹配字串結束。

3. 最終結果：
    - 返回：`true`（字串完全匹配正則表達式）

### 所有方法的性能比較
```
| 方法           | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|---------------|------------|------------|--------------|
| 有限狀態機      | O(n)       | O(1)       | 0.1 ms       |
| 線性掃描        | O(n)       | O(1)       | 0.08 ms      |
| 正則表達式      | O(n)       | O(1)       | 0.15 ms      |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我們的線性掃描解決方案是最符合 Go 風格的實現，它明確且高效。
- 在 Go 中，通常傾向於明確的控制流而不是過於抽象的模式。
- 我們確保代碼清晰易讀，使用有意義的變數名稱。

### 錯誤處理與邊緣情況
- 我們的解決方案對所有邊緣情況都有明確處理：
    - 空字串
    - 只有符號的情況（"+"、"-"）
    - 只有小數點的情況（"."）
    - 各種無效格式（"e3"、"99e2.5"、"--6"等）


## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
    - 仔細閱讀問題，確保理解所有規則
    - 詢問面試官任何不清楚的地方
- 初始解決方案提案：~5 分鐘
    - 提出線性掃描方法，解釋思考過程
    - 討論跟踪的標誌和處理邏輯
- 優化討論：~5-7 分鐘
    - 討論其他可能的方法（狀態機、正則表達式）
    - 分析各方法的優缺點
- 代碼編寫：~10-15 分鐘
    - 實現線性掃描解決方案
    - 確保處理所有邊緣情況
- 測試與除錯：~5 分鐘
    - 使用提供的範例和其他自創測試用例檢查邏輯

### 面試官互動模擬
- 我會這樣向面試官解釋我的 Go 實現：
  "我選擇使用線性掃描方法來解決這個問題，因為它直觀且高效。我使用布爾標誌來跟踪關鍵元素的出現，如數字、小數點和科學記數法標記。這使我能夠在O(n)時間內驗證字串，同時保持O(1)的空間複雜度。"

- 潛在的提示和引導問題：
    - "你如何處理 '4.' 和 '.5' 這樣的邊緣情況？"
      "對於 '4.'，我確保即使小數點後沒有數字，只要前面有數字就是有效的。對於 '.5'，我確保即使小數點前沒有數字，只要後面有數字就是有效的。"
    - "使用狀態機或正則表達式有什麼優缺點？"
      "狀態機提供了更細粒度的控制，但實現較為複雜。正則表達式非常簡潔，但在面試中可能不被視為展示完整思考過程的最佳方式。線性掃描在這兩者之間取得了良好的平衡。"

### 潛在的後續問題
- 如果輸入規模增加到數百萬字，你會如何修改你的 Go 代碼？
  "對於非常大的輸入，線性掃描方法已經是渐近最優的，時間複雜度O(n)無法再改進。但我會考慮使用緩衝區讀取來避免一次載入全部字串到內存中。"

- 如果需要支持更多的數值格式（如十六進制、八進制），你會如何擴展你的解決方案？
  "我會擴展線性掃描方法來處理新的格式標記和規則。例如，對於十六進制，我會檢測 '0x' 前綴並相應調整數字集。如果規則變得非常複雜，我可能會考慮使用更結構化的狀態機方法。"

## 9. 知識整合與學習

### 解題洞察
- 這個問題教導了我如何使用不同的 Go 技術來處理字串驗證：
    - 線性掃描的簡潔實現
    - 有限狀態機的狀態管理
    - 正則表達式的模式匹配
- 我更深入理解了 Go 中處理字串和字的技術。

### 心智模型構建
- 從這個問題中，我可以抽象出一個處理字串驗證問題的框架：
    1. 識別核心規則和約束
    2. 確定需要跟踪的狀態或標誌
    3. 線性掃描字串，根據當前字和狀態更新標誌
    4. 最後檢查是否達到有效的終止狀態
- 這個框架可以應用於其他字串驗證問題，如驗證 IP 地址、電子郵件格式等。

### 錯誤模式識別
- 在實現過程中，容易犯的錯誤包括：
    - 忽略邊緣情況，如只有符號或小數點的情況
    - 處理 e/E 後面的數字要求時的邏輯錯誤
    - 混淆小數點前後的數字要求
- 這些錯誤揭示了在字串解析中需要特別小心處理的地方。

### 知識圖譜擴展
- 相關的 Go 編程資源：
    - Go 的正則表達式庫文檔和最佳實踐
    - Go 中的字串處理技術
    - Go 的單元測試和基準測試框架
- 這個實現如何融入我的整體 Go 知識系統：
    - 加深了對 Go 字串處理的理解
    - 強化了使用 Go 實現狀態機的能力
    - 提高了編寫清晰、高效的 Go 代碼的技巧