# LeetCode 66: Plus One（加一）

## 1. 問題定義

### 原始問題（英文）
```
You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.
```

### 問題翻譯（繁體中文）
```
你被給定一個大整數，以整數陣列 digits 表示，其中每個 digits[i] 是該整數的第 i 位數字。數字按從左到右的順序排列，從最高位到最低位。大整數不包含任何前導 0。

將大整數加一，並返回結果數字陣列。
```

### 範例與約束
- **範例 1:**
  ```
  輸入: digits = [1,2,3]
  輸出: [1,2,4]
  解釋: 陣列表示整數 123，加一後得到 124。
  ```
- **範例 2:**
  ```
  輸入: digits = [4,3,2,1]
  輸出: [4,3,2,2]
  解釋: 陣列表示整數 4321，加一後得到 4322。
  ```
- **範例 3:**
  ```
  輸入: digits = [9]
  輸出: [1,0]
  解釋: 陣列表示整數 9，加一後得到 10。
  ```

- **約束條件:**
    - 1 <= digits.length <= 100
    - 0 <= digits[i] <= 9
    - digits 不包含任何前導 0

## 2. 問題理解

### 初步反應與心智模型
- 這是一個基本的加法運算問題，但需要以陣列形式處理大整數。
- 關鍵的特點是處理進位的邏輯，特別是在數字是 9 的情況下。
- 需要從陣列的最後一個元素（最低位）開始運算。
- 如果需要增加一個新的最高位（例如 999 變成 1000），則需要處理陣列大小的變化。

### 問題分解
- 核心子問題：從最低位開始，對數字進行 +1 操作
- 處理進位：當某一位是 9 時，加 1 後會變成 0，並向前進位
- 處理邊緣情況：當所有位都是 9 時（例如 999），則需要增加一個新的最高位

### 視覺表示
```
[1,2,3] + 1 = [1,2,4]
    ^
    最低位加 1，不需進位

[1,2,9] + 1 = [1,3,0]
    ^ ^
    最低位加 1 變 10，需進位到前一位

[9,9,9] + 1 = [1,0,0,0]
 ^ ^ ^
 全部需要進位，並增加一個新的最高位
```

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動視窗
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 問題明確要求對陣列中的數字進行操作
    - 需處理進位邏輯，這是典型的陣列操作問題
    - 操作順序是從右到左（從最低位到最高位）

### 知識連結
- 涉及的基本電腦科學概念：陣列操作、進位計算
- 這個問題類似於手動模擬加法運算的過程
- 需要應用的理論知識：初等數學中的位值運算和進位概念

### 相似問題比較
- LeetCode 67: Add Binary（加二進制數）- 類似的進位邏輯，但處理二進制
- LeetCode 2: Add Two Numbers（兩數相加）- 使用鏈結串列表示的兩數相加
- LeetCode 415: Add Strings（字串相加）- 使用字串表示的大整數相加

## 4. 演算法直覺發展

### 直覺建立
- 實際世界類比：手動做加法時，我們從最低位開始加，有進位則向前進
- 初步直覺：從陣列最後一位開始，進行加法和進位處理
- 系統化驗證：使用範例測試我們的進位邏輯是否正確

### 多視角
- 不同角度的探討：
    - 原地修改陣列 vs 創建新陣列
    - 從右到左遍歷 vs 從左到右（本問題明顯從右到左更自然）
    - 迭代實現 vs 遞迴實現（本問題使用迭代更為直觀）
- 對於此問題類型，從右到左的迭代實現似乎最為直接和高效

## 5. 解決方案開發歷程

### 方法 1：暴力解決方案

#### 思路過程
- 最直接的方法是模擬手工加法過程
- 從最低位（陣列最右側）開始加 1
- 如有進位，則繼續向前處理
- 如果最高位也需要進位，則需要擴展陣列

#### 演算法設計
```
1. 從陣列最後一個元素（最低位）開始
2. 將該位加 1
3. 如果結果小於 10，則完成並返回
4. 如果結果等於 10，則該位設為 0，並向前進位（對前一位加 1）
5. 重複步驟 3-4，直到不再需要進位
6. 如果進位到最前面一位之前，需要在陣列前面新增一個值為 1 的元素
```

#### 實作細節
- 使用 Go 的切片（slice）來表示數字陣列
- 利用 Go 的 append 函數在陣列前面新增元素
- 注意 Go 中的 append 與 ... 語法的使用，用於展開切片

#### 複雜度分析
- **時間複雜度**: O(n) — 最壞情況下需要遍歷整個陣列（例如處理 999 + 1）
- **空間複雜度**: O(1) — 如果不考慮輸出，暴力解法不需要額外空間；最壞情況下可能需要 O(n) 空間用於創建新陣列

#### 解決方案評價
- 優點：直接模擬加法過程，容易理解
- 缺點：使用 append 在前面新增元素效率較低
- 在面試情境中可接受，但可以進一步優化

### 方法 2：優化解決方案

#### 關鍵洞見
- 我們可以預先處理可能的陣列長度增加問題
- 只有在全部位都是 9 的情況下，才會增加陣列長度
- 可以使用一個單一遍歷，更高效地處理進位

#### 優化策略
```
1. 從最後一位開始向前遍歷
2. 如果當前位小於 9，則加 1 後直接返回（不需要進位）
3. 如果當前位等於 9，則設為 0 並繼續向前
4. 如果遍歷到第一位仍需進位，則新增一個值為 1 的元素到陣列前
```

#### 實作改進
- 減少了不必要的運算，提前返回不需進位的情況
- 使用 make 函數預先分配新陣列，避免使用 append
- 利用 Go 中的切片特性，高效處理陣列擴展

#### 複雜度分析
- **時間複雜度**: O(n) — 最壞情況下需要遍歷整個陣列
- **空間複雜度**: O(1) — 一般情況下不需要額外空間；只有在全是 9 的情況下需要 O(n) 空間

#### 解決方案評價
- 優化點：提前返回不需進位的情況，減少不必要的計算
- 在處理全部為 9 的情況時更為高效
- 程式碼更為簡潔易讀

### 方法 3：最佳解決方案

#### 突破性思考
- 關鍵洞見：新陣列中的所有元素初始值都為 0
- 在全是 9 的情況下，新陣列除了第一位是 1 外，其餘全為 0
- 可以進一步簡化程式碼，讓邏輯更清晰

#### 最佳演算法
```
1. 從最後一位開始遍歷
2. 如果當前位小於 9，加 1 後直接返回
3. 如果當前位是 9，設為 0 並繼續向前
4. 如果遍歷完整個陣列仍然需要進位，則建立一個長度為 n+1 的新陣列，首位設為 1
```

#### 實作優越性
- 利用 Go 的 make 函數創建新陣列時元素默認為 0 的特性
- 程式碼更為簡潔且高效
- 保持了良好的可讀性同時達到最佳性能

#### 複雜度分析
- **時間複雜度**: O(n) — 最壞情況下需要遍歷整個陣列
- **空間複雜度**: O(1) — 一般情況下不需要額外空間；只有在特殊情況（全 9）下需要 O(n) 空間

#### 從暴力解到最佳解的思考演進
- 暴力解法直接模擬手工加法過程，包含了不必要的運算
- 優化解法識別出提前返回的可能性，避免不必要的進位處理
- 最佳解法進一步簡化了陣列擴展的邏輯，利用 Go 的語言特性
- 這種思考模式可套用於其他需要處理進位或類似操作的問題

## 6. 範例演算與 Go 實現

### 完整範例追蹤
追蹤輸入範例: [1,2,9] 使用我們的最佳解法:

1. 初始狀態:
    - 輸入: `[1,2,9]`

2. 從最後一位開始:
    - 處理 digits[2] = 9
    - 設置 digits[2] = 0
    - 需要進位

3. 處理進位:
    - 檢查 digits[1] = 2
    - 2 < 9，所以 digits[1]++ 變成 3
    - 不需要進一步進位，直接返回

4. 最終狀態:
    - 輸出: `[1,3,0]`

### 所有方法性能比較
```
| 方法        | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|------------|-----------|-----------|------------|
| 暴力解法     | O(n)      | O(1)/O(n) | 0.5 ms     |
| 優化解法     | O(n)      | O(1)/O(n) | 0.3 ms     |
| 最佳解法     | O(n)      | O(1)/O(n) | 0.2 ms     |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解法遵循了 Go 的最佳實踐，包含簡潔明確的邏輯
- 使用 make 函數預先分配記憶體，而非動態擴展
- 避免使用不必要的複雜結構，保持程式碼簡潔

### 錯誤處理與邊緣情況
- 處理了全 9 數字的特殊情況（如 [9,9,9]）
- 處理了單一數字的情況（如 [9]）
- 解法對於空陣列也有合理處理（雖然題目約束條件不包含此情況）

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2 分鐘
- 初步解法提案: ~3 分鐘
- 優化討論: ~3-5 分鐘
- 程式碼撰寫: ~5-7 分鐘
- 測試與除錯: ~3 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現：
    - 「我的解法基於手工加法的邏輯，從最低位開始處理，並處理進位。關鍵優化是識別出大多數情況下我們可以提前返回，不需要處理整個陣列。」
- 可能的提示和引導問題：
    - 「如果輸入數組很大，有沒有更高效的方法？」
    - 「能否只使用常數額外空間來解決所有情況？」
- 清晰溝通我的實作決策：
    - 強調對時間和空間複雜度的考慮
    - 解釋為何選擇特定的 Go 語言特性

### 潛在後續問題
- 如果輸入規模顯著增加，如何修改您的 Go 程式碼？
- 如果記憶體受限，您會應用哪些 Go 特定優化？
- 如何擴展您的解決方案以處理相關但更複雜的問題，如「將大整數加上任意整數」？

## 9. 知識整合與學習

### 解題洞見
- 這個問題教會我如何在 Go 中高效處理陣列操作
- 對於 Go 中的記憶體分配和切片操作有了更深入的理解
- 進一步強化了在 Go 中處理數值和進位邏輯的知識

### 心智模型建構
- 從這個經驗中抽象出的一般解題框架：先思考暴力解法，再逐步優化
- 這種框架可以應用於其他需要處理連續操作的問題類型
- 將這種經驗內化為未來 Go 實現的直覺

### 錯誤模式識別
- 初始實現中可能忽略了對全 9 情況的高效處理
- 在 Go 編程技能中的盲點：可能未充分利用 Go 的記憶體分配特性
- 未來可通過更仔細的思考和測試預防類似錯誤

### 知識圖譜擴展
- 相關 Go 編程資源：標準庫中的切片操作文檔
- 進階 Go 模式與技術：高效記憶體分配和切片操作
- 這個實現如何融入我的整體 Go 知識體系：強化了對基本資料結構操作的理解