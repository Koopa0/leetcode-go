# LeetCode 98: 驗證二元搜尋樹（Validate Binary Search Tree）

## 1. 問題定義

### 原始問題（英文）
```
Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.
```

### 問題翻譯（繁體中文）
```
給定一個二元樹的根節點，判斷其是否為有效的二元搜尋樹 (BST)。

一個有效的二元搜尋樹定義如下：
- 節點的左子樹只包含小於該節點值的節點。
- 節點的右子樹只包含大於該節點值的節點。
- 所有左子樹和右子樹自身必須也是二元搜尋樹。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: [2,1,3]
    2
   / \
  1   3
  輸出: true
  解釋: 這是一個有效的BST，左子節點小於根節點，右子節點大於根節點。
  ```
- **範例 2:**
  ```
  輸入: [5,1,4,null,null,3,6]
      5
     / \
    1   4
       / \
      3   6
  輸出: false
  解釋: 根節點值為5，但右子樹的值3小於5，違反了BST的定義。
  ```

- **限制條件:**
    - 樹中的節點數量在範圍 [1, 10^4] 內
    - -2^31 <= Node.val <= 2^31 - 1

## 2. 問題理解

### 初步反應與心智模型
- 首先我們需要理解二元搜尋樹的基本性質：對於任一節點，其左子樹中所有節點的值都小於該節點的值，右子樹中所有節點的值都大於該節點的值。
- 這個問題不僅要求直接子節點符合大小關係，還要求整個子樹都要符合條件。
- 這意味著我們需要追蹤每個節點應該在的值域範圍。
- 一個常見的錯誤解法是只檢查每個節點與其直接子節點的關係，而忽略了祖先節點帶來的約束。

### 問題分解
- 核心子問題：如何確保一個節點的所有左子樹節點都小於它，所有右子樹節點都大於它？
- 我們需要為每個節點設定上界和下界，確保其值在正確的範圍內。
- 在遞迴檢查左子樹時，上界會更新為當前節點的值。
- 在遞迴檢查右子樹時，下界會更新為當前節點的值。
- 邊界案例：空節點被認為是有效的BST。

### 視覺表示
```
對於這棵樹：
      5
     / \
    1   7
       / \
      4   8

節點5：範圍(-∞, +∞)
節點1：範圍(-∞, 5)，有效
節點7：範圍(5, +∞)，有效
節點4：範圍(5, 7)，無效！因為4 < 5
節點8：範圍(7, +∞)，有效
```
- 這個視覺化幫助我們理解，4雖然大於其父節點3，但因為它在5的右子樹中，所以它也應該大於5，這就是為什麼我們需要跟踪上下界。

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [x] 深度優先搜索 (DFS)
    - [x] 樹問題
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜索/二分答案
    - [ ] 廣度優先搜索 (BFS)
    - [ ] 回溯
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別基礎：
    - 這個問題涉及樹的遍歷，需要檢查樹中的每個節點是否符合特定條件。
    - 深度優先搜索是處理樹結構的自然選擇，可以有效地遍歷整棵樹。
    - 我們需要維護上下界信息，這在遞迴DFS中很容易實現。

### 知識連結
- 此問題涉及二元搜尋樹的基本性質：左小右大。
- 涉及樹的遞迴遍歷策略。
- 考驗邊界條件的處理能力，需要理解如何傳遞和更新界限。
- 與中序遍歷（inorder traversal）有關，因為BST的中序遍歷結果應該是升序排列的。

### 類似問題比較
- LeetCode 95/96: "Unique Binary Search Trees" - 處理BST的結構特性
- LeetCode 230: "Kth Smallest Element in a BST" - 利用BST的性質進行搜索
- LeetCode 700: "Search in a Binary Search Tree" - BST的基本操作
- LeetCode 235/236: "Lowest Common Ancestor of a BST/Binary Tree" - 樹遍歷問題

## 4. 算法直覺發展

### 直覺建立
- 直覺告訴我，我們需要一種方法來確保左子樹中的所有節點都小於根節點，右子樹中的所有節點都大於根節點。
- 一個常見的誤解是只檢查直接的父子關係，但實際上我們需要確保整個子樹都滿足條件。
- 可以想像每個節點都有一個有效的值域範圍，當我們向下遞迴時，這個範圍會越來越窄。

### 多種視角
- 自頂向下的方法：從根節點開始，為每個子節點設定有效值域。
- 自底向上的方法：檢查每個子樹是否是BST，然後組合結果。
- 中序遍歷方法：BST的中序遍歷應該產生一個升序序列。
- 範圍限制方法：為每個節點設定上下限，確保其值在有效範圍內。

對於這個問題，自頂向下的方法似乎最直觀，因為我們可以在遍歷過程中逐步縮小有效值域。

## 5. 解決方案開發歷程

### 方法1：暴力解法（錯誤方法，僅供學習）

#### 思考過程
- 最簡單的思路可能是只檢查每個節點與其直接子節點的關係。
- 然而，這種方法是不正確的，因為它沒有考慮到祖先節點的影響。
- 我包含這個錯誤解法是為了強調一個常見的誤解，並理解為什麼它不起作用。

#### 算法設計
```
遞迴檢查每個節點：
1. 如果節點為空，返回true（空樹是BST）
2. 檢查左子節點是否小於當前節點（如果存在）
3. 檢查右子節點是否大於當前節點（如果存在）
4. 遞迴檢查左右子樹
```

#### 實現細節
- 我們使用遞迴方式遍歷樹的每個節點。
- 對於每個節點，我們檢查它與直接子節點的關係。
- 這個實現的問題在於它沒有考慮整個子樹的所有節點，只考慮了直接子節點。

#### 複雜度分析
- **時間複雜度**: O(n)，其中n是樹中的節點數量。我們需要訪問每個節點一次。
- **空間複雜度**: O(h)，其中h是樹的高度。在最壞情況下（樹退化為鏈表），空間複雜度為O(n)。

#### 解法評估
- 這個解法有重大缺陷，因為它只檢查直接父子關係，無法保證整個子樹都符合BST的性質。
- 例如，範例2中提到的樹就無法被正確判斷。
- 在實際面試中，這種解法會被視為錯誤的。

### 方法2：使用遞迴與值域限制

#### 關鍵洞察
- 暴力解法的問題在於沒有考慮祖先節點的影響。
- 我們需要為每個節點維護一個有效值域，確保其值在這個範圍內。
- 當我們向左子樹遞迴時，上界會更新為當前節點的值。
- 當我們向右子樹遞迴時，下界會更新為當前節點的值。

#### 優化策略
```
1. 使用兩個參數（min和max）來表示節點的有效值域。
2. 遞迴檢查每個節點的值是否在這個範圍內。
3. 更新範圍並向下遞迴。
```

#### 實現改進
- 我們引入了一個輔助函數來攜帶額外的範圍信息。
- 初始時，範圍設為無限大，然後在遞迴過程中逐漸縮小。
- 針對每個節點，我們先檢查其值是否在有效範圍內，然後再更新範圍並遞迴。

#### 複雜度分析
- **時間複雜度**: O(n)，其中n是樹中的節點數量。我們依然需要訪問每個節點一次。
- **空間複雜度**: O(h)，其中h是樹的高度，用於遞迴堆疊。

#### 解法評估
- 這個解法正確地處理了BST的性質，確保了整個子樹都滿足條件。
- 它能夠有效地處理所有測試案例，包括那些暴力解法無法處理的案例。
- 值得注意的是，我們使用了int類型的最大和最小值作為初始範圍，這在處理邊界節點時可能存在問題。

### 方法3：中序遍歷法

#### 突破性思考
- BST的一個重要性質是：其中序遍歷結果應該是嚴格升序的。
- 如果我們進行中序遍歷並檢查結果是否是升序的，就可以判斷是否為有效的BST。
- 這提供了一種不同的視角來解決這個問題。

#### 最優算法
```
1. 進行樹的中序遍歷。
2. 跟踪上一個訪問的節點的值。
3. 如果當前節點的值小於或等於上一個節點的值，則不是BST。
```

#### 實現精進
- 我們使用閉包來簡化實現，避免傳遞太多參數。
- 通過追踪前一個訪問的節點，我們可以輕鬆檢查中序遍歷結果是否升序。
- 一旦發現違反升序規則的情況，立即停止遍歷並返回false。

#### 複雜度分析
- **時間複雜度**: O(n)，其中n是樹中的節點數量。我們依然需要訪問每個節點一次。
- **空間複雜度**: O(h)，其中h是樹的高度，用於遞迴堆疊。

#### 從暴力到最優的思考演進
- 我們最初的暴力解法忽略了BST的全局性質，只檢查了局部關係。
- 第二種方法通過維護值域範圍，確保了每個節點的值都在合適的範圍內。
- 最後，我們利用BST的中序遍歷性質，提供了一種更簡潔的解法。
- 這種思考演進展示了如何從基本定義開始，深入理解問題，最終找到最優解。

## 6. 使用Go實現的完整範例演練

### 完整範例追蹤
以範例輸入為例：`[5,1,4,null,null,3,6]`

使用我們最優解法的執行過程：

1. 初始狀態：
    - 根節點：5
    - prev = nil
    - valid = true

2. 開始中序遍歷：
    - 訪問左子樹：1
        - 1沒有左子樹
        - 檢查：prev = nil，節點值 = 1，有效
        - 更新prev = 1
        - 1沒有右子樹

    - 返回到5
    - 檢查：prev = 1，節點值 = 5，有效
    - 更新prev = 5

    - 訪問右子樹：4
        - 訪問4的左子樹：3
            - 3沒有左子樹
            - 檢查：prev = 5，節點值 = 3，無效！因為3 < 5
            - 設置valid = false
            - 立即返回

3. 最終狀態：
    - valid = false
    - 輸出：false

### 所有方法的性能比較
```
| 方法             | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|-----------------|-----------|-----------|------------|
| 暴力解法（錯誤） | O(n)      | O(h)      | 不適用      |
| 遞迴與值域限制   | O(n)      | O(h)      | ~0ms       |
| 中序遍歷法       | O(n)      | O(h)      | ~0ms       |
```

## 7. Go最佳實踐與測試

### Go慣用解法
- 我們的解法遵循了Go的最佳實踐，使用簡潔的函數和有意義的變數名稱。
- 中序遍歷解法中使用閉包是一種Go常見的模式，可以簡化複雜的遞迴操作。
- 我們避免了全局變數，而是使用閉包來捕獲和修改變數。

### 錯誤處理與邊界案例
- 我們處理了空樹的情況，將其視為有效的BST。
- 對於整數邊界值的處理，需要特別注意。在第二種方法中，我們使用了int的最大和最小值，但在實際應用中可能需要考慮更多邊界情況。
- 在中序遍歷法中，我們通過檢查前一個值來處理重複值的情況。

## 8. 面試模擬

### 時間管理規劃
- 理解問題：~2分鐘
- 初步解法提案：~5分鐘
- 優化討論：~5-7分鐘
- 程式碼編寫：~10-15分鐘
- 測試與除錯：~5分鐘

### 面試互動模擬
- 面試官可能會問：「如果樹的節點值可能等於整數的最大或最小值，你的第二種解法會有什麼問題？」
    - 回答：「確實，使用整數最大最小值可能會導致問題。更好的做法是使用指針類型來表示上下界，初始時為nil，表示沒有限制。」

- 面試官可能會問：「你的中序遍歷解法中，為什麼要使用閉包而不是直接傳遞參數？」
    - 回答：「使用閉包可以簡化程式碼，避免傳遞過多參數。同時，它也使程式碼更易讀，因為所有相關變數都在同一作用域內。」

### 潛在跟進問題
- 如果輸入規模巨大，你如何修改你的Go程式碼以提高效率？
- 如果要求在內存受限的環境中運行，你會如何優化解法？
- 如何將你的解法擴展以處理更複雜的問題，例如確定一棵樹是否為平衡二元搜尋樹？

## 9. 知識整合與學習

### 問題解決洞察
- 這個問題教會了我深入理解BST的性質及其定義。
- 透過實現不同解法，我學會了樹遍歷的不同方法及其適用場景。
- 我需要加強對各種邊界情況的處理，特別是涉及整數邊界值的情況。

### 心智模型構建
- 在處理樹問題時，考慮多種遍歷方式（前序、中序、後序）可能帶來不同的解法。
- 遞迴是處理樹結構的強大工具，但需要謹慎設計基礎條件和遞迴流程。
- 閉包可以簡化複雜的遞迴操作，是Go中的一個有用特性。

### 錯誤模式識別
- 忽略BST的整體性質，僅關注局部關係是一個常見錯誤。
- 在範圍檢查中使用整數的極限值可能導致溢出或邊界問題。
- 忘記處理樹中可能出現的重複值也是一個易犯的錯誤。