# LeetCode 56: 合併區間 (Merge Intervals)

## 1. 問題定義

### 原始問題 (英文)
```
Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.

Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.

Constraints:
- 1 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti <= endi <= 10^4
```

### 問題翻譯 (繁體中文)
```
給定一個區間陣列，其中 intervals[i] = [starti, endi]，合併所有重疊的區間，並返回一個涵蓋輸入中所有區間的非重疊區間陣列。

範例 1:
輸入: intervals = [[1,3],[2,6],[8,10],[15,18]]
輸出: [[1,6],[8,10],[15,18]]
解釋: 由於區間 [1,3] 和 [2,6] 重疊，將它們合併為 [1,6]。

範例 2:
輸入: intervals = [[1,4],[4,5]]
輸出: [[1,5]]
解釋: 區間 [1,4] 和 [4,5] 被視為重疊。

限制條件:
- 1 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti <= endi <= 10^4
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: intervals = [[1,3],[2,6],[8,10],[15,18]]
  輸出: [[1,6],[8,10],[15,18]]
  解釋: 由於區間 [1,3] 和 [2,6] 重疊，將它們合併為 [1,6]。
  ```
- **範例 2:**
  ```
  輸入: intervals = [[1,4],[4,5]]
  輸出: [[1,5]]
  解釋: 區間 [1,4] 和 [4,5] 被視為重疊。
  ```

- **限制條件:**
    - 1 <= intervals.length <= 10^4
    - intervals[i].length == 2
    - 0 <= starti <= endi <= 10^4

## 2. 問題理解

### 初始反應與心理模型
- 看到這個問題時，我的第一反應是「需要檢查每對區間是否重疊，然後將重疊的區間合併」。
- 範例展示了如何將重疊的區間合併：當區間 [1,3] 和 [2,6] 重疊時，合併後的區間是 [1,6]，即取最小的起始值和最大的結束值。
- 關鍵在於如何有效地識別重疊的區間，以及如何處理可能的連續合併（例如，合併兩個區間後，新的區間可能與其他區間重疊）。
- 視覺化的角度看，這個問題就像在數線上有多個線段，我們需要合併那些有交集的線段。

### 問題分解
- 如何確定兩個區間是否重疊？
    - 當一個區間的起始值小於等於另一個區間的結束值，且另一個區間的起始值小於等於該區間的結束值時，這兩個區間重疊。
    - 簡化條件：區間 A 和區間 B 重疊，當且僅當 max(A.start, B.start) <= min(A.end, B.end)。
- 如何合併重疊的區間？
    - 合併後的區間：[min(A.start, B.start), max(A.end, B.end)]。
- 如何處理多個區間的合併？
    - 需要一個策略來確保所有可能的合併都被考慮到。

### 視覺表示
```
數線表示：
      1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
範例1: |---|
          |-----------|
                              |---|
                                                          |-------|
合併後: |-----------|
                              |---|
                                                          |-------|

範例2: |-----------|
                |---|
合併後: |-------------|
```
- 這種視覺化有助於理解區間重疊的概念，以及合併後的結果。
- 從視覺模型中可以看出，如果我們先將區間按照起始值排序，那麼只需要比較相鄰區間是否重疊，這可以簡化問題。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下演算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [x] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖論演算法
    - [ ] 樹狀問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [x] 排序演算法
    - [ ] 位元操作
    - [ ] 其他：________

- 識別基礎：
    - 問題涉及操作和合併陣列中的區間，屬於陣列操作。
    - 解決策略需要將區間排序，然後以貪婪方式合併重疊的區間，因此也屬於貪婪演算法和排序演算法。

### 知識連接
- 這個問題涉及的基本資訊科學概念包括：
    - 排序演算法（用於排序區間）
    - 貪婪策略（按順序處理區間）
    - 區間操作和合併
- 這個問題與區間樹、線段樹等資料結構有關，雖然這些進階資料結構並非解決此問題所必需。

### 類似問題比較
- LeetCode 57: Insert Interval - 在已排序的區間集合中插入新區間
- LeetCode 252 & 253: Meeting Rooms I & II - 檢查會議室時間是否重疊，以及需要多少會議室
- LeetCode 435: Non-overlapping Intervals - 移除最少的區間以使剩餘區間不重疊
- 這些問題都涉及區間操作，並且通常都以排序作為第一步。區別在於具體的操作（合併、檢查重疊、移除等）。

## 4. 演算法直覺發展

### 直覺建立
- 想像你在安排一天的會議，有些會議時間重疊。為了簡化你的行程表，你希望將重疊的會議合併成一個較長的時段。
- 處理這樣的問題，自然的做法是先將會議按照開始時間排序，然後逐一檢查是否有重疊。
- 實際上，這種貪婪策略在處理區間問題時非常常見且有效。

### 多重視角
- 從不同角度思考問題：
    - 從頭到尾掃描全部區間（迭代方法）
    - 遞迴地合併相鄰的區間（分治方法）
    - 使用堆疊來跟踪當前可能合併的區間
- 對於這類問題，迭代方法配合排序通常是最直接且高效的方法。

## 5. 解決方案開發歷程

### 方法 1: 暴力解法

#### 思考過程
- 最直接的方法是檢查每對區間是否重疊，然後合併它們。
- 合併後，我們需要重新檢查新的區間集合中是否還有重疊。
- 這個過程需要多次迭代，直到沒有更多的合併可以進行。

#### 演算法設計
```
將輸入區間集合記為 intervals
建立一個結果集合 result
將所有區間加入 result
重複以下步驟，直到沒有更多合併發生：
    merged = False
    建立一個新的暫存集合 temp
    對 result 中的每個區間：
        如果該區間能與 temp 中的某個區間合併：
            進行合併
            設置 merged = True
        否則：
            將該區間添加到 temp 中
    如果 merged = True：
        將 temp 賦值給 result
返回 result
```


#### 實作細節
- 我使用二維切片來表示區間集合。
- 實作了輔助函數 `canMerge` 來檢查兩個區間是否可以合併。
- 使用 `min` 和 `max` 函數來計算合併後的區間邊界。
- 使用外層循環來重複合併過程，直到沒有更多合併發生。

#### 複雜度分析
- **時間複雜度**: O(n³) — 在最壞情況下，外層循環可能執行 O(n) 次，每次迭代中，我們檢查每對區間，這需要 O(n²) 的時間。
- **空間複雜度**: O(n) — 我們使用額外的空間來存儲中間結果。

#### 解決方案評估
- 這種方法概念上簡單，容易理解。
- 然而，時間複雜度很高，不適合處理大型輸入。
- 在極端情況下（如所有區間都不重疊），外層循環只執行一次，但檢查所有對仍需要 O(n²) 時間。
- 這個方法在面試中可能會被接受作為初始解決方案，但面試官會期望進一步優化。

### 方法 2: 排序優化解法

#### 關鍵洞見
- 在暴力解法中，我們重複檢查所有區間對，這顯然效率低下。
- 如果我們先將區間按照起始值排序，那麼只需要檢查相鄰的區間是否重疊。
- 排序後，我們可以順序處理區間，並維護一個當前合併結果，使演算法更高效。

#### 優化策略
```
將輸入區間集合按照起始值排序
建立一個空的結果集合 result
將第一個區間加入 result
對於排序後的每個區間 interval：
    獲取 result 中的最後一個區間 lastInterval
    如果 interval 與 lastInterval 重疊：
        合併這兩個區間，並更新 lastInterval
    否則：
        將 interval 添加到 result 中
返回 result
```

#### 實作改進
- 使用 Go 的 `sort.Slice` 函數來排序區間。
- 排序後，我們只需要一次遍歷所有區間，並與結果集合中的最後一個區間進行比較。
- 這種方法更符合 Go 的慣用做法，代碼簡潔且高效。

#### 複雜度分析
- **時間複雜度**: O(n log n) — 排序需要 O(n log n) 時間，然後我們需要 O(n) 時間遍歷排序後的區間。
- **空間複雜度**: O(1) — 如果不考慮輸出，我們只需要常數空間。如果考慮輸出，則為 O(n)。

#### 解決方案評估
- 這種方法比暴力解法高效得多，時間複雜度降低到 O(n log n)。
- 排序是一個關鍵的預處理步驟，使後續的合併操作變得簡單。
- 這個演算法具有良好的可擴展性，可以處理大型輸入。
- 在面試中，這被視為一個很好的解決方案。

### 方法 3: 最佳解法（線性掃描）

#### 突破性思考
- 排序優化解法已經是這個問題的最佳解法，因為我們需要至少 O(n log n) 的時間來排序區間。
- 然而，我們可以進一步優化實作細節，使代碼更加簡潔和高效。
- 如果輸入已經排序，我們可以實現 O(n) 的時間複雜度。

#### 最佳演算法
```
如果輸入已經按照起始值排序：
    建立一個空的結果集合 result
    建立一個當前合併區間 current = 第一個區間
    對於排序後的每個區間 interval（從第二個開始）：
        如果 interval 與 current 重疊：
            更新 current 為合併後的區間
        否則：
            將 current 添加到 result 中
            設置 current = interval
    將最後的 current 添加到 result 中
返回 result
```

#### 實作卓越性
- 這個實作充分利用了 Go 的切片操作和排序功能。
- 使用單一循環來處理所有區間，並維護一個當前合併區間。
- 代碼簡潔且易於理解，同時保持高效性能。

#### 複雜度分析
- **時間複雜度**: O(n log n) — 排序需要 O(n log n) 時間，然後我們需要 O(n) 時間遍歷排序後的區間。
- **空間複雜度**: O(n) — 我們需要空間來存儲結果。

#### 從暴力解法到最佳的思考演進
- 我們從檢查所有區間對的暴力解法開始，時間複雜度為 O(n³)。
- 通過觀察到區間排序的重要性，我們改進算法到 O(n log n)。
- 最後，我們進一步優化實作，使代碼更加簡潔和高效。
- 這種演進思維模式可以應用於其他區間相關問題，即先排序，然後線性處理。

## 6. 範例步驟追蹤與 Go 實作

### 完整範例追蹤
追蹤範例輸入：`[[1,3],[2,6],[8,10],[15,18]]` 使用我們的最佳解法：

1. 初始狀態：
    - 輸入：`[[1,3],[2,6],[8,10],[15,18]]`
    - 排序後（按起始值）：`[[1,3],[2,6],[8,10],[15,18]]`（已經排序）
    - current = [1,3]
    - result = []

2. 迭代 i=1：
    - 檢查 [2,6] 與 current [1,3]
    - 2 <= 3，有重疊
    - 更新 current = [1,6]
    - result = []

3. 迭代 i=2：
    - 檢查 [8,10] 與 current [1,6]
    - 8 > 6，沒有重疊
    - 將 current [1,6] 添加到 result
    - result = [[1,6]]
    - 更新 current = [8,10]

4. 迭代 i=3：
    - 檢查 [15,18] 與 current [8,10]
    - 15 > 10，沒有重疊
    - 將 current [8,10] 添加到 result
    - result = [[1,6],[8,10]]
    - 更新 current = [15,18]

5. 循環結束，將最後的 current [15,18] 添加到 result
    - result = [[1,6],[8,10],[15,18]]

6. 最終狀態：
    - 輸出：`[[1,6],[8,10],[15,18]]`

### 所有方法的性能比較
```
| 方法           | 時間複雜度     | 空間複雜度   | 範例執行時間 |
|---------------|--------------|------------|------------|
| 暴力解法        | O(n³)        | O(n)       | 約 3 ms     |
| 排序優化解法     | O(n log n)   | O(n)       | 約 0.5 ms   |
| 最佳解法        | O(n log n)   | O(n)       | 約 0.5 ms   |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解決方案遵循 Go 的最佳實踐，使用內建的 `sort.Slice` 函數進行排序。
- 使用切片操作來維護結果集，這是 Go 中處理集合的慣用方式。
- 函數和變數命名符合 Go 的命名慣例。

### 錯誤處理與邊界情況
- 處理了空輸入或單個區間的情況，直接返回。
- 即使輸入不是按照起始值排序的，解決方案也能正確工作。
- 解決方案能夠處理區間邊界相等的情況（如 [1,4] 和 [4,5]）

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初始解決方案提議：~3 分鐘
- 優化討論：~5 分鐘
- 代碼編寫：~10 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現：
  "我的解決方案首先將區間按照起始值排序，這樣我們可以順序處理區間並合併重疊的部分。我使用 Go 的 `sort.Slice` 函數來排序區間，然後維護一個當前合併區間，並遍歷所有排序後的區間。如果當前區間與合併區間重疊，我們更新合併區間；否則，我們將合併區間添加到結果中，並開始新的合併區間。"

- 可能的提示和引導問題：
    - 為什麼排序是必要的？
    - 如何處理區間邊界相等的情況？
    - 你的解決方案的時間和空間複雜度是多少？

- 如何清晰地溝通我的實現決策：
  "我選擇使用排序作為預處理步驟，因為這使得後續的合併操作變得簡單且高效。排序後，我只需要線性遍歷區間，而不需要重複檢查所有區間對。在 Go 中，我使用切片操作來維護結果集，這是處理動態集合的慣用方式。"

### 潛在的後續問題
- 如果輸入規模增加到極大，你會如何修改你的 Go 代碼？
  "對於極大規模的輸入，我們可以考慮並行排序，利用 Go 的併發特性。此外，我們可以分批處理區間，減少內存使用。"

- 如果內存受限，你會應用哪些 Go 特定的優化？
  "為了減少內存使用，我們可以考慮原地排序和合併，避免創建額外的切片。此外，我們可以使用緩衝區來批量處理區間，而不是一次加載全部區間到內存中。"

- 如何擴展你的解決方案以處理相關但更複雜的問題？
  "我們可以擴展解決方案以處理多維區間，例如時間和空間的組合。此外，我們可以添加權重或優先級來決定如何合併重疊的區間，而不是簡單地取最大範圍。"

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會了我 Go 中排序和切片操作的高效使用。
- 我更深入地理解了 Go 的函數式編程範式，特別是在排序和過濾集合方面。
- 需要進一步加強的 Go 知識領域包括並行排序和更高級的切片操作。

### 心智模型構建
- 這個問題強化了"排序預處理"的心智模型，即通過排序來簡化後續操作。
- 這種範式可以應用於許多其他問題，例如合併有序數組、找出重疊事件等。
- 通過將這種經驗內化為直覺，我可以更快地識別和解決類似的問題。

### 錯誤模式識別
- 在實現過程中，我曾錯誤地認為需要在每次合併後重新檢查所有區間。
- 這揭示了我對排序後的數據特性理解不足。
- 通過深入理解問題的結構，我可以避免未來實現中的類似錯誤。

### 知識圖譜擴展
- 相關 Go 編程資源：
    - 《Effective Go》 — 學習 Go 的慣用模式
    - Go 官方文檔中的排序部分
    - 《The Go Programming Language》一書中的切片操作章節
- 這個實現增強了我對區間操作和排序算法的理解，豐富了我的 Go 知識體系