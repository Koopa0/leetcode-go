## 1. Original Problem

### English Version
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

```
Symbol       Value
I            1
V            5
X            10
L            50
C            100
D            500
M            1000
```

For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

- I can be placed before V (5) and X (10) to make 4 and 9.
- X can be placed before L (50) and C (100) to make 40 and 90.
- C can be placed before D (500) and M (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.

**Example 1:**
```
Input: num = 3
Output: "III"
```

**Example 2:**
```
Input: num = 4
Output: "IV"
```

**Example 3:**
```
Input: num = 9
Output: "IX"
```

**Example 4:**
```
Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
```

**Example 5:**
```
Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90, IV = 4.
```

**Constraints:**
- 1 <= num <= 3999

### 繁體中文版本
羅馬數字由以下七個不同的符號表示：I、V、X、L、C、D 和 M。

```
符號       值
I          1
V          5
X          10
L          50
C          100
D          500
M          1000
```

例如，2 在羅馬數字中寫作 II，即為兩個並列的 1。12 寫作 XII，即為 X + II。27 寫作 XXVII，即為 XX + V + II。

羅馬數字通常從左到右由大到小書寫。然而，數字 4 不是寫作 IIII，而是 IV。因為 1 在 5 的前面，所以減去它得到 4。同樣的原則也適用於數字 9，寫作 IX。有六種情況使用減法：

- I 可以放在 V (5) 和 X (10) 前面，表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 前面，表示 40 和 90。
- C 可以放在 D (500) 和 M (1000) 前面，表示 400 和 900。

給定一個整數，將其轉換為羅馬數字。

**示例 1:**
```
輸入: num = 3
輸出: "III"
```

**示例 2:**
```
輸入: num = 4
輸出: "IV"
```

**示例 3:**
```
輸入: num = 9
輸出: "IX"
```

**示例 4:**
```
輸入: num = 58
輸出: "LVIII"
解釋: L = 50, V = 5, III = 3.
```

**示例 5:**
```
輸入: num = 1994
輸出: "MCMXCIV"
解釋: M = 1000, CM = 900, XC = 90, IV = 4.
```

**約束:**
- 1 <= num <= 3999

## 2. 問題理解

這個問題要求我們將一個整數轉換為羅馬數字表示形式。讓我們分析一下關鍵要點：

1. **輸入特性**：整數 `num`，範圍在 1 到 3999 之間。
2. **輸出特性**：字串，表示該整數的羅馬數字表示。
3. **羅馬數字規則**：
    - 基本符號：I (1), V (5), X (10), L (50), C (100), D (500), M (1000)
    - 通常從左到右由大到小排列
    - 特殊減法規則：
        * IV (4) = 5-1
        * IX (9) = 10-1
        * XL (40) = 50-10
        * XC (90) = 100-10
        * CD (400) = 500-100
        * CM (900) = 1000-100

4. **邊界情況**：
    - 最小值：1，對應羅馬數字 "I"
    - 最大值：3999，對應羅馬數字 "MMMCMXCIX"
    - 不需要考慮 0 或負數，因為羅馬數字系統中沒有這些概念

5. **挑戰**：
    - 正確處理減法規則
    - 有效地從整數構建羅馬數字字串

## 3. 視覺解釋

讓我們用視覺方式解釋這個問題，以更好地理解羅馬數字的構建過程。以上圖表展示了將整數 1994 轉換為羅馬數字的步驟：

1. 首先找到不超過 1994 的最大羅馬數字：M (1000)
2. 使用 M 後，剩餘 994
3. 對於 994，使用 CM (900)，剩餘 94
4. 對於 94，使用 XC (90)，剩餘 4
5. 對於 4，使用 IV (4)，剩餘 0
6. 最終結果：MCMXCIV

## 4. 思考過程

針對這個問題，我可以考慮幾種不同的解決方案：

### 方法一：貪心算法（從大到小迭代）

這是一種直觀的方法，我們可以定義所有可能的羅馬數字及其值（包括減法組合如 IV、IX 等），然後從最大的值開始，盡可能多地使用每個符號。

1. 創建一個包含所有羅馬數字及其對應值的有序映射
2. 從最大的值開始遍歷這個映射
3. 對於每個符號，盡可能多地從輸入數字中減去該值，並將相應的羅馬數字添加到結果中
4. 重複直到輸入數字變為 0

### 方法二：分位處理

1. 將數字分解為千位、百位、十位和個位
2. 為每個位置定義特定的羅馬數字映射
3. 根據每個位置的數字選擇適當的羅馬數字

例如：
```
千位映射：["", "M", "MM", "MMM"]
百位映射：["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]
十位映射：["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]
個位映射：["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]
```

### 方法三：查表法

由於問題範圍有限（1-3999），我們可以為每個位置的每個可能數字預定義羅馬數字表示。

比較這三種方法：
- 方法一最為通用和直觀
- 方法二更符合人類思考過程
- 方法三實現最簡單且效率最高，但適用範圍有限

考慮到問題的特性和範圍，我決定同時實現方法一（貪心算法）和方法二（分位處理），因為它們各有優點。

## 5. 最佳解決方案開發

### 方法：貪心算法

首先，定義所有可能的羅馬數字及其值，包括減法組合：

```
符號數值對：
(M, 1000), (CM, 900), (D, 500), (CD, 400), (C, 100), (XC, 90),
(L, 50), (XL, 40), (X, 10), (IX, 9), (V, 5), (IV, 4), (I, 1)
```

這些符號按值從大到小排序，這樣我們可以貪心地選擇符號。

讓我們以 `num = 1994` 演示這個算法：

1. 初始數字 = 1994, 結果 = ""
2. 找到不超過 1994 的最大符號：M (1000)
    - 結果 = "M", 剩餘 = 994
3. 找到不超過 994 的最大符號：CM (900)
    - 結果 = "MCM", 剩餘 = 94
4. 找到不超過 94 的最大符號：XC (90)
    - 結果 = "MCMXC", 剩餘 = 4
5. 找到不超過 4 的最大符號：IV (4)
    - 結果 = "MCMXCIV", 剩餘 = 0

## 6. Golang 實現

### 方法一：貪心算法實現


## 7. 複雜度分析

### 方法：貪心算法

#### 時間複雜度

在此算法中，時間複雜度取決於輸入數字 `num` 和羅馬數字的數量。

- 最壞情況：O(n)，其中 n 是符號出現的次數。在最壞的情況下，如果 `num = 3999`，我們需要使用 "MMM" + "CM" + "XC" + "IX" = 15 個符號。
- 平均情況：O(1)，因為輸入範圍有限（1 ≤ num ≤ 3999），而且符號組合的數量是固定的（13 種）。

重要的是要注意，雖然我們有嵌套循環，但內部循環的總迭代次數實際上只與 `num` 有關，而不與外部循環的大小有關。

#### 空間複雜度

空間複雜度為 O(1)，因為使用的額外空間不依賴於輸入大小：
- 符號表的大小是固定的（13 個條目）
- 結果字串的大小在最壞情況下也不會超過一個常數（對於最大的輸入 3999，結果是 "MMMCMXCIX"，長度為 15）
- 
#### 空間複雜度

空間複雜度為 O(1)，因為使用的額外空間不依賴於輸入大小：
- 預定義的映射表大小是固定的
- 結果字串的大小在最壞情況下也不會超過一個常數

## 8. 優化與改進

我們的解決方案已經相當優化了，主要有以下幾個優點：

### 貪心算法
1. 程式碼簡潔易懂
2. 使用 `strings.Builder` 而不是字串連接來提高效率
3. 通用性強，可以容易地擴展到其他範圍

可能的進一步改進：

1. **混合方法**：對於小於 4000 的數字，使用分位處理；對於更大的數字（如果需要支持），使用貪心算法。

2. **預計算**：如果需要頻繁轉換，可以預先計算 1-3999 的所有羅馬數字表示並存儲在映射中，以便直接查詢。

3. **並行處理**：對於非常大的數字（超出羅馬數字的傳統範圍），可以考慮並行處理不同位置。

權衡考量：
- 對於 LeetCode 問題的具體約束（1 ≤ num ≤ 3999），分位處理方法可能略微更高效。
- 如果需要擴展到更大的數字範圍或處理非常規的羅馬數字規則，貪心算法更為靈活。

## 9. 測試策略

我們設計了全面的測試策略，包括：

1. **單元測試**：
    - 基本符號測試：驗證每個基本羅馬數字是否正確轉換
    - 重複符號測試：測試重複使用相同符號的情況
    - 減法規則測試：測試所有六種減法規則
    - 組合情況測試：測試符號組合的情況
    - 邊界測試：測試最小和最大的有效輸入
    - LeetCode 提供的例子：確保與問題描述一致

2. **性能測試**：
    - 對兩種實現方法進行基準測試
    - 使用不同複雜度的測試用例
    - 比較兩種方法在不同輸入下的性能表現

3. **測試覆蓋**：
    - 我們的測試涵蓋了所有可能的羅馬數字和組合規則
    - 包括各種邊界情況和特殊情況

這些測試共同確保了我們的解決方案在各種情況下的正確性和效率。由於輸入範圍有限（1-3999），所有可能的輸入都可以通過有限數量的測試用例進行有效測試。

總結起來，整數轉羅馬數字是一個直觀但需要仔細處理的問題。我們提供了兩種高效的解決方案，並通過全面的測試確保其正確性。這兩種方法各有優勢，可以根據具體需求選擇使用。