# LeetCode 83: 移除已排序串列中的重複元素 (Remove Duplicates from Sorted List)

## 1. 問題定義

### 原始問題 (英文)
```
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

Example 1:
Input: head = [1,1,2]
Output: [1,2]

Example 2:
Input: head = [1,1,2,3,3]
Output: [1,2,3]

Constraints:
- The number of nodes in the list is in the range [0, 300]
- -100 <= Node.val <= 100
- The list is guaranteed to be sorted in ascending order
```

### 問題翻譯 (繁體中文)
```
給定一個已排序的鏈結串列頭節點，刪除所有重複項，使每個元素只出現一次。傳回排序後的鏈結串列。

範例 1:
輸入: head = [1,1,2]
輸出: [1,2]

範例 2:
輸入: head = [1,1,2,3,3]
輸出: [1,2,3]

限制條件:
- 串列中的節點數量範圍為 [0, 300]
- -100 <= 節點值 <= 100
- 保證串列已按升序排序
```

### 範例與限制
- **範例 1:**
  ```
  輸入: head = [1,1,2]
  輸出: [1,2]
  說明: 第一個 1 後面的重複 1 被移除
  ```
- **範例 2:**
  ```
  輸入: head = [1,1,2,3,3]
  輸出: [1,2,3]
  說明: 重複的 1 和 3 被移除
  ```

- **限制條件:**
    - 串列中的節點數量範圍為 [0, 300]
    - -100 <= 節點值 <= 100
    - 保證串列已按升序排序

## 2. 問題理解

### 初始反應與心智模型
- 這是一個處理鏈結串列的問題，需要刪除重複元素
- 由於串列已排序，相同的元素會相鄰出現
- 我需要遍歷串列並檢查相鄰節點，如果值相同，則需要刪除或跳過後續節點
- 這是一個原地操作問題，不需要額外的數據結構來存儲結果

### 問題分解
- 核心子問題：如何在遍歷過程中安全地移除重複節點
- 需要考慮的基本操作：
    1. 遍歷鏈結串列
    2. 比較相鄰節點的值
    3. 若發現重複，修改指針以跳過重複節點
- 邊界情況：
    1. 空串列 (head == nil)
    2. 只有一個節點的串列
    3. 所有節點都有相同值的串列

### 視覺表示
```
原始串列: 1 -> 1 -> 2 -> 3 -> 3 -> NULL
           |    |
           |    被刪除
           v
        1 -------> 2 -> 3 -> 3 -> NULL
                    |    |
                    |    被刪除
                    v
                 1 -> 2 -------> 3 -> NULL
                                  |
                                  v
                               1 -> 2 -> 3 -> NULL
```
- 這個視覺化幫助理解我們如何通過修改指針來跳過重複節點
- 可以看出，當當前節點的值與下一個節點相同時，我們需要修改當前節點的 next 指針，使其指向下一個節點的 next

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [x] 鏈結串列操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪心演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 問題直接涉及鏈結串列的遍歷與修改
    - 需要比較相鄰節點並刪除重複項
    - 不需要複雜的數據結構或算法策略

### 知識連接
- 基礎資料結構：鏈結串列
- 相關概念：指針操作、節點刪除
- 需要應用的理論知識：鏈結串列的操作特性，特別是如何安全地刪除節點

### 類似問題比較
- LeetCode 82: Remove Duplicates from Sorted List II
    - 相似點：都處理已排序鏈結串列中的重複元素
    - 差異點：82題要求刪除所有出現重複的元素，而不只是重複部分
- LeetCode 26: Remove Duplicates from Sorted Array
    - 相似點：都處理已排序數據中的重複元素
    - 差異點：26題處理的是陣列而非鏈結串列

## 4. 算法直覺發展

### 直覺建立
- 由於串列已排序，重複元素一定相鄰
- 可以用一個指針遍歷串列，每次檢查當前節點與下一個節點的值
- 若相同，就修改指針跳過下一個節點；若不同，則移動到下一個節點
- 這就像在整理一疊排好的卡片，看到重複的卡片就拿掉一張

### 多角度思考
- 迭代 vs 遞迴：
    - 迭代方法：使用一個循環遍歷串列，檢查並刪除重複
    - 遞迴方法：當前節點處理後，遞迴處理下一個不重複的節點
- 本問題中，迭代方法更直觀且空間效率更高

## 5. 解決方案開發歷程

### 方法 1: 迭代解法

#### 思考過程
- 最直觀的方法是遍歷串列，比較當前節點與其下一個節點
- 如果值相同，跳過下一個節點；如果不同，移動到下一個節點
- 這種方法不需要額外空間，時間複雜度為 O(n)

#### 演算法設計
```
1. 如果頭節點為空或只有一個節點，直接返回頭節點
2. 創建一個指針 current 從頭節點開始
3. 當 current 和 current.Next 都不為空時:
   a. 如果 current.Val == current.Next.Val:
      將 current.Next 指向 current.Next.Next (跳過重複節點)
   b. 否則:
      current = current.Next (移動到下一個節點)
4. 返回頭節點
```


#### 實現細節
- 使用單一指針 `current` 遍歷鏈結串列
- 通過修改 `current.Next` 來跳過重複的節點
- 需要特別注意邊界情況的處理，例如空串列或只有一個節點的情況

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是串列長度。我們最多遍歷串列一次。
- **空間複雜度**: O(1)，只使用了常數額外空間。

#### 解決方案評估
- **優點**:
    - 簡單直觀，易於實現
    - 空間效率高，不需要額外空間
    - 時間效率高，只需遍歷一次串列
- **缺點**:
    - 需要處理多個指針操作，容易出錯
- 這個解決方案在面試環境中完全可以接受

### 方法 2: 遞迴解法

#### 關鍵洞見
- 問題可以分解為：處理當前節點的重複，然後處理剩餘串列
- 遞迴可以簡化問題描述，但可能引入額外的函數調用開銷

#### 優化策略
```
1. 如果頭節點為空，直接返回 nil
2. 處理頭節點後面的子串列，獲得不含重複元素的子串列
3. 如果頭節點的值與子串列第一個節點相同，丟棄頭節點，返回子串列
4. 否則，將頭節點與子串列連接起來返回
```

#### 實現改進
- 遞迴方法提供了更簡潔的程式碼
- 邏輯更容易理解：先遞迴處理剩餘部分，再處理當前節點
- 使用 Go 的回傳值機制來簡化重複節點的移除

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是串列長度。每個節點最多被訪問一次。
- **空間複雜度**: O(n)，最壞情況下遞迴調用棧的深度可達 n。

#### 解決方案評估
- **優點**:
    - 程式碼簡潔優雅
    - 問題分解清晰
- **缺點**:
    - 遞迴調用消耗額外空間
    - 對於大型鏈結串列，可能導致堆疊溢出
- 在實際面試中，此解法展示了您對遞迴思想的理解，但應當提及其空間複雜度問題

### 方法 3: 雙指針解法

#### 突破性思考
- 我們可以使用兩個指針：一個指向當前唯一值的最後一個節點，另一個用於探索
- 這種方法可以在一次遍歷中完成串列的處理，且邏輯清晰

#### 最佳演算法
```
1. 如果頭節點為空，直接返回 nil
2. 創建兩個指針 prev 和 explorer，初始都指向頭節點
3. 當 explorer 不為空時:
   a. 如果 prev.Val != explorer.Val:
      prev.Next = explorer (將 prev 的下一個節點設為 explorer)
      prev = explorer (移動 prev 到新的唯一值)
   b. explorer = explorer.Next (繼續探索)
4. prev.Next = nil (截斷串列尾部可能的重複)
5. 返回頭節點
```

#### 實現卓越性
- 雙指針策略使邏輯更清晰：prev 始終指向最後一個不重複的節點
- 程式碼結構簡潔，易於理解
- 特別注意在遍歷結束後設置 `prev.Next = nil`，確保正確處理尾部重複節點

#### 複雜度分析
- **時間複雜度**: O(n)，只需遍歷一次串列。
- **空間複雜度**: O(1)，只使用了兩個指針的額外空間。

#### 從暴力解法到最佳解法的思維演變
- 初始迭代解法：直觀但需要處理多個條件判斷
- 遞迴解法：代碼簡潔但空間效率較低
- 雙指針解法：結合了簡潔和效率，邏輯更清晰
- 這種思維模式可以應用於處理其他鏈結串列問題：從直觀解法開始，通過觀察特性進行優化

## 6. 範例演練與 Go 實現

### 完整示範追蹤
以範例輸入: `[1,1,2,3,3]` 使用雙指針解法:

1. 初始狀態:
    - 輸入: `[1,1,2,3,3]`
    - `prev` = 指向第一個 `1`
    - `explorer` = 指向第二個 `1`

2. 第一次迭代:
    - `prev.Val` (1) == `explorer.Val` (1)，不做任何連接
    - `explorer` 移動到 `2`

3. 第二次迭代:
    - `prev.Val` (1) != `explorer.Val` (2)
    - 設置 `prev.Next = explorer`，將第一個 `1` 連接到 `2`
    - `prev` 移動到 `2`
    - `explorer` 移動到第一個 `3`

4. 第三次迭代:
    - `prev.Val` (2) != `explorer.Val` (3)
    - 設置 `prev.Next = explorer`，將 `2` 連接到第一個 `3`
    - `prev` 移動到第一個 `3`
    - `explorer` 移動到第二個 `3`

5. 第四次迭代:
    - `prev.Val` (3) == `explorer.Val` (3)，不做任何連接
    - `explorer` 移動到 `nil`

6. 循環結束:
    - 設置 `prev.Next = nil`，確保串列正確終止

7. 最終狀態:
    - 輸出: `[1,2,3]`

### 所有方法的效能比較
```
| 方法            | 時間複雜度 | 空間複雜度 | 範例執行時間 |
|----------------|-----------|-----------|------------|
| 迭代解法        | O(n)      | O(1)      | 0 ms       |
| 遞迴解法        | O(n)      | O(n)      | 0 ms       |
| 雙指針解法      | O(n)      | O(1)      | 0 ms       |
```
在這個簡單的問題中，所有解法的時間效能都很接近，但在空間使用上，迭代和雙指針解法更優。

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 最佳解法採用了清晰的變數命名（`prev` 和 `explorer`）
- 遵循 Go 的錯誤處理模式，先處理特殊情況
- 簡潔的條件式和迴圈結構提高了程式碼可讀性

### 錯誤處理與邊界情況
- 妥善處理空串列情況
- 處理單節點串列
- 特別注意處理串列尾部的重複節點

## 8. 面試模擬

### 時間管理計劃
- 問題理解: ~2分鐘
- 初始解法提案: ~3分鐘
- 優化討論: ~3分鐘
- 程式碼編寫: ~5分鐘
- 測試與除錯: ~2分鐘

### 面試互動模擬
- 如何向面試官解釋我的 Go 實現:
  「我會使用雙指針解法，一個指針保持在最後一個不重複的節點，另一個探索新節點。當探索指針找到新的不重複值時，就建立連接；否則就繼續探索。這種方法只需一次遍歷，空間複雜度為 O(1)。」

- 可能的提示和引導問題:
    - 「如果串列非常長，會有什麼效能考量？」
    - 「你能否用遞迴方式解決這個問題？」
    - 「這個解法如何處理尾部的重複節點？」

### 潛在的後續問題
- 如何修改代碼以處理未排序的串列？
- 如果需要保留恰好一個重複元素（即每個值最多出現兩次），如何修改解法？
- 如何在不使用額外空間的情況下檢測串列中是否存在循環？

## 9. 知識整合與學習

### 問題解決洞見
- 從這個問題中，我學到了如何有效地處理鏈結串列中的特定模式（重複元素）
- 雙指針技術在處理串列問題時非常有用，可以減少邏輯複雜度
- 處理鏈結串列時，特別注意邊界情況和指針操作的安全性

### 心智模型建構
- 解決鏈結串列問題的框架：
    1. 先處理邊界情況（空串列、單節點）
    2. 確定是否需要多個指針來追蹤不同狀態
    3. 小心指針修改操作，確保不會丟失節點或創建循環
    4. 考慮串列尾部的特殊處理

### 錯誤模式識別
- 忘記處理空串列或單節點的情況
- 未正確終止串列，導致尾部重複節點保留
- 指針移動順序不當，導致節點丟失

### 知識圖譜擴展
- 相關資源：
    - 《數據結構與算法分析：Go 語言描述》
    - Go 標準庫中的 container/list 包
- 進階技術：
    - 快慢指針檢測循環
    - Floyd's Cycle-Finding Algorithm