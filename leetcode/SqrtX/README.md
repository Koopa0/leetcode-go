# LeetCode 69: Sqrt(x) 平方根函數

## 1. 問題定義

### 原始問題 (English)
```
Given a non-negative integer x, return the square root of x rounded down to the nearest integer.

The returned integer should be non-negative as well.

You must not use any built-in exponent function or operator.

For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.
```

### 問題翻譯 (繁體中文)
```
給定一個非負整數 x，返回 x 的平方根，並向下取整到最接近的整數。

返回的整數也應該是非負的。

你不能使用任何內建的指數函數或運算符。

例如，不要在 c++ 中使用 pow(x, 0.5) 或在 python 中使用 x ** 0.5。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: x = 4
  輸出: 2
  解釋: 4 的平方根是 2，所以我們返回 2。
  ```
- **範例 2:**
  ```
  輸入: x = 8
  輸出: 2
  解釋: 8 的平方根是 2.82842...，因為我們向下取整到最接近的整數，所以返回 2。
  ```

- **限制條件:**
    - 0 <= x <= 2^31 - 1

## 2. 問題理解

### 初始反應與心智模型
- 這個問題看起來是要我們實現一個求平方根的函數，不能使用內建的函數。
- 我們需要找到一個非負整數，其平方小於或等於 x，且是最大的這種數。
- 實際上，我們尋找的是最大的整數 k，使得 k² ≤ x < (k+1)²。
- 可以想像成在數線上找一個位置，使得該位置的平方剛好不超過目標數字。

### 問題分解
- 核心子問題：找到最大的整數 k，使得 k² ≤ x。
- 需要處理的特殊情況：x = 0 時，平方根為 0。
- 需要確保運算過程中不會發生整數溢出問題，特別是在計算大數的平方時。

### 視覺表示
```
對於 x = 8:

0² = 0 < 8
1² = 1 < 8
2² = 4 < 8
3² = 9 > 8

所以答案是 2。

數線表示：
0---1---2---3---
   平方：
0---1---4---9---
           ^
           |
          x=8
```
- 這個視覺化幫助我們理解我們在尋找的是一個閾值，即最後一個平方值不超過 x 的整數。

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [x] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [x] 其他: 數值計算

- 識別基礎：
    - 問題要求在一個有序範圍內（從0到x）找到一個滿足特定條件的值，這非常適合使用二分搜尋。
    - 我們在尋找一個邊界值（最大的k使得k²≤x），這是二分搜尋的典型應用。

### 知識連接
- 此問題涉及的基本計算機科學概念：二分搜尋、整數運算、邊界條件處理。
- 這個問題也和數值分析中的根查找算法有關，如牛頓法。
- 需要注意整數溢出的問題，特別是在計算大數的平方時。

### 相似問題比較
- LeetCode 35: 搜尋插入位置 - 同樣使用二分搜尋找到一個特定位置。
- LeetCode 367: 有效的完全平方數 - 判斷一個數是否為完全平方數。
- LeetCode 50: Pow(x, n) - 計算冪次方，也是一種數值運算問題。

## 4. 算法直覺發展

### 直覺建立
- 最直接的方法是從1開始逐一檢查每個數的平方是否超過x，但這對大數效率很低。
- 更高效的方法是使用二分搜尋，因為我們知道答案一定在0到x之間。
- 牛頓法也是一個解決此類問題的高效方法，它利用迭代快速收斂到答案。

### 多角度思考
- 從頂部到底部思考：我們可以從可能的最大值開始，然後逐步縮小範圍。
- 從底部到頂部思考：我們可以從0開始，逐步增加直到找到答案。
- 二分法：直接在可能的答案範圍中進行二分搜尋，這是最高效的方法。
- 對於這種尋找特定閾值的問題，二分搜尋通常是最有效的方法。

## 5. 解決方案開發過程

### 方法一：暴力解法

#### 思考過程
- 最直接的方法是從1開始，逐一檢查每個數的平方是否超過x。
- 找到第一個平方大於x的整數k，則答案為k-1。
- 這個方法簡單明瞭，但對於大數效率低下。

#### 算法設計
```
1. 如果 x = 0，直接返回 0。
2. 從 i = 1 開始遍歷：
   - 如果 i*i > x，則返回 i-1。
   - 否則繼續增加 i。
```

#### 實現細節
- 使用了最基本的整數迭代。
- 需要特別處理 x = 0 的情況。
- 注意迴圈的終止條件，確保找到的是最大的滿足條件的整數。

#### 複雜度分析
- **時間複雜度**: O(√x) — 迴圈會執行大約 √x 次。
- **空間複雜度**: O(1) — 只使用了常數空間。

#### 解決方案評估
- 優點：簡單直觀，容易實現。
- 缺點：對於大數效率低下，時間複雜度與輸入的平方根成正比。
- 在面試情境中，這種方法可以作為起點，但應該繼續優化。

### 方法二：二分搜尋解法

#### 關鍵洞察
- 暴力解法中，我們線性搜尋答案，效率不高。
- 由於我們在一個有序範圍內尋找特定值，可以使用二分搜尋提高效率。
- 二分搜尋可以將時間複雜度從 O(√x) 降低到 O(log x)。

#### 優化策略
```
1. 設置搜尋範圍 left = 0, right = x。
2. 當 left <= right 時，計算中間值 mid = (left + right) / 2。
3. 如果 mid*mid <= x < (mid+1)*(mid+1)，則 mid 就是答案。
4. 如果 mid*mid > x，則在左半部分搜尋，right = mid - 1。
5. 如果 mid*mid < x 且 (mid+1)*(mid+1) <= x，則在右半部分搜尋，left = mid + 1。
```

#### 實現改進
- 使用 `mid <= x / mid` 而不是 `mid * mid <= x` 來避免整數溢出。
- 使用 `left + (right - left) / 2` 計算中間值，這樣可以避免 `left + right` 可能的溢出。
- 在二分搜尋的過程中檢查邊界條件，確保找到正確的答案。

#### 複雜度分析
- **時間複雜度**: O(log x) — 二分搜尋的標準時間複雜度。
- **空間複雜度**: O(1) — 只使用了常數空間。

#### 解決方案評估
- 優點：效率高，能夠處理大數輸入。
- 缺點：實現稍微複雜一些，需要仔細處理邊界條件和整數溢出問題。
- 在面試情境中，這種方法展示了你對二分搜尋的理解和處理數值問題的能力。

### 方法三：牛頓法

#### 突破性思考
- 牛頓法是一種用於求解方程根的迭代算法，對於計算平方根特別有效。
- 對於求解 f(x) = 0 的根，牛頓法使用迭代公式 x_{n+1} = x_n - f(x_n) / f'(x_n)。
- 對於平方根問題，我們求解 f(r) = r^2 - x = 0，牛頓迭代公式簡化為 r_{n+1} = (r_n + x/r_n) / 2。

#### 最佳算法
```
1. 選擇一個初始猜測值 r = x。
2. 重複迭代：r = (r + x/r) / 2，直到收斂。
3. 由於我們需要向下取整，最終返回 floor(r)。
```

#### 實現卓越性
- 使用牛頓法快速收斂到平方根值。
- 避免了整數溢出問題，同時保持了代碼簡潔。
- 迭代條件 `r > x/r` 確保了我們找到的是向下取整的平方根。

#### 複雜度分析
- **時間複雜度**: O(log x) — 牛頓法的收斂速度非常快，通常只需要少數幾次迭代。
- **空間複雜度**: O(1) — 只使用了常數空間。

#### 從暴力到最佳的思考演變
- 我們從最直觀的線性搜尋開始，識別出效率問題。
- 利用二分搜尋，我們將時間複雜度從 O(√x) 改進到 O(log x)。
- 最後，通過應用牛頓法，我們達到了一個既高效又優雅的解決方案。
- 這種思考模式展示了如何通過數學洞察力來優化算法。

## 6. 範例演算與 Go 實現過程

### 完整範例演算
使用牛頓法解法追蹤輸入 x = 8 的過程：

1. 初始狀態：
    - 輸入：`x = 8`
    - 變數 `r = 8`

2. 第一次迭代：
    - 計算 `r = (r + x/r) / 2 = (8 + 8/8) / 2 = (8 + 1) / 2 = 4.5`
    - 由於整數除法，實際上 `r = 4`

3. 第二次迭代：
    - 檢查 `r > x/r`：`4 > 8/4`？是的，`4 > 2`
    - 計算 `r = (r + x/r) / 2 = (4 + 8/4) / 2 = (4 + 2) / 2 = 3`

4. 第三次迭代：
    - 檢查 `r > x/r`：`3 > 8/3`？是的，`3 > 2.67`
    - 計算 `r = (r + x/r) / 2 = (3 + 8/3) / 2 = (3 + 2.67) / 2 = 2.83`
    - 由於整數除法，實際上 `r = 2`

5. 最後一次檢查：
    - `r > x/r`：`2 > 8/2`？不是，`2 = 4`，迭代結束

6. 最終狀態：
    - 輸出：`2`

### 所有方法的性能比較
```
| 方法           | 時間複雜度   | 空間複雜度  | 範例運行時間 |
|---------------|------------|------------|------------|
| 暴力解法       | O(√x)      | O(1)       | 線性增長    |
| 二分搜尋解法   | O(log x)   | O(1)       | 對數增長    |
| 牛頓法解法     | O(log x)   | O(1)       | 最快收斂    |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我的解決方案遵循 Go 的簡潔性和明確性原則。
- 使用整數算術而非浮點運算，這在 Go 中更有效率。
- 避免使用過於複雜的數據結構，保持代碼簡單明了。

### 錯誤處理與邊界情況
- 特別處理 x = 0 的情況。
- 使用 `mid <= x / mid` 而非 `mid * mid <= x` 避免整數溢出。
- 確保二分搜尋的邊界條件正確處理

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2分鐘
- 初始解決方案提案：~3分鐘（暴力解法）
- 優化討論：~5分鐘（二分搜尋和牛頓法）
- 代碼編寫：~10分鐘
- 測試與除錯：~5分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現：
    - "我首先想到的是暴力解法，但考慮到效率問題，我轉向了二分搜尋"
    - "為了避免整數溢出，我使用了 `mid <= x / mid` 而不是 `mid * mid <= x`"
    - "最後，我發現牛頓法提供了一個更優雅的解決方案，具有快速收斂的特性"

### 可能的後續問題
- 如果輸入規模大幅增加，你會如何修改你的 Go 代碼？
- 如果我們需要計算精確的平方根（包括小數部分），你的解決方案會如何改變？
- 你如何擴展你的解決方案來處理求立方根或任意次方根的問題？

## 9. 知識整合與學習

### 解題洞察
- 這個問題教會了我如何在 Go 中高效地實現數值算法。
- 我更深入地理解了整數溢出問題及其處理方法。
- 我需要進一步加強對數學算法在計算機科學中應用的理解。

### 心智模型構建
- 從這個問題中，我抽象出了一個尋找閾值的框架：
    1. 識別問題的搜尋空間
    2. 根據搜尋空間的特性選擇適當的算法（線性、二分、牛頓等）
    3. 仔細處理邊界條件和潛在的數值問題
- 這個框架可以應用於類似的尋找閾值問題。

### 錯誤模式識別
- 最初沒有考慮整數溢出問題。
- 在實現二分搜尋時，邊界條件處理不夠仔細。
- 這些錯誤揭示了我在處理數值計算和邊界條件時的盲點。

### 知識圖譜擴展
- 相關的 Go 編程資源：
    - Go 的數值計算套件和最佳實踐
    - Go 中的位元操作和整數處理技巧
- 這個實現如何融入我的整體 Go 知識體系：
    - 加深了對 Go 中整數運算的理解
    - 提高了實現數學算法的能力