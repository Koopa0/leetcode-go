# 回文數問題：反轉一半數字的解法

## 問題理解

回文數是指從左往右讀和從右往左讀都相同的數字。例如，121、1221、12321 都是回文數，而 123、-121、10 則不是。我們需要設計一個有效的算法來判斷一個整數是否為回文數。

## 基本思路探索

我們可以從多個角度思考這個問題：

首先，最直觀的方法是將整數轉換為字符串，然後檢查這個字符串是否是回文。這個方法雖然簡單，但需要額外的空間來存儲字符串，不是最優解。

其次，我們可以考慮完全反轉整數，然後比較原數和反轉後的數字是否相同。這個方法雖然避免了字符串轉換，但反轉整數可能會導致溢出問題，特別是當數字非常大的時候。

在深入思考後，我們發現了一個更優雅的解決方案：只反轉數字的一半，然後與另一半比較。這個方法既避免了溢出問題，又減少了計算量。

## 算法詳細說明

這個方法的核心思想是：**回文數的後半部分反轉後應該等於前半部分**。

具體步驟如下：

1. 首先處理特殊情況：
    - 負數不可能是回文數，因為負號在反轉後會出現在末尾
    - 如果數字末尾是0，且數字不是0本身，則不可能是回文數（因為回文數的開頭不能是0）

2. 反轉數字的後半部分：
    - 使用模運算和整除運算逐位提取數字
    - 將提取的數字加到反轉結果的末尾

3. 判斷何時反轉了一半的數字：
    - 當原數字小於或等於反轉後的數字時，表示已經處理了一半或剛好一半

4. 比較原數字與反轉後的數字：
    - 對於偶數位數的回文數（如1221），原數字應等於反轉後的數字
    - 對於奇數位數的回文數（如12321），原數字應等於反轉後的數字除以10（去掉中間數字）

## 算法執行過程視覺化

讓我們通過兩個具體例子來理解這個過程：

### 例子1：判斷12321是否為回文數

```
初始狀態：x = 12321, reversed = 0
第一次循環：x = 1232, reversed = 1      (提取最後一位1)
第二次循環：x = 123, reversed = 12      (提取最後一位2)
第三次循環：x = 12, reversed = 123      (提取最後一位3)
循環結束，因為 x < reversed
檢查：12 == 123/10 (12) ✓
結論：12321 是回文數
```

### 例子2：判斷1234是否為回文數

```
初始狀態：x = 1234, reversed = 0
第一次循環：x = 123, reversed = 4      (提取最後一位4)
第二次循環：x = 12, reversed = 43      (提取最後一位3)
循環結束，因為 x < reversed
檢查：12 == 43/10 (4) ✗
結論：1234 不是回文數
```

## 邊界情況處理

這個算法優雅地處理了各種邊界情況：

1. **負數**：
    - 例如：-121 不是回文數，因為反轉後變成 121-
    - 所有負數都可以直接返回 false

2. **末尾為0的數字**：
    - 例如：10 不是回文數，因為反轉後變成 01，而整數不能以0開頭
    - 只有0本身例外，它是回文數

3. **奇數位數與偶數位數**：
    - 偶數位數（如1221）：反轉一半後，x == reversed
    - 奇數位數（如12321）：反轉一半後，中間數字會在reversed中，所以x == reversed/10

## 高效性分析

### 時間複雜度

時間複雜度為 O(log₁₀n)，其中n是輸入整數。這是因為：
- 一個數字n的位數大約是log₁₀n
- 我們只處理了數字的一半，所以循環執行大約log₁₀n/2次
- 大O表示法中忽略常數因子，所以複雜度仍為O(log₁₀n)

### 空間複雜度

空間複雜度為 O(1)，因為我們只使用了幾個變量（x和reversed），不管輸入多大，所需空間都是常數。

## 程式碼實現

以下是完整的Go語言實現：

```go
func isPalindrome(x int) bool {
    // 特殊情況處理：
    // 1. 負數不可能是回文數
    // 2. 非零數字但末尾為0的數不可能是回文數
    if x < 0 || (x % 10 == 0 && x != 0) {
        return false
    }
    
    reversed := 0
    
    // 只反轉數字的一半
    // 當原數字小於或等於反轉數字時，表示已經處理了一半或剛好一半
    for x > reversed {
        // 取出原數字的最後一位，加到反轉數字的末尾
        reversed = reversed * 10 + x % 10
        // 去掉原數字的最後一位
        x /= 10
    }
    
    // 偶數位數：x 應等於 reversed（如 1221 中，x=12，reversed=12）
    // 奇數位數：x 應等於 reversed/10（如 12321 中，x=12，reversed=123，需要去掉中間的3）
    return x == reversed || x == reversed/10
}
```

## 算法洞察與應用

這種「只處理一半數據」的方法體現了解決對稱性問題的一種重要思維模式：**當問題具有對稱特性時，我們往往只需要處理一半的數據**。

這種思路可以應用到許多其他問題中：

1. **回文字符串檢測**：可以從兩端向中間比較，或者類似地只反轉一半

2. **回文鏈表判斷**：可以找到鏈表中點，反轉後半部分，然後與前半部分比較

3. **對稱二叉樹判斷**：可以同時遍歷左右子樹，比較對應節點值

## 總結

「反轉一半數字」的方法是解決回文數問題的優雅解決方案。它充分利用了回文數的對稱特性，既避免了可能的整數溢出問題，又減少了計算量。這種算法的設計思路也可以啟發我們解決其他具有對稱性的問題。

解決回文數問題的關鍵在於理解：**對於回文數，反轉後半部分應該等於前半部分**。這個洞察幫助我們設計出了一個既高效又簡潔的算法。