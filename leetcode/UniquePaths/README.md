# LeetCode 62: Unique Paths - 不同路徑問題分析

## 1. 問題定義

### 原始問題 (英文)
```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
```

### 問題翻譯 (繁體中文)
```
一個機器人位於 m x n 網格的左上角（在下圖中標記為「起點」）。

機器人每一時刻只能向下或者向右移動一步。機器人試圖到達網格的右下角（在下圖中標記為「終點」）。

總共有多少條不同的路徑？
```

### 範例與限制
- **範例 1:**
  ```
  輸入: m = 3, n = 7
  輸出: 28
  ```
- **範例 2:**
  ```
  輸入: m = 3, n = 2
  輸出: 3
  解釋: 
  從左上角開始，總共有 3 條路徑可以到達右下角。
  1. 向右 -> 向下 -> 向下
  2. 向下 -> 向右 -> 向下
  3. 向下 -> 向下 -> 向右
  ```

- **限制條件:**
    - 1 <= m, n <= 100
    - 答案保證是小於 2 * 10^9 的整數

## 2. 問題理解

### 初始反應與心智模型
- 初看此問題，這是一個典型的路徑規劃問題。
- 機器人只能向右或向下移動，從左上到右下。
- 我需要計算出所有可能的路徑數量，而不是尋找最短路徑。
- 可以把這個問題看作是一個組合問題，因為機器人總共需要移動 (m-1) + (n-1) 步，其中包含 (m-1) 次向下移動和 (n-1) 次向右移動。

### 問題分解
- 計算從起點 (0,0) 到終點 (m-1,n-1) 的所有可能路徑數量。
- 每一步只能選擇向右或向下移動。
- 路徑數量取決於網格大小 m 和 n。
- 需要處理的邊界情況：當 m=1 或 n=1 時，只有一條路徑。

### 視覺表示
```
(0,0) → → →
  ↓       ↓
  ↓       ↓
  ↓ → → → (m-1,n-1)
```
- 這個視覺化表示幫助我們理解：從任何點 (i,j)，我們只能移動到 (i+1,j) 或 (i,j+1)。
- 到達某點 (i,j) 的路徑數量等於到達 (i-1,j) 和 (i,j-1) 的路徑數量之和。

## 3. 模式識別與知識映射

### 演算法模式分類
- 此問題屬於以下常見演算法模式：
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [x] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [x] 其他: 數學組合

- 識別依據:
    - 問題具有重疊子問題和最優子結構的特性。
    - 到達一個格子的路徑數取決於到達上方格子和左方格子的路徑數。
    - 這是一個計數問題，而不是最佳化問題。

### 知識連結
- 此問題涉及到的基本資訊科學概念包括：動態規劃、組合數學。
- 從組合數學角度看，這個問題等同於在 (m+n-2) 步中選擇 (m-1) 步向下移動的方式，即組合數 C(m+n-2, m-1)。
- 這個問題還可以使用二維陣列或一維陣列進行動態規劃求解。

### 類似問題比較
- LeetCode 63: Unique Paths II（有障礙物的不同路徑）
- LeetCode 64: Minimum Path Sum（最小路徑和）
- LeetCode 980: Unique Paths III（必須訪問所有空格子的不同路徑）
- 這些問題都是在網格上移動的變形，但本題最為基礎，沒有障礙物且只關心路徑數量。

## 4. 演算法直覺發展

### 直覺建立
- 想象一個人從起點到終點的所有可能走法，每次只能選擇向右或向下。
- 如果我們看各個格子，到達每個格子的路徑數等於到達其上方格子和左方格子的路徑數之和。
- 這種關係正好符合動態規劃的特性，可以通過構建一個表格來計算答案。

### 多角度思考
- 從組合數學角度：無論如何，機器人都需要向右移動 (n-1) 次，向下移動 (m-1) 次，總計 (m+n-2) 步。問題變成在 (m+n-2) 個位置中選擇 (m-1) 個位置放置向下的移動。
- 從動態規劃角度：我們可以構建一個二維陣列 dp，其中 dp[i][j] 表示從左上角到達位置 (i,j) 的路徑數量。
- 遞迴角度：我們可以定義一個函數 f(i,j) 表示從 (i,j) 到終點的路徑數量，然後使用記憶化搜尋來避免重複計算。

## 5. 解決方案開發過程

### 方法一：暴力遞迴（無優化）

#### 思考過程
- 最直接的方法是使用遞迴，從起點開始，嘗試所有可能的路徑。
- 對於每個位置 (i,j)，我們可以選擇向右或向下，然後遞迴計算。
- 然而，這種方法會導致大量重複計算，效率非常低。

#### 演算法設計
```
定義函數 uniquePaths(i, j, m, n):
    如果 i == m-1 且 j == n-1，返回 1（已達終點）
    如果 i >= m 或 j >= n，返回 0（越界）
    
    計算向右移動的路徑數：rightPaths = uniquePaths(i, j+1, m, n)
    計算向下移動的路徑數：downPaths = uniquePaths(i+1, j, m, n)
    
    返回 rightPaths + downPaths
```

#### 實作細節
- 使用簡單的遞迴函數實現。
- 基本情況：當到達終點時返回 1，當越界時返回 0。
- 遞迴情況：路徑數量等於向右移動和向下移動的路徑數量之和。
- 由於 Go 沒有自帶的記憶化機制，這個暴力解法會有大量重複計算。

#### 複雜度分析
- **時間複雜度**: O(2^(m+n)) — 每個位置都有兩種選擇（向右或向下），總共需要 m+n-2 步才能到達終點。
- **空間複雜度**: O(m+n) — 遞迴的最大深度為路徑長度 m+n-2。

#### 解法評估
- 優點：實作簡單，易於理解。
- 缺點：時間複雜度呈指數級別，對於較大的 m 和 n 會超時。
- 在面試情境中，這只能作為初步解法，需要進一步優化。

### 方法二：記憶化遞迴

#### 關鍵洞見
- 暴力遞迴中有大量重複計算。例如，到達 (1,1) 的路徑數被多次計算。
- 我們可以使用記憶化（備忘錄）來儲存已計算過的結果，避免重複計算。

#### 優化策略
```
初始化一個二維陣列 memo[m][n]，用於儲存中間結果。
定義函數 uniquePaths(i, j, m, n, memo):
    如果 i == m-1 且 j == n-1，返回 1
    如果 i >= m 或 j >= n，返回 0
    如果 memo[i][j] 已經計算過，直接返回 memo[i][j]
    
    rightPaths = uniquePaths(i, j+1, m, n, memo)
    downPaths = uniquePaths(i+1, j, m, n, memo)
    
    memo[i][j] = rightPaths + downPaths
    返回 memo[i][j]
```

#### 實作改進
- 使用二維陣列 memo 儲存從位置 (i,j) 到終點的路徑數量。
- 在遞迴之前檢查是否已經計算過，如果已計算過則直接返回儲存的結果。
- 這種方法大大減少了重複計算，提高了效率。

#### 複雜度分析
- **時間複雜度**: O(m*n) — 每個格子只會被計算一次，共有 m*n 個格子。
- **空間複雜度**: O(m*n) — 備忘錄的大小為 m*n，遞迴調用棧的最大深度為 m+n-2。

#### 解法評估
- 優點：避免了重複計算，時間複雜度從指數級下降到多項式級。
- 缺點：仍使用遞迴，對於極大的輸入可能導致棧溢出。
- 在面試情境中，這是一個可接受的解法，但還可以進一步優化。

### 方法三：動態規劃（自底向上）

#### 突破性思考
- 我們可以使用動態規劃，自底向上地構建解。
- 定義 dp[i][j] 為從起點到位置 (i,j) 的路徑數量。
- 邊界條件：第一行和第一列的所有位置都只有一條路徑可達（只能向右或向下移動）。
- 遞推關係：dp[i][j] = dp[i-1][j] + dp[i][j-1]。

#### 最佳演算法
```
初始化二維陣列 dp[m][n]，所有元素設為 0
設定邊界條件：
    對於所有 0 <= i < m: dp[i][0] = 1
    對於所有 0 <= j < n: dp[0][j] = 1
    
對於 1 <= i < m, 1 <= j < n:
    dp[i][j] = dp[i-1][j] + dp[i][j-1]
    
返回 dp[m-1][n-1]
```

#### 實作卓越性
- 使用二維陣列儲存動態規劃狀態，避免了遞迴調用。
- 先初始化邊界條件，然後按照狀態轉移方程填充表格。
- 這種方法直接計算最終答案，沒有多餘的計算。

#### 複雜度分析
- **時間複雜度**: O(m*n) — 需要填充 m*n 大小的表格。
- **空間複雜度**: O(m*n) — 需要 m*n 大小的二維陣列。

#### 從暴力到最佳的思考演變
- 暴力解法：直接使用遞迴嘗試所有可能的路徑，存在大量重複計算。
- 記憶化遞迴：引入備忘錄避免重複計算，從「自頂向下」的角度解決問題。
- 動態規劃：轉變為「自底向上」的思路，直接填表得到答案，避免了遞迴調用的開銷。
- 這種思考演變從指數級別的時間複雜度優化到了多項式級別。

### 方法四：空間優化的動態規劃

#### 空間優化思路
- 注意到在填充 dp 表格時，每次計算 dp[i][j] 只需要用到 dp[i-1][j] 和 dp[i][j-1]。
- 因此，我們只需要保存一行數據，而不需要整個二維表格。

#### 實作細節
- 使用一維陣列 dp，其中 dp[j] 表示到達當前行第 j 列的路徑數量。
- 初始化 dp 陣列全部為 1，對應第一行的情況。
- 在更新 dp[j] 時，原始的 dp[j] 表示上一行的值，而 dp[j-1] 表示當前行前一列的值。

#### 複雜度分析
- **時間複雜度**: O(m*n) — 仍需要進行 m*n 次計算。
- **空間複雜度**: O(n) — 只需要存儲一行的數據，大幅減少了空間使用。

### 方法五：數學組合解法

#### 組合數學思考
- 從起點到終點，總共需要向右移動 (n-1) 次，向下移動 (m-1) 次。
- 總共需要移動 (m+n-2) 步，其中選擇 (m-1) 步向下移動（或選擇 (n-1) 步向右移動）。
- 因此，問題轉化為：在 (m+n-2) 個位置中選擇 (m-1) 個位置的組合數，即 C(m+n-2, m-1)。

#### 實作細節
- 計算組合數 C(m+n-2, min(m-1, n-1))。
- 為避免計算階乘時的溢出問題，採用逐步計算的方式。
- 選擇 m-1 和 n-1 中較小的一個作為 k，可以減少計算量。

#### 複雜度分析
- **時間複雜度**: O(min(m,n)) — 只需要進行 min(m-1,n-1) 次乘除運算。
- **空間複雜度**: O(1) — 只需要常數級別的額外空間。

#### 解法評估
- 優點：時間和空間複雜度都非常優秀，是理論上最優的解法。
- 缺點：需要注意大數運算和溢出問題，實作需要小心處理。
- 這個解法在面試中展示了對問題的深刻理解和數學建模能力。

## 6. 範例演算逐步追蹤

### 完整範例追蹤
以範例輸入：m = 3, n = 3 為例，使用動態規劃解法追蹤：

1. 初始狀態：
    - 初始化 dp 表格為 3x3 大小
   ```
   dp = [
     [1, 1, 1],
     [1, 0, 0],
     [1, 0, 0]
   ]
   ```

2. 填充 dp[1][1]：
    - dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
   ```
   dp = [
     [1, 1, 1],
     [1, 2, 0],
     [1, 0, 0]
   ]
   ```

3. 填充 dp[1][2]：
    - dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
   ```
   dp = [
     [1, 1, 1],
     [1, 2, 3],
     [1, 0, 0]
   ]
   ```

4. 填充 dp[2][1]：
    - dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3
   ```
   dp = [
     [1, 1, 1],
     [1, 2, 3],
     [1, 3, 0]
   ]
   ```

5. 填充 dp[2][2]：
    - dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6
   ```
   dp = [
     [1, 1, 1],
     [1, 2, 3],
     [1, 3, 6]
   ]
   ```

6. 最終狀態：
    - 輸出：dp[2][2] = 6

### 所有方法的效能比較
```
| 方法            | 時間複雜度         | 空間複雜度        | 範例執行時間   |
|----------------|------------------|-----------------|--------------|
| 暴力遞迴         | O(2^(m+n))       | O(m+n)          | 較長         |
| 記憶化遞迴       | O(m*n)           | O(m*n)          | 中等          |
| 動態規劃（二維）  | O(m*n)           | O(m*n)          | 中等          |
| 動態規劃（一維）  | O(m*n)           | O(n)            | 中等          |
| 數學組合解法      | O(min(m,n))      | O(1)            | 最快          |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解法遵循 Go 的最佳實踐：
    - 使用清晰的變數命名
    - 適當的函數設計和參數傳遞
    - 在關鍵步驟添加註釋
    - 避免不必要的記憶體分配

### 錯誤處理與邊界情況
- 處理了特殊情況：當 m=1 或 n=1 時，只有一條路徑。
- 數學組合解法中需要注意大數運算和溢出問題。
- 確保代碼對於所有有效輸入都能正確工作

## 8. 面試模擬

### 時間管理計劃
- 問題理解：~2-3 分鐘
- 初始解法提案：~5 分鐘 (暴力遞迴 → 動態規劃)
- 優化討論：~5-7 分鐘 (空間優化 → 數學組合解法)
- 程式碼撰寫：~10 分鐘 (實作 DP 解法和數學組合解法)
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實作：
  "這是一個典型的動態規劃問題。首先，我定義 dp[i][j] 表示從起點到位置 (i,j) 的路徑數。由於機器人只能向右或向下移動，所以到達 (i,j) 的路徑數等於到達 (i-1,j) 和 (i,j-1) 的路徑數之和。邊界條件是第一行和第一列的所有位置都只有一條路徑可達。我還注意到這個問題可以用組合數學解決，相當於在 m+n-2 步中選擇 m-1 步向下移動的組合數。"

- 潛在引導問題：
    - "你是如何發現這個問題可以用數學組合解決的？"
    - "如果網格非常大，你的解法會有什麼問題？如何優化？"
    - "如何處理大數運算的溢出問題？"

### 潛在跟進問題
- 如果輸入規模增大，你會如何修改你的 Go 程式碼？
    - "對於極大的輸入，數學組合解法是最好的，但需要小心處理大數運算。我會使用 big.Int 來避免溢出，或者利用對數運算來簡化大數乘法。"

- 如果記憶體受限，你會如何優化？
    - "我會使用一維動態規劃解法，只保存一行數據，將空間複雜度降低到 O(n)。"

- 如果問題變形為「有障礙物的不同路徑」（Unique Paths II），你會如何修改解法？
    - "對於有障礙物的情況，我會修改 DP 轉移方程：如果當前格子是障礙物，則 dp[i][j] = 0；否則，dp[i][j] = dp[i-1][j] + dp[i][j-1]。邊界條件也需要修改，如果第一行或第一列有障礙物，則該障礙物之後的格子都無法到達。"

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會了我動態規劃在路徑規劃問題中的應用。
- 學習了如何從遞迴解法優化到動態規劃，再到空間優化，最後發現數學組合解法。
- 理解了如何在 Go 中有效地實作這些不同的解法。

### 心智模型構建
- 這個問題幫助我建立了「路徑計數」問題的通用框架：
    1. 識別問題的狀態定義和轉移方程
    2. 確定邊界條件
    3. 思考是否可以優化空間複雜度
    4. 尋找可能的數學解法

### 錯誤模式識別
- 初始實作中可能忽略的邊界情況，如 m=1 或 n=1 的情況。
- 在數學組合解法中需要小心處理的大數運算和溢出問題。
- 在實作遞迴解法時未使用記憶化導致的效率問題。

### 知識圖譜擴展
- 相關 Go 程式設計資源：
    - [Go 官方文件](https://golang.org/doc/)
    - [Effective Go](https://golang.org/doc/effective_go)
    - [Go 語言聖經](https://gopl-zh.github.io/)
- 這個實作與其他動態規劃問題（如最短路徑、背包問題）有相似之處。

### 弱點識別與強化
- 需要加強的 Go 程式設計弱點：
    - 熟悉 Go 的 big.Int 套件，以處理大數運算
    - 提高對 Go 記憶體管理的理解
    - 學習更多 Go 的測試最佳實踐
- 學習計畫：
    - 系統學習 Go 標準庫中的數學和測試相關套件
    - 練習更多需要大數運算的問題
    - 為每個解法編寫全面的單元測試和基準測試