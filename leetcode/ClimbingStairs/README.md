# LeetCode 70: 爬樓梯 (Climbing Stairs)

## 1. 問題定義

### 原始問題 (英文)
```
You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
```

### 問題翻譯 (繁體中文)
```
你正在爬樓梯。到達頂部需要 n 個階梯。

每次你可以爬 1 或 2 個階梯。有多少種不同的方法可以爬到頂部？
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: n = 2
  輸出: 2
  解釋: 有兩種方式可以爬到頂端。
  1. 1 階 + 1 階
  2. 2 階
  ```
- **範例 2:**
  ```
  輸入: n = 3
  輸出: 3
  解釋: 有三種方式可以爬到頂端。
  1. 1 階 + 1 階 + 1 階
  2. 1 階 + 2 階
  3. 2 階 + 1 階
  ```

- **限制條件:**
    - 1 <= n <= 45

## 2. 問題理解

### 初始反應與心智建模
- 第一反應：這是一個組合問題，我們需要找出所有可能的爬樓梯方式。
- 觀察範例：對於每一階樓梯，我們可以選擇爬 1 階或 2 階，這些選擇會產生不同的組合路徑。
- 輸入輸出：輸入是樓梯的總階數 n，輸出是可能的爬樓梯方法數量。
- 視覺化：可以將問題視為從 0 階到 n 階的路徑選擇問題。

### 問題分解
- 核心子問題：要到達第 n 階樓梯，我們可以從第 n-1 階爬 1 階，或從第 n-2 階爬 2 階。
- 基本操作：每次可以爬 1 階或 2 階。
- 邊界條件：當 n = 1 時，只有 1 種方法；當 n = 2 時，有 2 種方法。
- 問題可以分解為：計算到達前面階梯的方法數，然後組合出到達當前階梯的方法數。

### 視覺表示
```
第 0 階 (起點)
  |
 / \
1階  2階
 |    |
第1階 第2階
 | \   |
1階 2階 1階
 |   |   |
第2階 第3階 第3階
```
- 這個視覺化幫助我們看到，到達某一階的方法數量是到達前一階和前兩階方法數的總和。
- 從這個模型中，我們可以發現斐波那契數列的模式。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見的演算法模式：
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動視窗
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [x] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖形演算法
    - [ ] 樹狀問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別基礎：
    - 問題具有重疊子問題特性：計算到達第 n 階的方法數時，需要用到到達第 n-1 階和第 n-2 階的方法數。
    - 問題具有最優子結構：到達第 n 階的最佳解可以由到達第 n-1 階和第 n-2 階的最佳解組成。
    - 類似於斐波那契數列的計算。

### 知識連結
- 此問題涉及的基本計算機科學概念：組合數學、遞迴關係、動態規劃。
- 這個問題與斐波那契數列有直接關係：到達第 n 階的方法數等於到達第 n-1 階的方法數加上到達第 n-2 階的方法數。
- 需要應用的理論知識：遞迴關係、動態規劃的記憶化和自底向上方法。

### 相似問題比較
- 類似的 LeetCode 問題：
    - 斐波那契數列（LeetCode 509）：使用相同的遞迴關係。
    - 強盜問題（LeetCode 198）：需要考慮相鄰元素的選擇。
    - 最小花費爬樓梯（LeetCode 746）：考慮成本因素的變體。
- 相似性：都可以用動態規劃解決，具有重疊子問題。
- 差異性：本問題只關注方法數量，不涉及成本或其他限制。

## 4. 演算法直覺發展

### 直覺建立
- 真實世界類比：想像你在爬樓梯，每一步可以選擇爬 1 階或 2 階，你需要計算從底部到頂部的所有可能路徑。
- 初步直覺：這個問題可以用遞迴解決，但會有效能問題。計算到達第 n 階的方法數，我們只需要知道到達第 n-1 階和第 n-2 階的方法數。
- 驗證直覺：透過手動計算小型實例（如 n = 4, 5）來確認模式。

### 多重視角
- 不同的解題角度：
    - 自頂向下 vs. 自底向上：可以從頂部向下思考（遞迴+記憶化），也可以從底部向上思考（迭代）。
    - 迭代 vs. 遞迴實現：遞迴需要額外的調用堆疊空間，迭代可能更有效率。
    - 狀態型 vs. 轉換型視角：可以將問題視為狀態轉移問題，狀態 f(n) 依賴於 f(n-1) 和 f(n-2)。
- 最有希望的視角：自底向上的迭代方法最適合這種模式，因為它效率高且容易實現。

## 5. 解決方案開發歷程

### 方法 1：暴力遞迴解法

#### 思考過程
- 最直接的方法是使用遞迴：對於每一步，我們可以選擇爬 1 階或 2 階，然後遞迴計算剩餘階梯的方法數。
- 開始使用這種方法是因為它直接映射到問題的自然理解。
- 這種解法對於小的輸入值有效，但對於較大的輸入值會導致大量重複計算。

#### 演算法設計
```
function climbStairs(n):
    如果 n <= 0, 返回 0
    如果 n = 1, 返回 1
    如果 n = 2, 返回 2
    否則, 返回 climbStairs(n-1) + climbStairs(n-2)
```

#### 實作細節
- 使用的 Go 特定資料結構：沒有特殊的資料結構，僅使用基本整數類型。
- 潛在的實作陷阱：在 Go 中，遞迴深度過大可能導致堆疊溢出。對於 n 較大的情況（如接近限制條件的 45），這將成為問題。
- 在 Go 中需要特別注意 n 的邊界情況。

#### 複雜度分析
- **時間複雜度**：O(2^n) — 每次遞迴調用分裂為兩個子問題，形成二叉樹結構，深度為 n，因此時間複雜度為 O(2^n)。
- **空間複雜度**：O(n) — 遞迴調用堆疊的深度為 n。

#### 解法評估
- 優點：直觀易懂，直接對應問題描述。
- 缺點：效能極差，存在大量重複計算。n=45 時將導致無法接受的運行時間。
- 面試情境中的可接受性：只作為初始解法提出，必須立即指出其局限性並提出優化方案。

### 方法 2：記憶化遞迴解法

#### 關鍵洞見
- 暴力遞迴中存在大量重複計算。例如，計算 f(5) 需要計算 f(4) 和 f(3)，而計算 f(4) 又需要計算 f(3) 和 f(2)，f(3) 被重複計算。
- 可以使用記憶化技術（備忘錄）來儲存已計算的結果，避免重複計算。
- 使用哈希表或陣列來快速查找先前計算的值。

#### 最佳化策略
```
創建一個 memo 陣列來儲存已計算的結果
function climbStairs(n, memo):
    如果 n <= 0, 返回 0
    如果 n = 1, 返回 1
    如果 n = 2, 返回 2
    如果 memo[n] 已存在, 返回 memo[n]
    memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo)
    返回 memo[n]
```

#### 實作改進
- 利用 Go 的切片（slice）作為記憶化陣列。
- 通過檢查 memo[n] 是否為 0 來判斷該值是否已計算。
- 相較於暴力解法，我們不再重複計算相同的子問題，大幅提高效能。

#### 複雜度分析
- **時間複雜度**：O(n) — 每個子問題只計算一次，共有 n 個子問題。
- **空間複雜度**：O(n) — 需要一個大小為 n+1 的陣列來儲存計算結果，以及 O(n) 的遞迴堆疊空間。

#### 解法評估
- 效能大幅提升，可以處理 n 較大的情況。
- 這種方法保留了遞迴的直觀性，同時解決了效能問題。
- 在面試中，這是一個合理的優化步驟，顯示了對動態規劃中記憶化技術的理解。

### 方法 3：動態規劃（自底向上）

#### 突破性思考
- 遞迴方法是自頂向下的方法，我們也可以採用自底向上的方法，從小問題開始解決，逐步建立大問題的解。
- 關鍵洞見：我們可以使用迭代而非遞迴，從 f(1) 和 f(2) 開始計算，逐步計算到 f(n)。
- 這種方法避免了遞迴調用的開銷，並進一步優化空間使用。

#### 最佳演算法
```
創建一個 dp 陣列，dp[i] 表示爬到第 i 階的方法數
dp[1] = 1, dp[2] = 2
對於 i 從 3 到 n:
    dp[i] = dp[i-1] + dp[i-2]
返回 dp[n]
```

#### 實作卓越性
- 這個 Go 實作達到了最佳效能，沒有遞迴調用的開銷。
- 使用了 Go 的切片進行動態規劃陣列的建立和訪問。
- 程式碼簡潔明了，同時保持了高效能和可讀性。

#### 複雜度分析
- **時間複雜度**：O(n) — 只需要一個循環從 3 迭代到 n。
- **空間複雜度**：O(n) — 需要一個大小為 n+1 的 dp 陣列。

#### 思考演化（從暴力到最佳解）
- 思考方式的進步：從直接映射問題（遞迴）到識別並消除重複計算（記憶化），再到自底向上構建解（動態規劃）。
- 每個最佳化階段解決的具體問題：
    1. 暴力解法：直接對應問題，但效能差。
    2. 記憶化解法：解決重複計算問題，提高效能。
    3. 動態規劃解法：消除遞迴調用開銷，進一步提高效能和減少空間使用。
- 這種思考模式可以應用到其他具有重疊子問題特性的問題上。

### 方法 4：空間最佳化的動態規劃

#### 進一步最佳化
- 觀察到 dp[i] 只依賴於 dp[i-1] 和 dp[i-2]，因此不需要儲存整個 dp 陣列。
- 我們可以只使用兩個變數來追蹤前兩個狀態，將空間複雜度降低到 O(1)。

#### 複雜度分析
- **時間複雜度**：O(n) — 與方法 3 相同。
- **空間複雜度**：O(1) — 只使用了常數額外空間。

## 6. 範例推導與 Go 實作

### 完整範例追蹤
以輸入 n = 5 追蹤我們的最佳解法（空間最佳化的動態規劃）：

1. 初始狀態：
    - 輸入：`n = 5`
    - 變數 `prev` = 1 (f(1))
    - 變數 `curr` = 2 (f(2))

2. 第一次迭代 (i = 3)：
    - 操作：計算 f(3) = f(2) + f(1)
    - `next` = prev + curr = 1 + 2 = 3
    - `prev` = curr = 2
    - `curr` = next = 3

3. 第二次迭代 (i = 4)：
    - 操作：計算 f(4) = f(3) + f(2)
    - `next` = prev + curr = 2 + 3 = 5
    - `prev` = curr = 3
    - `curr` = next = 5

4. 第三次迭代 (i = 5)：
    - 操作：計算 f(5) = f(4) + f(3)
    - `next` = prev + curr = 3 + 5 = 8
    - `prev` = curr = 5
    - `curr` = next = 8

5. 最終狀態：
    - 輸出：`8`，表示有 8 種不同的方法可以爬到 5 階樓梯的頂部。

### 所有方法的效能比較
```
| 方法           | 時間複雜度 | 空間複雜度 | 範例執行時間（n=45） |
|--------------|----------|----------|-----------------|
| 暴力遞迴       | O(2^n)   | O(n)     | 超時             |
| 記憶化遞迴     | O(n)     | O(n)     | ~0.01 ms        |
| 動態規劃       | O(n)     | O(n)     | ~0.01 ms        |
| 空間最佳化 DP  | O(n)     | O(1)     | ~0.01 ms        |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我們的解法遵循了 Go 的最佳實踐，使用簡潔的變數名稱和明確的函數結構。
- 使用了 Go 的切片來實現動態陣列，並在最佳解中使用基本變數來優化空間。
- 程式碼結構清晰，易於理解和維護。

### 錯誤處理與邊界情況
- 我們處理了 n <= 0、n = 1 和 n = 2 的特殊情況。
- 根據限制條件，n 最大為 45，我們的解法在此範圍內能有效處理。
- 解法對所有有效輸入都是穩健的。

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初始解法提案：~3 分鐘（暴力遞迴）
- 最佳化討論：~5 分鐘（從記憶化到動態規劃再到空間最佳化）
- 程式碼撰寫：~10 分鐘（專注於最佳解）
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 解釋我的 Go 實作：
    - "這是一個經典的動態規劃問題，類似於斐波那契數列。關鍵洞見是我們可以用 f(n) = f(n-1) + f(n-2) 的遞迴關係來解決它。"
    - "我首先想到的是暴力遞迴解法，但它會導致許多重複計算，時間複雜度為 O(2^n)。"
    - "接著，我使用記憶化技術來避免重複計算，將時間複雜度降到 O(n)。"
    - "最後，我實現了自底向上的動態規劃解法，不僅消除了遞迴調用的開銷，還透過只使用兩個變數來追蹤前兩個狀態，將空間複雜度優化到 O(1)。"

- 可能的提示和引導問題：
    - "你能解釋一下為什麼這個問題與斐波那契數列相關嗎？"
    - "如果我們允許爬 1、2 或 3 階，你的解法會如何變化？"
    - "這個解法的空間複雜度能否進一步優化？"

### 潛在的後續問題
- 如果輸入規模大幅增加，例如 n > 10^6，你會如何修改你的 Go 程式碼？
    - 回答：對於非常大的 n，我們可能會遇到整數溢出的問題。我們可以使用 Go 的 big.Int 套件來處理大整數，或者在實際計算中對結果取模（例如，取模 10^9+7，這是競賽編程中常見的做法）。

- 如果我們允許爬 1 到 k 階（而不僅僅是 1 或 2 階），你的解法會如何改變？
    - 回答：我們需要修改遞迴關係為 f(n) = f(n-1) + f(n-2) + ... + f(n-k)，即考慮從前 k 個階梯到達當前階梯的所有可能方法。在實作上，我們需要一個迴圈來加總前 k 個狀態。

- 如果樓梯有某些階梯不能踩（有障礙物），如何修改你的解法？
    - 回答：我們需要修改狀態轉移邏輯，如果第 i 階有障礙物，則 dp[i] = 0（表示無法到達）；否則，dp[i] = dp[i-1] + dp[i-2]。

## 9. 知識整合與學習

### 解題洞見
- 這個問題教會了我動態規劃的核心概念：識別重疊子問題和最優子結構。
- 我更深入地理解了自頂向下（記憶化遞迴）和自底向上（迭代 DP）的方法差異。
- 我需要進一步加強的領域：更複雜的動態規劃問題，如二維 DP、狀態壓縮等。

### 心智模型建構
- 從這個問題中，我可以抽象出一個通用的問題解決框架：
    1. 識別問題的遞迴結構
    2. 嘗試暴力遞迴解法
    3. 應用記憶化消除重複計算
    4. 轉換為自底向上的動態規劃
    5. 最佳化空間使用
- 這個框架可以應用於許多動態規劃問題。

### 錯誤模式識別
- 在實作過程中容易出現的錯誤：
    - 基本情況處理不當（例如忘記處理 n <= 0 的情況）
    - 記憶化陣列索引錯誤
    - 迭代順序錯誤
- 這些錯誤反映了在動態規劃問題中需要特別注意的細節。

### 知識圖譜擴展
- 相關的 Go 編程資源：
    - "Go 語言高效編程" - 學習 Go 中高效的記憶體管理
    - "Go 語言實戰" - 深入了解 Go 的最佳實踐
- 此實作在我的 Go 知識體系中的位置：基礎算法實作，特別是在動態規劃和記憶體優化方面