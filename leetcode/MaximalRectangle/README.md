# LeetCode 85：最大矩形 (Maximal Rectangle)

## 1. 問題定義

### 原始問題 (英文)
```
Given an m x n binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

Example 1:
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6
Explanation: The maximal rectangle is shown in the above image.

Example 2:
Input: matrix = []
Output: 0

Example 3:
Input: matrix = [["0"]]
Output: 0

Example 4:
Input: matrix = [["1"]]
Output: 1

Example 5:
Input: matrix = [["0","0"]]
Output: 0

Constraints:
- rows == matrix.length
- cols == matrix[i].length
- 0 <= rows, cols <= 200
- matrix[i][j] is '0' or '1'
```

### 問題翻譯 (繁體中文)
```
給定一個由 0 和 1 組成的 m x n 二進制矩陣，找出僅包含 1 的最大矩形，並返回其面積。

範例 1：
輸入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
輸出：6
說明：最大矩形如上圖所示。

範例 2：
輸入：matrix = []
輸出：0

範例 3：
輸入：matrix = [["0"]]
輸出：0

範例 4：
輸入：matrix = [["1"]]
輸出：1

範例 5：
輸入：matrix = [["0","0"]]
輸出：0

約束條件：
- rows == matrix.length
- cols == matrix[i].length
- 0 <= rows, cols <= 200
- matrix[i][j] 為 '0' 或 '1'
```

### 範例與約束條件
- **範例 1：**
  ```
  輸入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
  輸出：6
  說明：最大矩形面積為 6 (2×3 的矩形)
  ```
- **範例 2：**
  ```
  輸入：matrix = []
  輸出：0
  ```

- **約束條件：**
    - 行數 == matrix.length
    - 列數 == matrix[i].length
    - 0 <= 行數, 列數 <= 200
    - matrix[i][j] 為 '0' 或 '1'

## 2. 問題理解

### 初始反應與心智模型
- 第一眼看到這個問題時，我想到的是如何識別矩陣中的矩形區域並計算其面積。
- 可以將範例視為一個建築物的藍圖，我們需要找出最大的連續區域。
- 輸入是一個二維矩陣，輸出是一個整數（最大矩形的面積）。
- 可以將問題視覺化為一組堆疊的直方圖，其中每一列都建立在前一列的基礎上。

### 問題分解
- 核心子問題：找出全部由 '1' 組成的最大矩形區域。
- 必要操作：識別連續的 '1'，計算可能的矩形面積。
- 需要處理的假設和邊緣情況：空矩陣、只有一個元素的矩陣、全部為 '0' 或全部為 '1' 的矩陣。
- 可以將這個問題分解為：計算每一行的高度直方圖，然後找出直方圖中的最大矩形面積。

### 視覺表示
```
對於輸入：
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]

可以將其轉換為高度直方圖：
第 1 行：[1,0,1,0,0]
第 2 行：[2,0,2,1,1]
第 3 行：[3,1,3,2,2]
第 4 行：[4,0,0,3,0]

然後在每一行的直方圖中找出最大矩形面積。
```
- 這種視覺化幫助我們將二維問題轉換為一系列的一維問題。
- 從視覺模型中可以發現，我們可以利用已有的「直方圖中最大矩形」解法來解決每一行的子問題。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [x] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [x] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據：
    - 問題涉及在二維矩陣中尋找特定模式，這是陣列操作的典型特徵。
    - 可以利用動態規劃來追蹤每個位置的高度和可能的矩形面積。
    - 使用堆疊可以高效解決直方圖中最大矩形的子問題。

### 知識連接
- 這個問題涉及的基本 CS 概念包括：矩陣操作、動態規劃、單調堆疊。
- 這個問題與直方圖中最大矩形問題 (LeetCode 84) 直接相關。
- 需要應用的理論知識包括：高度累積、使用堆疊查找矩形的左右邊界。

### 類似問題比較
- 類似的 LeetCode 問題：
    - LeetCode 84 (柱狀圖中最大的矩形)：是本問題的子問題。
    - LeetCode 221 (最大正方形)：尋找全為 '1' 的最大正方形而非矩形。
    - LeetCode 1277 (統計全為 1 的正方形子矩陣)：計算全部的正方形子矩陣而非找最大面積。
- 本題與 LC 84 最相似，但將一維直方圖問題擴展到二維矩陣。

## 4. 演算法直覺發展

### 直覺建立
- 直觀上，我們可以將二維矩陣問題轉換為多個一維的直方圖問題。
- 每一行都可以視為構建在前面幾行基礎上的直方圖，如果當前位置是 '1'，則高度加 1，否則高度重置為 0。
- 對每一行的高度直方圖，使用單調堆疊方法找出最大矩形面積。

### 多角度思考
- 自上而下 vs. 自下而上：可以使用動態規劃自下而上構建解決方案。
- 迭代 vs. 遞迴：這個問題更適合迭代解法，遞迴可能導致堆疊溢出。
- 狀態基礎 vs. 轉換基礎：我們使用基於狀態的視角，追蹤每個位置的高度。

## 5. 解決方案開發歷程

### 方法 1：暴力解法

#### 思考過程
- 最直接的方法是檢查矩陣中的每個可能的矩形。
- 我選擇這種方法作為起點，因為它清晰地展示了問題的挑戰。
- 這種解法會檢查所有可能的左上和右下角坐標組合，確保該矩形只包含 '1'。

#### 演算法設計
```
1. 對於每一對可能的左上角 (r1, c1) 和右下角 (r2, c2)：
   a. 檢查 (r1, c1) 到 (r2, c2) 範圍內的所有單元格是否都是 '1'
   b. 如果是，計算面積 (r2-r1+1) * (c2-c1+1)，並更新最大面積
2. 返回最大面積
```

#### 實現細節
- 使用了 Go 的二維切片來表示矩陣。
- 使用嵌套循環來檢查所有可能的矩形。
- 需要注意的是，Go 中字是使用單引號，而字節是使用雙引號，對應於題目中的 '0' 和 '1'。

#### 複雜度分析
- **時間複雜度**：O(m³n³)，其中 m 是行數，n 是列數。我們有四層循環遍歷所有可能的矩形，外加兩層循環檢查矩形內的所有單元格。
- **空間複雜度**：O(1)，只使用了常數額外空間。

#### 解決方案評估
- 優點：直觀且易於理解。
- 缺點：極其低效，在大型矩陣上會超時。
- 在面試環境中，這不是一個可接受的解決方案，但可以作為思考的起點。

### 方法 2：優化解法 - 使用高度直方圖

#### 關鍵洞察
- 暴力解法中，我們重複檢查了許多相同的單元格。
- 我們可以預先計算每個位置的高度（連續的 '1' 的數量）。
- 利用這些高度，我們可以將問題轉化為在每一行中尋找最大矩形。

#### 優化策略
```
1. 對於每一行，計算每個位置的高度（向上連續的 '1' 的數量）
2. 對於每一行的高度直方圖，找出最大矩形面積
3. 返回所有行中的最大值
```


#### 實現改進
- 利用了預計算的高度直方圖來避免重複計算。
- 使用了單調堆疊來高效地找出每個柱子的左右邊界。
- 將 LeetCode 84 的解法整合到我們的解決方案中。

#### 複雜度分析
- **時間複雜度**：O(m*n)，其中 m 是行數，n 是列數。對於每一行，我們需要 O(n) 時間更新高度和計算最大矩形面積。
- **空間複雜度**：O(n)，用於存儲高度陣列和堆疊。

#### 解決方案評估
- 優點：大大提高了效率，從 O(m³n³) 降至 O(m*n)。
- 缺點：需要理解單調堆疊的概念，實現較為複雜。
- 在面試環境中，這是一個很好的解決方案，體現了問題拆解和演算法應用的能力。

### 方法 3：最佳解法 - 動態規劃優化

#### 突破性思考
- 我們可以進一步優化，在計算直方圖的最大矩形時使用動態規劃預計算每個位置的左右邊界。
- 關鍵洞察是：對於每個位置，我們只需知道它能向左和向右擴展多遠。
- 這樣可以避免使用堆疊，使解法更加直觀。

#### 最佳演算法
```
1. 對於每一行，計算每個位置的高度
2. 對於每個位置，計算它能向左和向右擴展的最遠距離（保持相同高度）
3. 計算每個位置的矩形面積（高度 * 寬度）
4. 返回最大面積
```

#### 實現卓越性
- 這個 Go 實現通過動態規劃預計算左右邊界，達到了最佳性能。
- 使用了輔助函數 max 和 min 增強程式碼可讀性。
- 通過重用數組避免了重複分配記憶體，提高了空間效率。

#### 複雜度分析
- **時間複雜度**：O(m*n)，與方法 2 相同，但常數因子更小，因為避免了堆疊操作。
- **空間複雜度**：O(n)，用於存儲高度、左邊界和右邊界數組。

#### 從暴力到最佳的思考演進
- 暴力解法：枚舉所有可能的矩形，非常低效。
- 優化解法：將問題轉化為直方圖中最大矩形問題，利用單調堆疊提高效率。
- 最佳解法：使用動態規劃預計算邊界，減少堆疊操作，同時保持線性時間複雜度。
- 這種思考模式可以應用於其他涉及二維矩陣和子結構的問題。

## 6. 以 Go 實現的範例演練

### 完整範例追踪
追踪使用我們的最佳解決方案處理範例輸入：

1. 初始狀態：
    - 輸入：
   ```
   [
     ["1","0","1","0","0"],
     ["1","0","1","1","1"],
     ["1","1","1","1","1"],
     ["1","0","0","1","0"]
   ]
   ```
    - heights = [0, 0, 0, 0, 0]
    - left = [0, 0, 0, 0, 0]
    - right = [5, 5, 5, 5, 5]

2. 處理第一行後：
    - matrix[0] = ["1","0","1","0","0"]
    - heights = [1, 0, 1, 0, 0]
    - left = [0, 0, 2, 0, 0]
    - right = [1, 5, 3, 5, 5]
    - 最大面積 = 1

3. 處理第二行後：
    - matrix[1] = ["1","0","1","1","1"]
    - heights = [2, 0, 2, 1, 1]
    - left = [0, 0, 2, 2, 2]
    - right = [1, 5, 3, 5, 5]
    - 最大面積 = 3

4. 處理第三行後：
    - matrix[2] = ["1","1","1","1","1"]
    - heights = [3, 1, 3, 2, 2]
    - left = [0, 0, 2, 2, 2]
    - right = [1, 5, 3, 5, 5]
    - 最大面積 = 6 (heights[2] = 3, right[2] - left[2] = 3 - 0 = 3, 面積 = 3 * 2 = 6)

5. 處理第四行後：
    - matrix[3] = ["1","0","0","1","0"]
    - heights = [4, 0, 0, 3, 0]
    - left = [0, 0, 0, 3, 0]
    - right = [1, 5, 5, 4, 5]
    - 最大面積仍然是 6

6. 最終狀態：
    - 輸出：6

### 所有方法的性能比較
```
| 方法              | 時間複雜度      | 空間複雜度 | 範例執行時間 |
|-------------------|----------------|------------|-------------|
| 暴力解法          | O(m³n³)        | O(1)       | >1000ms     |
| 優化解法（堆疊）   | O(m*n)         | O(n)       | ~10ms       |
| 最佳解法（動態規劃）| O(m*n)        | O(n)       | ~5ms        |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解決方案遵循了 Go 的最佳實踐：
    - 使用明確的變數命名
    - 適當的錯誤處理和邊界檢查
    - 編寫清晰的註釋說明程式碼意圖
    - 使用輔助函數增強程式碼可讀性

### 錯誤處理與邊緣情況
- 處理了空矩陣和空行的情況
- 正確處理了所有邊緣情況，如單個元素矩陣
- 確保所有陣列訪問都在界限內

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解決方案提議：~5 分鐘（暴力解法）
- 優化討論：~5-7 分鐘（直方圖方法和動態規劃）
- 程式碼編寫：~10-15 分鐘（動態規劃解法）
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 我會先解釋問題的本質：尋找二維矩陣中全為 '1' 的最大矩形。
- 然後提出將問題轉化為直方圖問題的策略，並解釋單調堆疊的作用。
- 最後，討論如何使用動態規劃進一步優化算法。
- 對可能的提示和引導問題：
    - 如果面試官問為何選擇動態規劃而非單調堆疊，我會解釋動態規劃在此問題中的優勢。
    - 如果被問到時間和空間複雜度，我會詳細分析每種方法的複雜度並比較。

### 潛在後續問題
- 如果輸入規模增加怎麼辦？我的解法仍然高效，時間複雜度為 O(m*n)。
- 如果記憶體受限，可以優化空間使用，例如重用陣列。
- 這個解決方案可以擴展到處理更多相關問題，如找最大正方形或處理稀疏矩陣。

## 9. 知識整合與學習

### 解題洞察
- 這個問題教導了我如何將複雜的二維問題分解為一維子問題。
- 學到的 Go 實現技巧：有效地使用切片、預先分配記憶體，以及利用輔助函數提高可讀性。
- 需要進一步加強的 Go 知識領域：Go 的記憶體優化和併發處理。

### 心智模型構建
- 從這個問題中抽象出的一般解題框架：
    1. 將複雜問題分解為更簡單的子問題
    2. 識別並利用子問題之間的關聯
    3. 使用適當的資料結構優化解決方案
- 這個框架可以應用於其他涉及二維矩陣、動態規劃和單調堆疊的問題。

### 錯誤模式識別
- 在實現過程中的常見錯誤：初始化邊界值不正確、索引錯誤，以及處理更新左右邊界的邏輯不當。
- 這些錯誤揭示了我在處理陣列和矩陣時需要更加謹慎。
- 增強邊界情況檢查和變數初始化可以預防類似錯誤。

### 知識圖譜擴展
- 相關 Go 程式設計資源：
    - 《Effective Go》
    - 《Go 語言實戰》
    - Go 的標準庫文檔
- 進階 Go 模式：記憶體管理、錯誤處理，以及性能優化
- 這個實現與我對動態規劃和單調堆疊的整體理解相符合