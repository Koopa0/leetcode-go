# LeetCode 63: Unique Paths II 不同路徑 II

## 1. 問題定義

### 原始問題 (英文)
```
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and space is marked as 1 and 0 respectively in the grid.
```

### 問題翻譯 (繁體中文)
```
一個機器人位於 m x n 網格的左上角（在下面的圖表中標記為「起點」）。

機器人在任一時刻只能向下或向右移動。機器人試圖到達網格的右下角（在下面的圖表中標記為「終點」）。

現在考慮如果在網格中添加了一些障礙物，有多少種不同的路徑？

障礙物和空位分別在網格中被標記為 1 和 0。
```

### 範例與限制條件
- **範例 1:**
  ```
  Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
  Output: 2
  Explanation: 有兩種方法可以到達右下角。
  1. 向右 -> 向右 -> 向下 -> 向下
  2. 向下 -> 向下 -> 向右 -> 向右
  ```
- **範例 2:**
  ```
  Input: obstacleGrid = [[0,1],[0,0]]
  Output: 1
  Explanation: 機器人只能按照下列路徑走：向下 -> 向右
  ```

- **限制條件:**
    - m == obstacleGrid.length
    - n == obstacleGrid[i].length
    - 1 <= m, n <= 100
    - obstacleGrid[i][j] 是 0 或 1

## 2. 問題理解

### 初始反應與心智建模
- 這是一個經典的路徑規劃問題，但加入了障礙物的考量。
- 第一印象是這可以使用動態規劃（Dynamic Programming）來解決。
- 若沒有障礙物，從起點到終點的路徑數量是有明確計算方式的，但有障礙物時需要特別處理。
- 機器人每次只能向下或向右移動，這限制了可能的移動方向。

### 問題分解
- 核心子問題：到達每個格子的路徑數量是多少？
- 我們需要考慮的邊界條件：起點是否有障礙物？如果起點就有障礙物，則無法到達終點。
- 需要處理的主要情況：當前格子是否為障礙物？如果是，則到達這個格子的路徑數為 0。

### 視覺呈現
```
起點 (0,0) -> ... -> ... -> 終點 (m-1,n-1)
如果格子 (i,j) 不是障礙物，則到達該格子的路徑數 = 到達 (i-1,j) 的路徑數 + 到達 (i,j-1) 的路徑數
如果格子 (i,j) 是障礙物，則到達該格子的路徑數 = 0
```

## 3. 模式識別與知識映射

### 演算法模式分類
- 此問題屬於以下常見演算法模式：
    - [x] 動態規劃 (DP)

- 識別基礎：
    - 問題要求計算路徑總數，而不是找出具體路徑
    - 存在重疊子問題：到達每個格子的路徑數可以由其上方和左方格子的路徑數推導
    - 具有最優子結構：最終解可以由子問題的解構建出來

### 知識連結
- 涉及的基礎電腦科學概念：動態規劃、二維陣列遍歷、路徑計算
- 與其他題目相關：此問題是「不同路徑 I」(Unique Paths I) 的擴展版本，增加了障礙物的考量

### 相似問題比較
- LeetCode 62: Unique Paths - 無障礙物版本
- LeetCode 64: Minimum Path Sum - 尋找最小路徑和而非路徑數量
- LeetCode 980: Unique Paths III - 需要訪問所有空格子的變種

## 4. 演算法直覺發展

### 直覺建立
- 如果沒有障礙物，從起點到終點的路徑數量就是組合數學中的組合數 C(m+n-2, m-1) 或 C(m+n-2, n-1)
- 有障礙物時，我們需要針對每個格子計算到達它的路徑數量，並考慮障礙物的影響
- 動態規劃適合逐步建立解決方案，因為每個格子的答案依賴於之前已計算的格子

### 多種觀點
- 自上而下與自下而上：我們可以使用自上而下（記憶化遞迴）或自下而上（迭代）的 DP 方法
- 我們也可以考慮使用 BFS 或 DFS 來窮舉所有可能路徑，但對於大型網格可能效率較低
- 對於這類問題，迭代式的動態規劃通常是最高效的解法

## 5. 解決方案開發過程

### 方法 1: 暴力解法 (遞迴)

#### 思考過程
- 最直接的想法是使用遞迴枚舉所有可能的路徑
- 從起點開始，每次可選擇向右或向下移動
- 如果遇到障礙物或越界，則該路徑不可行
- 當到達終點時，路徑數加 1

#### 演算法設計
```
從 (0,0) 開始，遞迴嘗試所有可能的路徑：
1. 如果當前位置是障礙物或越界，返回 0
2. 如果到達終點，返回 1
3. 否則，返回「向下移動的路徑數」+「向右移動的路徑數」
```

#### 實作細節
- 使用了記憶化遞迴 (memoization) 來避免重複計算
- 使用二維陣列 `memo` 來存儲已計算的子問題結果
- Go 中的閉包函數 (closure) 讓我們可以在 `dfs` 中訪問外部變數

#### 複雜度分析
- **時間複雜度**: O(m * n) — 每個格子只會被計算一次，共有 m * n 個格子
- **空間複雜度**: O(m * n) — 記憶化陣列和遞迴調用棧的空間

#### 解法評估
- 優點：容易理解和實作，使用記憶化避免了指數級的時間複雜度
- 缺點：遞迴調用在大型網格上可能導致棧溢出
- 在面試中可接受，但不是最優解

### 方法 2: 優化解法 (自下而上的動態規劃)

#### 關鍵見解
- 暴力解法中的遞迴調用可能導致效率問題
- 我們可以使用自下而上的動態規劃方法消除遞迴
- 利用二維 DP 表格儲存中間結果，從左上到右下逐步構建解答

#### 優化策略
```
創建一個 dp 陣列，其中 dp[i][j] 表示從起點到位置 (i,j) 的路徑數：
1. 初始化：如果起點是障礙物，則 dp[0][0] = 0，否則 dp[0][0] = 1
2. 對於第一行和第一列的特殊處理
3. 對於其他格子 (i,j)：
   - 如果是障礙物，則 dp[i][j] = 0
   - 否則，dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

#### 實作改進
- 消除了遞迴調用，改用迭代方式填充 DP 表格
- 特別處理了第一行和第一列的邊界情況
- 程式碼結構清晰，易於理解和維護

#### 複雜度分析
- **時間複雜度**: O(m * n) — 需要填充整個 DP 表格
- **空間複雜度**: O(m * n) — 需要儲存整個 DP 表格

#### 解法評估
- 優點：消除了遞迴調用，更加穩定和高效
- 缺點：仍然需要 O(m * n) 的空間
- 在面試中表現良好，但空間複雜度還可以進一步優化

### 方法 3: 最佳解法 (空間優化的動態規劃)

#### 突破性思考
- 觀察到每個格子的值只依賴於其左方和上方的格子
- 因此我們可以只保留一行的 DP 值，而不需要整個二維表格
- 遍歷每一行時，逐步更新這一行的值

#### 最佳演算法
```
使用一維 dp 陣列，其中 dp[j] 表示到達當前行第 j 列的路徑數：
1. 初始化 dp[0] = 1 (如果起點不是障礙物)
2. 對於每一行 i：
   a. 如果 obstacleGrid[i][0] == 1，則 dp[0] = 0
   b. 對於該行中的每個位置 j > 0：
      - 如果 obstacleGrid[i][j] == 1，則 dp[j] = 0
      - 否則，dp[j] = dp[j] (上方的值) + dp[j-1] (左方的值)
```

#### 實作卓越性
- 將空間複雜度從 O(m * n) 降低到 O(n)，僅使用一個長度為 n 的陣列
- 巧妙地更新 dp 陣列，使其同時包含「上方的值」和「新計算的值」
- 程式碼簡潔而高效，適合在面試中展示

#### 複雜度分析
- **時間複雜度**: O(m * n) — 仍需遍歷整個網格
- **空間複雜度**: O(n) — 只需要一個長度為 n 的陣列

#### 從暴力到最佳的思維演進
- 暴力解法：使用遞迴窮舉所有路徑，加上記憶化避免重複計算
- 優化解法：消除遞迴調用，使用二維 DP 表格自下而上地構建解答
- 最佳解法：觀察到每個格子只依賴於其左方和上方的值，將空間複雜度從 O(m * n) 降低到 O(n)

## 6. 範例演示與 Go 實現

### 完整範例追蹤
追蹤範例輸入 `[[0,0,0],[0,1,0],[0,0,0]]` 的解題過程：

使用最佳解法：

1. 初始狀態：
    - 輸入：`[[0,0,0],[0,1,0],[0,0,0]]`，m = 3, n = 3
    - dp = [0, 0, 0]

2. 初始化起點：
    - obstacleGrid[0][0] = 0 (不是障礙物)
    - dp = [1, 0, 0]

3. 填充第一行 (i = 0)：
    - j = 1: obstacleGrid[0][1] = 0，dp[1] = dp[0] = 1
    - j = 2: obstacleGrid[0][2] = 0，dp[2] = dp[1] = 1
    - 此時 dp = [1, 1, 1]

4. 處理第二行 (i = 1)：
    - 更新 dp[0]：仍為 1 (因為 obstacleGrid[1][0] = 0)
    - j = 1: obstacleGrid[1][1] = 1 (是障礙物)，dp[1] = 0
    - j = 2: obstacleGrid[1][2] = 0，dp[2] = dp[2] + dp[1] = 1 + 0 = 1
    - 此時 dp = [1, 0, 1]

5. 處理第三行 (i = 2)：
    - 更新 dp[0]：仍為 1 (因為 obstacleGrid[2][0] = 0)
    - j = 1: obstacleGrid[2][1] = 0，dp[1] = dp[1] + dp[0] = 0 + 1 = 1
    - j = 2: obstacleGrid[2][2] = 0，dp[2] = dp[2] + dp[1] = 1 + 1 = 2
    - 此時 dp = [1, 1, 2]

6. 最終狀態：
    - 輸出：dp[n-1] = dp[2] = 2

### 所有方法的性能比較
```
| 方法             | 時間複雜度   | 空間複雜度   | 範例執行時間   |
|-----------------|------------|------------|--------------|
| 暴力解法 (遞迴)    | O(m * n)   | O(m * n)   | 較慢          |
| 優化解法 (二維 DP) | O(m * n)   | O(m * n)   | 中等          |
| 最佳解法 (一維 DP) | O(m * n)   | O(n)       | 最快          |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我們的最佳解法遵循了 Go 的簡潔風格和效能優先的原則
- 使用切片 (slice) 而非固定大小的陣列，更符合 Go 的動態性
- 變數命名清晰簡潔，符合 Go 的命名約定

### 錯誤處理與邊界情況
- 特別處理了起點是障礙物的情況
- 正確處理了第一行和第一列的邊界情況
- 解法對於任何符合約束的輸入都能正確運作

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初始解法提案：~3 分鐘
- 最佳化討論：~5 分鐘
- 程式碼撰寫：~10 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實作？
    - 首先說明問題是一個動態規劃問題，可以從暴力解法逐步優化
    - 解釋空間優化的思路：利用一維陣列代替二維表格
    - 強調解法的時間和空間複雜度

- 可能的提示和引導問題：
    - 面試官可能會問：「你能進一步優化空間複雜度嗎？」
    - 回應：解釋一維 DP 的原理，以及為何這已是最優解
    - 面試官可能會問：「如果網格非常大，有其他方法嗎？」
    - 回應：討論數學公式解法和對大型輸入的處理

### 可能的後續問題
- 如果輸入規模增大，如何修改你的 Go 程式碼以確保效能？
- 如果記憶體受限，你會如何調整你的 Go 解法？
- 如何擴展你的解法以處理機器人可以向更多方向移動的情況？

## 9. 知識整合與學習

### 解題洞見
- 從這個問題中學到了空間優化的動態規劃技巧
- 加深了對路徑計數問題的理解
- 更好地掌握了 Go 中處理二維和一維陣列的方式

### 心智模型構建
- 這類路徑問題通常可以從暴力枚舉開始，然後逐步優化到動態規劃
- 當 DP 狀態只依賴於有限的前置狀態時，可以考慮使用滾動數組優化空間
- 二維 DP 問題經常可以壓縮為一維 DP，這是一種常見的優化技巧

### 錯誤模式識別
- 初學者常犯的錯誤是沒有正確處理障礙物的情況
- 另一個常見錯誤是沒有特別處理起點和終點是障礙物的邊界情況
- 在 Go 中錯誤使用切片可能導致索引越界錯誤

### 知識圖譜擴展
- 相關 Go 程式設計資源：《Effective Go》、《Go 程式設計語言》
- 動態規劃進階模式：滾動數組優化、狀態壓縮
- 這類實作如何體現 Google 編碼風格：簡潔、高效、可讀性強