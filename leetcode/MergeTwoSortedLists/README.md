## 1. Original Problem:

**Merge Two Sorted Lists**

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

**繁體中文翻譯：**

**合併兩個有序鏈表**

給你兩個已排序的鏈表的頭節點 `list1` 和 `list2`。

將這兩個鏈表合併為一個已排序的鏈表。新鏈表應通過拼接前兩個鏈表的節點來創建。

返回合併後鏈表的頭節點。

**Examples:**

Example 1:
```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

Example 2:
```
Input: list1 = [], list2 = []
Output: []
```

Example 3:
```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**
- The number of nodes in both lists is in the range [0, 50].
- -100 <= Node.val <= 100
- Both list1 and list2 are sorted in non-decreasing order.

## 2. 問題理解：

這個問題要求我們合併兩個已排序的鏈表，使結果仍然是一個有序的鏈表。核心要求和約束如下：

- 輸入是兩個已按非遞減順序排序的鏈表
- 需要將兩個鏈表的節點合併成一個新的有序鏈表
- 合併後的鏈表也應該按非遞減順序排序
- 我們不需要創建新的節點，只需要重新連接原有的節點

邊界情況：
- 其中一個或兩個鏈表為空
- 鏈表長度不同
- 節點值相同的情況

關鍵挑戰：
- 保持鏈表的有序性
- 正確處理指針的操作，避免鏈表斷裂或循環
- 處理空鏈表的情況

## 3. 視覺解釋：

讓我們用一個例子來說明合併過程：

```
list1: 1 -> 2 -> 4 -> NULL
list2: 1 -> 3 -> 4 -> NULL
```

合併步驟：

1. 比較頭節點：`1` vs `1`（相等，選擇 list1 的 `1`）
```
結果：1 -> ?
list1: 2 -> 4 -> NULL
list2: 1 -> 3 -> 4 -> NULL
```

2. 比較：`2` vs `1`（選擇 list2 的 `1`）
```
結果：1 -> 1 -> ?
list1: 2 -> 4 -> NULL
list2: 3 -> 4 -> NULL
```

3. 比較：`2` vs `3`（選擇 list1 的 `2`）
```
結果：1 -> 1 -> 2 -> ?
list1: 4 -> NULL
list2: 3 -> 4 -> NULL
```

4. 比較：`4` vs `3`（選擇 list2 的 `3`）
```
結果：1 -> 1 -> 2 -> 3 -> ?
list1: 4 -> NULL
list2: 4 -> NULL
```

5. 比較：`4` vs `4`（相等，選擇 list1 的 `4`）
```
結果：1 -> 1 -> 2 -> 3 -> 4 -> ?
list1: NULL
list2: 4 -> NULL
```

6. list1 已經為空，將 list2 的剩餘部分接上
```
結果：1 -> 1 -> 2 -> 3 -> 4 -> 4 -> NULL
```

## 4. 思考過程：

對於合併兩個已排序的鏈表，我們可以考慮以下幾種方法：

1. **迭代法**：
    - 創建一個虛擬頭節點（dummy node）
    - 使用兩個指針分別遍歷兩個鏈表
    - 在每一步中，選擇值較小的節點接到結果鏈表上
    - 當其中一個鏈表遍歷完畢，將另一個鏈表的剩餘部分直接接上

2. **遞迴法**：
    - 比較兩個鏈表的頭節點
    - 選擇值較小的頭節點作為結果的頭節點
    - 遞迴地合併較小頭節點的下一個節點與另一個鏈表
    - 當其中一個鏈表為空時，直接返回另一個鏈表

3. **原地合併法**：
    - 直接在原鏈表上操作，不使用額外空間
    - 選擇一個非空鏈表作為基礎，將另一個鏈表的節點插入適當位置

對於這類問題，迭代法通常是最直觀且效率高的解法。遞迴法雖然代碼簡潔，但在鏈表很長時可能導致堆棧溢出。原地合併法需要更複雜的指針操作，容易出錯。

## 5. 最優解決方案開發：

讓我們採用迭代法來解決這個問題：

1. 創建一個虛擬頭節點（dummy node），用於簡化邊界情況處理
2. 維護一個指針 `current`，指向當前結果鏈表的末尾
3. 同時遍歷兩個鏈表，比較兩個鏈表當前節點的值
4. 將較小值的節點接到 `current` 的後面，並移動相應的指針
5. 當其中一個鏈表遍歷完畢，將另一個鏈表的剩餘部分直接接到結果鏈表後
6. 返回虛擬頭節點的下一個節點，即為合併後的鏈表頭

這個方法的優點是：
- 時間複雜度是 O(n + m)，其中 n 和 m 是兩個鏈表的長度
- 空間複雜度是 O(1)，只使用了常數額外空間
- 代碼邏輯清晰，易於理解和實現

## 7. 複雜度分析：

**時間複雜度**: O(n + m)
- 我們需要遍歷兩個鏈表的所有節點，其中 n 和 m 分別是兩個鏈表的長度
- 在每一步中，我們只進行一次比較和一次指針操作，這些操作的時間複雜度都是 O(1)
- 因此總時間複雜度為 O(n + m)

**空間複雜度**: O(1)
- 我們只使用了常數額外空間（一個虛擬頭節點和幾個指針）
- 合併操作是在原鏈表上進行的，不需要額外創建新的節點
- 因此空間複雜度為 O(1)


## 9. 測試策略：

這個測試策略包含了：
1. 基本功能測試（從範例中）
2. 邊界情況測試（空鏈表）
3. 長度不同的鏈表測試
4. 相同值測試
5. 負值測試
6. 值域範圍較大的測試

通過這些測試用例，我們可以全面驗證解決方案的正確性和魯棒性。