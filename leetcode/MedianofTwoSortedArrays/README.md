## 1. Original Problem

### English Version
Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

**Example 1:**
```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**
```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:**
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

### 繁體中文版本
給定兩個大小分別為 `m` 和 `n` 的排序數組 `nums1` 和 `nums2`，請返回這兩個排序數組的中位數。

總體運行時間複雜度應為 O(log (m+n))。

**示例 1：**
```
輸入：nums1 = [1,3], nums2 = [2]
輸出：2.00000
解釋：合併數組 = [1,2,3]，中位數為 2。
```

**示例 2：**
```
輸入：nums1 = [1,2], nums2 = [3,4]
輸出：2.50000
解釋：合併數組 = [1,2,3,4]，中位數為 (2 + 3) / 2 = 2.5。
```

**約束條件：**
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## 2. 問題理解

這個問題要求找出兩個已排序數組的中位數，且時間複雜度要求為 O(log(m+n))。讓分析一下：

- 兩個數組已經各自排序好了
- 需要找出合併後的中位數，而不需要真正合併兩個數組
- 中位數的定義：如果合併後的數組長度為奇數，則中位數是中間的元素；如果長度為偶數，則中位數是中間兩個元素的平均值
- 時間複雜度要求 O(log(m+n)) 暗示需要使用二分查找或類似的對數級別算法
- 數組可能為空（m 或 n 可能為 0）
- 數組元素可能是負數

關鍵挑戰：
1. 如何在不合併數組的情況下找到中位數
2. 如何達到 O(log(m+n)) 的時間複雜度
3. 如何處理奇數和偶數長度的情況

## 3. 視覺解釋

讓用視覺化來理解問題和解決方案。

假設有兩個排序數組：
```
nums1 = [1, 3, 5, 7]
nums2 = [2, 4, 6]
```

合併後的數組應該是：
```
merged = [1, 2, 3, 4, 5, 6, 7]
```

合併後的長度為 7（奇數），所以中位數是中間的元素：4。

的目標是在不實際合併數組的情況下找到這個值。

關鍵思路：可以將問題轉化為"尋找第 k 小的元素"，其中 k = (m+n+1)/2。

對於這個例子：k = (4+3+1)/2 = 4，所以需要找第 4 小的元素。

讓看一個算法執行的圖示：

```
步驟 1: 初始狀態
nums1 = [1, 3, 5, 7]
        ^
nums2 = [2, 4, 6]
        ^
尋找第 4 小的元素

步驟 2: 比較 nums1[2-1]=1 和 nums2[2-1]=2
1 < 2，所以排除 nums1 的前 2 個元素

nums1 = [1, 3, 5, 7]
           ^
nums2 = [2, 4, 6]
        ^
現在尋找第 2 小的元素

步驟 3: 比較 nums1[1-1]=3 和 nums2[1-1]=2
3 > 2，所以排除 nums2 的前 1 個元素

nums1 = [1, 3, 5, 7]
           ^
nums2 = [2, 4, 6]
           ^
現在尋找第 1 小的元素

步驟 4: 比較 nums1[1-1]=3 和 nums2[1-1]=4
3 < 4，所以第 1 小的元素是 3

所以中位數是 4。
```

## 4. 思考過程

針對此問題，可以考慮幾種方法：

### 方法 1：合併後找中位數
最直觀的方法是先合併兩個排序數組，然後直接找中位數。
- 時間複雜度：O(m+n)，用於合併兩個數組
- 空間複雜度：O(m+n)，用於存儲合併後的數組
- 這種方法簡單直觀，但不符合題目要求的 O(log(m+n)) 時間複雜度

### 方法 2：使用計數方法
可以不實際合併數組，而是使用兩個指針同時遍歷兩個數組，直到找到中位數位置。
- 時間複雜度：O(m+n)
- 空間複雜度：O(1)
- 也不符合題目要求的時間複雜度

### 方法 3：二分查找
考慮到題目要求 O(log(m+n)) 的時間複雜度，可以使用二分查找。
- 將問題轉化為"尋找第 k 小的元素"
- 每次比較兩個數組的第 k/2 個元素，排除較小部分
- 時間複雜度：O(log(m+n))
- 空間複雜度：O(1)
- 這符合題目要求，但實現較為複雜

我選擇方法 3，因為它符合題目的時間複雜度要求，且不需要額外空間。

## 5. 最優解決方案開發

讓詳細開發二分查找的解決方案。

核心思想：將"尋找中位數"轉化為"尋找第 k 小的元素"。如果合併後的數組長度為奇數，則中位數是第 (m+n+1)/2 小的元素；如果為偶數，則是第 (m+n)/2 和第 (m+n)/2+1 小的元素的平均值。

使用二分查找逐步排除較小的一半元素：

1. 首先，計算 k = (m+n+1)/2
2. 比較 nums1[k/2-1] 與 nums2[k/2-1]（如果索引有效）
3. 較小的那部分可以排除，因為確定它們不可能包含第 k 小的元素
4. 調整指針和 k 值，重複上述過程
5. 直到找到第 k 小的元素

讓用例子詳細說明：
```
nums1 = [1, 3, 5, 7]  (m=4)
nums2 = [2, 4, 6]     (n=3)
```

1. 總長度 m+n=7（奇數），中位數是第 (7+1)/2=4 小的元素
2. 比較 nums1[4/2-1]=nums1[1]=3 和 nums2[4/2-1]=nums2[1]=4
3. 3 < 4，所以 nums1 的前 4/2=2 個元素（1 和 3）可能包含第 4 小的元素，不能排除；反之，可以排除 nums1 的前 2 個元素
4. 數組變為 [5, 7] 和 [2, 4, 6]，現在尋找第 4-2=2 小的元素
5. 比較 nums1[2/2-1]=nums1[0]=5 和 nums2[2/2-1]=nums2[0]=2
6. 5 > 2，所以排除 nums2 的前 1 個元素
7. 數組變為 [5, 7] 和 [4, 6]，現在尋找第 2-1=1 小的元素
8. 比較 nums1[1/2-1]=nums1[0]=5 和 nums2[1/2-1]=nums2[0]=4
9. 5 > 4，所以第 1 小的元素是 nums2[0]=4
10. 因此，中位數是 4


## 7. 複雜度分析

### 時間複雜度

- 首先將較長數組放在 nums2 位置：O(1)
- 二分查找過程：在長度為 m 的數組上進行二分查找，每次將搜索空間減半
    - 總共需要 O(log m) 次迭代
- 在每次迭代中，進行常數時間的操作
- 因此，總時間複雜度為 O(log m)，其中 m <= n
- 由於 m <= n，所以 O(log m) <= O(log n)，而且 O(log m) <= O(log(m+n))
- 所以最終時間複雜度是 O(log(min(m, n)))，這滿足題目要求的 O(log(m+n))

### 空間複雜度

- 只使用了常數額外空間來存儲變量
- 沒有使用與輸入大小相關的額外數據結構
- 因此，空間複雜度為 O(1)

## 8. 優化與改進

的解決方案已經達到了時間複雜度 O(log(min(m, n)))，這是最優的。可能的一些改進和變體：

1. **異常處理**：增加對空數組的處理
2. **簡化邊界條件**：可以通過添加"虛擬元素"（無窮大或無窮小）來簡化邊界條件的處理
3. **遞迴實現**：也可以使用遞迴方式實現二分查找，可能在某些情況下更容易理解

## 9. 測試策略

這個測試套件包含了各種情況：
1. 來自問題描述的基本示例
2. 邊界情況：空數組
3. 長度差異大的數組
4. 包含重複元素的數組
5. 包含負數的數組
6. 極端情況：接近約束限制的大值

總結：這道題的關鍵在於將"尋找中位數"轉化為"尋找第 k 小的元素"的問題，然後使用二分查找的思想逐步縮小搜索範圍。這種方法不僅達到了 O(log(min(m,n))) 的時間複雜度，還只使用 O(1) 的額外空間，是一個非常優秀的解法。

理解這個問題的關鍵是掌握如何在兩個排序數組中高效地找到特定位置的元素，這也是類似問題（如第 k 小元素、排序數組的中間值等）的基礎。


## 尋找兩個排序數組的中位數 - 核心思想

### 問題的本質

想像你有兩堆已經排好序的卡片，每張卡片上有一個數字。你需要找出如果把這兩堆卡片合併後，中間位置的那張卡片是什麼。但是，你不能真的把卡片全部合併排序，因為那樣太慢了。

### 更直觀的思路

如果直接合併兩個數組，時間複雜度是 O(m+n)。題目要求 O(log(m+n))，這意味著需要更聰明的方法，通常這暗示著二分查找。

讓換個思路：**中位數其實就是第 (m+n)/2 小的元素**（或者是第 (m+n)/2 和第 (m+n)/2+1 小元素的平均值，如果總長度是偶數）。

### 方法解析：二分排除法

這個方法的核心是：**不斷縮小搜索範圍，排除一定不包含答案的部分**。

讓我用一個生活中的例子來解釋：

想像你和朋友各有一堆已排序的撲克牌（只看牌面數字，不考慮花色）。你想知道把兩堆牌合在一起後，中間的那張牌是什麼。

1. **確定目標位置**：假設總共有 7 張牌，要找第 4 小的牌。

2. **比較中間位置**：
  - 你從你的牌堆中取出第 2 張牌（假設是 3）
  - 朋友從他的牌堆中取出第 2 張牌（假設是 4）

3. **排除不可能的部分**：
  - 你的第 2 張牌是 3，比朋友的第 2 張牌 4 小
  - 這告訴什麼？**你牌堆的前 2 張牌肯定在合併後的前 4 張牌中**，但不可能是第 4 小的牌
  - 為什麼？因為即使朋友的所有牌都比你的第 2 張牌大，你的第 2 張牌最多也只能是第 3 小的

4. **縮小範圍**：
  - 可以安全地排除你牌堆的前 2 張牌
  - 現在要在剩下的牌中找第 4-2=2 小的牌

### 用具體例子詳細演示

讓用實例演示這個過程：
```
你的牌堆：[1, 3, 5, 7]
朋友的牌堆：[2, 4, 6]
```

1. **目標**：找出合併後第 4 小的元素（總共 7 張牌，中位數是第 4 小）

2. **第一輪比較**：
  - 比較你的第 2 張牌（值為 3）和朋友的第 2 張牌（值為 4）
  - 3 < 4，說明你的前 2 張牌（1 和 3）肯定不是第 4 小的元素
  - 圖示：[1, 3, |5, 7] 和 [2, 4, 6]（| 表示排除分界線）

3. **更新搜索**：
  - 現在牌堆變為：[5, 7] 和 [2, 4, 6]
  - 已經排除了 2 張牌，現在要找第 4-2=2 小的元素

4. **第二輪比較**：
  - 比較你的第 1 張牌（值為 5）和朋友的第 1 張牌（值為 2）
  - 5 > 2，說明朋友的第 1 張牌（2）肯定不是第 2 小的元素
  - 圖示：[5, 7] 和 [|2, 4, 6]（| 表示排除分界線）

5. **再次更新**：
  - 牌堆變為：[5, 7] 和 [4, 6]
  - 排除了 1 張牌，現在找第 2-1=1 小的元素

6. **最後一輪**：
  - 比較 5 和 4
  - 4 < 5，所以第 1 小的元素是 4
  - 因此，原始牌堆合併後的第 4 小元素（即中位數）是 4

### 為什麼這個方法有效？

每次比較時，可以確定性地排除一些元素：

- 如果 nums1[k/2-1] < nums2[k/2-1]，那麼 nums1 的前 k/2 個元素絕對不可能是第 k 小的元素
- 因為即使 nums2 中的前 k/2-1 個元素全部小於 nums1[k/2-1]，那麼 nums1[k/2-1] 最多只能是第 (k/2-1) + k/2 = k-1 小的元素

每次都能排除 k/2 個元素，這就是為什麼時間複雜度是 O(log(m+n))。

### 視覺化理解

想像有兩個排序數組：
```
nums1: [1, 3, 5, 7]
nums2: [2, 4, 6]
```

合併後會是：[1, 2, 3, 4, 5, 6, 7]

的目標是找出第 4 個元素，即 4。但不通過合併來找，而是使用二分排除法：

```
比較 nums1[1]=3 和 nums2[1]=4：
3 < 4，排除 nums1 的前 2 個元素

剩下：
nums1: [5, 7]
nums2: [2, 4, 6]
找第 2 小的元素

比較 nums1[0]=5 和 nums2[0]=2：
5 > 2，排除 nums2 的前 1 個元素

剩下：
nums1: [5, 7]
nums2: [4, 6]
找第 1 小的元素

比較 nums1[0]=5 和 nums2[0]=4：
4 < 5，所以第 1 小的元素是 4
```


# 尋找兩個有序數組的中位數 - 思路引導與詳解

## 1. 先理解問題本質

這題看似複雜，讓我從最基本的思考開始引導：

**問題本質**：合併兩個有序數組後，找到中間的那個數（或中間兩個數的平均值）。

**直覺方法**：我們可能會想直接合併兩個數組，然後找中位數。但這需要 O(m+n) 時間，不符合題目要求的 O(log(m+n))。

**關鍵思考點**：我們能否不實際合併數組，就找到中位數呢？

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 320">
  <!-- 背景 -->
  <rect width="600" height="320" fill="#f8f9fa"/>

  <!-- 標題 -->
<text x="300" y="30" font-family="Arial" font-size="18" font-weight="bold" text-anchor="middle">中位數思想: 分割點與左右兩部分</text>

  <!-- 合併數組 -->
  <rect x="50" y="60" width="500" height="40" fill="#e6f7ff" stroke="#333" stroke-width="1"/>
  <text x="300" y="85" font-family="Arial" font-size="14" text-anchor="middle">假想的合併數組</text>

  <!-- 標記中位數 -->
  <line x1="300" y1="50" x2="300" y2="110" stroke="#ff0000" stroke-width="2" stroke-dasharray="5,5"/>
  <text x="300" y="130" font-family="Arial" font-size="14" text-anchor="middle" fill="#ff0000">中位數位置</text>

  <!-- 左右區域標註 -->
<text x="175" y="85" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0066cc">左半部分</text>
<text x="425" y="85" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#cc0066">右半部分</text>

  <!-- 關鍵思想 -->
  <rect x="50" y="150" width="500" height="150" rx="10" ry="10" fill="#f0f0f0" stroke="#333" stroke-width="1"/>
  <text x="300" y="175" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle">關鍵思想</text>
  <text x="70" y="200" font-family="Arial" font-size="14">1. 中位數將數組分成大小相等的兩部分</text>
  <text x="70" y="225" font-family="Arial" font-size="14">2. 左半部分的所有元素 ≤ 右半部分的所有元素</text>
  <text x="70" y="250" font-family="Arial" font-size="14">3. 找到滿足上述條件的分割點，就等於找到了中位數</text>
  <text x="70" y="275" font-family="Arial" font-size="14">4. 我們可以在較短的數組上二分查找這個分割點</text>
</svg>

## 2. 核心思想轉變 - 從合併到分割

**關鍵思路轉變**：
我們不需要實際合併數組，只需要找到一個「分割點」，這個分割點恰好將所有元素分成兩部分：
- 左半部分：具有總元素個數的一半（或一半多一個，如果總長度是奇數）
- 右半部分：剩餘的元素

如果能找到這樣的分割點，那麼：
- 如果總長度是奇數，中位數是**左半部分的最大值**
- 如果總長度是偶數，中位數是**左半部分最大值**和**右半部分最小值**的平均值

## 3. 從具體例子開始思考

讓我們用一個簡單的例子來引導思路：
```
nums1 = [1, 3, 8, 9]
nums2 = [7, 11, 18, 19]
```

如果合併後，數組會是：`[1, 3, 7, 8, 9, 11, 18, 19]`
中位數是 (8 + 9) / 2 = 8.5

**思考問題**：我們如何不實際合併，就能找到這個結果？

## 4. 分割方式的直覺理解

想象我們對兩個數組分別放置一個分割線：

```
nums1: [1, 3 | 8, 9]
nums2: [7 | 11, 18, 19]
```

這樣分割後：
- 左半部分：`[1, 3, 7]`（3個元素）
- 右半部分：`[8, 9, 11, 18, 19]`（5個元素）

這顯然不對！左右兩部分的元素個數不平衡。

**正確的分割**應該是：
```
nums1: [1, 3, 8 | 9]
nums2: [7 | 11, 18, 19]
```

這樣：
- 左半部分：`[1, 3, 7, 8]`（4個元素）
- 右半部分：`[9, 11, 18, 19]`（4個元素）
- 左半部分最大值：8
- 右半部分最小值：9
- 中位數：(8 + 9) / 2 = 8.5 ✓

## 5. 如何系統性找到正確的分割位置？

這就是算法的核心問題。我們需要找到合適的位置 i 和 j，使得：
- nums1[0...i-1] 和 nums2[0...j-1] 構成左半部分
- nums1[i...] 和 nums2[j...] 構成右半部分
- 左半部分和右半部分的元素個數相等（或左半部分多一個）
- 左半部分的最大值 ≤ 右半部分的最小值

## 6. 二分查找的思路引導

**為什麼使用二分查找？**
- 有序數組查找特定位置，二分查找是最有效的方法
- 符合題目要求的 O(log(m+n)) 時間複雜度

**關鍵約束條件**：
1. 左半部分和右半部分的元素個數要平衡
2. 左半部分的最大值 ≤ 右半部分的最小值

這引導出了一個重要思路：**我們只需要在一個數組中二分查找分割點，另一個數組的分割點就自動確定了！**

## 7. 算法步驟推導

讓我分步引導思考這個方法：

**第1步：確保在較短的數組上查找**
如果 nums1 的長度大於 nums2，交換它們。這樣可以減少二分查找的次數。

**為什麼？** 因為我們要在較短的數組上進行二分查找，時間複雜度是 O(log(min(m,n)))。

**第2步：計算關鍵數值**
- 總長度 totalLength = m + n
- 左半部分的元素個數 half = (totalLength + 1) / 2

**為什麼要 +1 再除以2？** 這樣無論總長度是奇數還是偶數，左半部分都能正好包含中位數（奇數）或左中位數（偶數）。

**第3步：在較短數組中二分查找分割點**
- 初始查找範圍：left = 0, right = m
- 在每一步中，計算 i = (left + right) / 2
- 對應的 j = half - i

**第4步：判斷分割點是否合適**
- 如果 nums1[i-1] > nums2[j]：分割點 i 太大，需要左移
- 如果 nums2[j-1] > nums1[i]：分割點 i 太小，需要右移
- 否則：找到了合適的分割點！

## 8. 核心判斷條件解析

為何使用這兩個條件？讓我解釋其深層邏輯：

**條件1: nums1[i-1] > nums2[j]**
- 意味著：nums1 左半部分的最大值 > nums2 右半部分的最小值
- 違反了「左半部分的所有元素 ≤ 右半部分的所有元素」的條件
- 需要將 nums1 的分割點左移，使 nums1 左半部分減少一些較大的元素

**條件2: nums2[j-1] > nums1[i]**
- 意味著：nums2 左半部分的最大值 > nums1 右半部分的最小值
- 同樣違反了「左半部分 ≤ 右半部分」的條件
- 需要將 nums1 的分割點右移，使 nums1 右半部分增加一些較小的元素

## 9. 具體例子跟蹤分析

讓我們以之前的例子完整走一遍：
```
nums1 = [1, 3, 8, 9]   (m = 4)
nums2 = [7, 11, 18, 19] (n = 4)
```

總長度 totalLength = 8，左半部分應有 half = (8 + 1) / 2 = 4 個元素。

**初始狀態**: left = 0, right = 4

**第一次嘗試**:
- i = (0 + 4) / 2 = 2
- j = 4 - 2 = 2
- 分割：
  - nums1: [1, 3 | 8, 9]
  - nums2: [7, 11 | 18, 19]
- 檢查條件：
  - nums1[i-1] = 3, nums2[j] = 18
  - nums2[j-1] = 11, nums1[i] = 8
  - 3 < 18 ✓ 但 11 > 8 ✗

分割點 i 太小，需要右移：left = 2 + 1 = 3

**第二次嘗試**:
- i = (3 + 4) / 2 = 3
- j = 4 - 3 = 1
- 分割：
  - nums1: [1, 3, 8 | 9]
  - nums2: [7 | 11, 18, 19]
- 檢查條件：
  - nums1[i-1] = 8, nums2[j] = 11
  - nums2[j-1] = 7, nums1[i] = 9
  - 8 < 11 ✓ 且 7 < 9 ✓

找到合適的分割點！

- 左半部分的最大值 maxLeft = max(8, 7) = 8
- 右半部分的最小值 minRight = min(9, 11) = 9
- 中位數 = (8 + 9) / 2 = 8.5

## 10. 邊界情況處理

算法中還有一些邊界情況需要特別處理：

**1. 左半部分為空的情況：**
- 如果 i = 0，表示 nums1 的所有元素都在右半部分
- 此時左半部分的最大值就是 nums2[j-1]

**2. 右半部分為空的情況：**
- 如果 i = m，表示 nums1 的所有元素都在左半部分
- 此時右半部分的最小值就是 nums2[j]

## 11. 完整程式碼解析，著重思路

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    // 確保在較短的數組上進行二分查找，優化時間複雜度
    if len(nums1) > len(nums2) {
       nums1, nums2 = nums2, nums1
    }

    m, n := len(nums1), len(nums2)
    totalLength := m + n
    
    // 計算左半部分應有的元素個數
    // 為什麼 +1？確保奇數長度時，左半部分多一個元素
    half := (totalLength + 1) / 2

    // 在nums1上進行二分查找，尋找合適的分割點
    // 注意：right = m而不是m-1，因為分割點可能在數組之後
    left, right := 0, m

    for left <= right {
       // 嘗試的分割點
       i := (left + right) / 2
       j := half - i  // 對應的nums2分割點

       // 檢查分割是否合適
       // 條件1：i < m && nums2[j-1] > nums1[i]
       // 說明：nums1分割點太靠左，nums2左半部分的最大值超過了nums1右半部分的最小值
       if i < m && nums2[j-1] > nums1[i] {
          left = i + 1  // 向右移動分割點
       } 
       // 條件2：i > 0 && nums1[i-1] > nums2[j]
       // 說明：nums1分割點太靠右，nums1左半部分的最大值超過了nums2右半部分的最小值
       else if i > 0 && nums1[i-1] > nums2[j] {
          right = i - 1  // 向左移動分割點
       } 
       // 找到合適的分割點
       else {
          // 計算左半部分的最大值
          maxLeft := 0
          // 處理邊界情況：nums1左半部分為空
          if i == 0 {
             maxLeft = nums2[j-1]
          } 
          // 處理邊界情況：nums2左半部分為空
          else if j == 0 {
             maxLeft = nums1[i-1]
          } 
          // 一般情況：取兩個左半部分的最大值
          else {
             maxLeft = max(nums1[i-1], nums2[j-1])
          }

          // 如果總長度為奇數，直接返回左半部分的最大值
          if totalLength%2 == 1 {
             return float64(maxLeft)
          }

          // 計算右半部分的最小值
          minRight := 0
          // 處理邊界情況：nums1右半部分為空
          if i == m {
             minRight = nums2[j]
          } 
          // 處理邊界情況：nums2右半部分為空
          else if j == n {
             minRight = nums1[i]
          } 
          // 一般情況：取兩個右半部分的最小值
          else {
             minRight = min(nums1[i], nums2[j])
          }

          // 總長度為偶數，返回左半部分最大值與右半部分最小值的平均值
          return float64(maxLeft+minRight) / 2.0
       }
    }

    return 0.0  // 不會執行到這裡，為了編譯器
}
```

## 12. 複雜度與核心思想總結

**時間複雜度**: O(log(min(m,n)))
- 我們在較短數組上進行二分查找
- 每次查找將搜索空間減半

**空間複雜度**: O(1)
- 只使用常數額外空間

**核心思想總結**:
1. 將「找中位數」轉化為「找分割點」問題
2. 在較短數組上二分查找分割點
3. 通過兩個關鍵條件判斷分割點是否合適：
  - nums1[i-1] ≤ nums2[j]
  - nums2[j-1] ≤ nums1[i]
4. 找到分割點後，根據總長度的奇偶性計算中位數

## 13. 學習啟示

這個問題展示了幾個重要的算法思想：
1. **問題轉化**：將「找中位數」轉化為「找分割點」
2. **二分查找**：在有序集合中查找特定值的高效方法
3. **不變性條件**：通過維持「左半部分 ≤ 右半部分」的不變性來解決問題
4. **邊界情況處理**：仔細考慮特殊情況，確保算法的全面性

掌握這些思想，不僅能解決此題，也能應用於其他複雜問題的解決。