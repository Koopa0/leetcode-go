## 1. Original Problem

### English Version
Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

**Example 1:**
```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**
```
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:**
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

### 繁體中文版本
給定兩個大小分別為 `m` 和 `n` 的排序數組 `nums1` 和 `nums2`，請返回這兩個排序數組的中位數。

總體運行時間複雜度應為 O(log (m+n))。

**示例 1：**
```
輸入：nums1 = [1,3], nums2 = [2]
輸出：2.00000
解釋：合併數組 = [1,2,3]，中位數為 2。
```

**示例 2：**
```
輸入：nums1 = [1,2], nums2 = [3,4]
輸出：2.50000
解釋：合併數組 = [1,2,3,4]，中位數為 (2 + 3) / 2 = 2.5。
```

**約束條件：**
- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-10^6 <= nums1[i], nums2[i] <= 10^6`

## 2. 問題理解

這個問題要求找出兩個已排序數組的中位數，且時間複雜度要求為 O(log(m+n))。讓分析一下：

- 兩個數組已經各自排序好了
- 需要找出合併後的中位數，而不需要真正合併兩個數組
- 中位數的定義：如果合併後的數組長度為奇數，則中位數是中間的元素；如果長度為偶數，則中位數是中間兩個元素的平均值
- 時間複雜度要求 O(log(m+n)) 暗示需要使用二分查找或類似的對數級別算法
- 數組可能為空（m 或 n 可能為 0）
- 數組元素可能是負數

關鍵挑戰：
1. 如何在不合併數組的情況下找到中位數
2. 如何達到 O(log(m+n)) 的時間複雜度
3. 如何處理奇數和偶數長度的情況

## 3. 視覺解釋

讓用視覺化來理解問題和解決方案。

假設有兩個排序數組：
```
nums1 = [1, 3, 5, 7]
nums2 = [2, 4, 6]
```

合併後的數組應該是：
```
merged = [1, 2, 3, 4, 5, 6, 7]
```

合併後的長度為 7（奇數），所以中位數是中間的元素：4。

的目標是在不實際合併數組的情況下找到這個值。

關鍵思路：可以將問題轉化為"尋找第 k 小的元素"，其中 k = (m+n+1)/2。

對於這個例子：k = (4+3+1)/2 = 4，所以需要找第 4 小的元素。

讓看一個算法執行的圖示：

```
步驟 1: 初始狀態
nums1 = [1, 3, 5, 7]
        ^
nums2 = [2, 4, 6]
        ^
尋找第 4 小的元素

步驟 2: 比較 nums1[2-1]=1 和 nums2[2-1]=2
1 < 2，所以排除 nums1 的前 2 個元素

nums1 = [1, 3, 5, 7]
           ^
nums2 = [2, 4, 6]
        ^
現在尋找第 2 小的元素

步驟 3: 比較 nums1[1-1]=3 和 nums2[1-1]=2
3 > 2，所以排除 nums2 的前 1 個元素

nums1 = [1, 3, 5, 7]
           ^
nums2 = [2, 4, 6]
           ^
現在尋找第 1 小的元素

步驟 4: 比較 nums1[1-1]=3 和 nums2[1-1]=4
3 < 4，所以第 1 小的元素是 3

所以中位數是 4。
```

## 4. 思考過程

針對此問題，可以考慮幾種方法：

### 方法 1：合併後找中位數
最直觀的方法是先合併兩個排序數組，然後直接找中位數。
- 時間複雜度：O(m+n)，用於合併兩個數組
- 空間複雜度：O(m+n)，用於存儲合併後的數組
- 這種方法簡單直觀，但不符合題目要求的 O(log(m+n)) 時間複雜度

### 方法 2：使用計數方法
可以不實際合併數組，而是使用兩個指針同時遍歷兩個數組，直到找到中位數位置。
- 時間複雜度：O(m+n)
- 空間複雜度：O(1)
- 也不符合題目要求的時間複雜度

### 方法 3：二分查找
考慮到題目要求 O(log(m+n)) 的時間複雜度，可以使用二分查找。
- 將問題轉化為"尋找第 k 小的元素"
- 每次比較兩個數組的第 k/2 個元素，排除較小部分
- 時間複雜度：O(log(m+n))
- 空間複雜度：O(1)
- 這符合題目要求，但實現較為複雜

我選擇方法 3，因為它符合題目的時間複雜度要求，且不需要額外空間。

## 5. 最優解決方案開發

讓詳細開發二分查找的解決方案。

核心思想：將"尋找中位數"轉化為"尋找第 k 小的元素"。如果合併後的數組長度為奇數，則中位數是第 (m+n+1)/2 小的元素；如果為偶數，則是第 (m+n)/2 和第 (m+n)/2+1 小的元素的平均值。

使用二分查找逐步排除較小的一半元素：

1. 首先，計算 k = (m+n+1)/2
2. 比較 nums1[k/2-1] 與 nums2[k/2-1]（如果索引有效）
3. 較小的那部分可以排除，因為確定它們不可能包含第 k 小的元素
4. 調整指針和 k 值，重複上述過程
5. 直到找到第 k 小的元素

讓用例子詳細說明：
```
nums1 = [1, 3, 5, 7]  (m=4)
nums2 = [2, 4, 6]     (n=3)
```

1. 總長度 m+n=7（奇數），中位數是第 (7+1)/2=4 小的元素
2. 比較 nums1[4/2-1]=nums1[1]=3 和 nums2[4/2-1]=nums2[1]=4
3. 3 < 4，所以 nums1 的前 4/2=2 個元素（1 和 3）可能包含第 4 小的元素，不能排除；反之，可以排除 nums1 的前 2 個元素
4. 數組變為 [5, 7] 和 [2, 4, 6]，現在尋找第 4-2=2 小的元素
5. 比較 nums1[2/2-1]=nums1[0]=5 和 nums2[2/2-1]=nums2[0]=2
6. 5 > 2，所以排除 nums2 的前 1 個元素
7. 數組變為 [5, 7] 和 [4, 6]，現在尋找第 2-1=1 小的元素
8. 比較 nums1[1/2-1]=nums1[0]=5 和 nums2[1/2-1]=nums2[0]=4
9. 5 > 4，所以第 1 小的元素是 nums2[0]=4
10. 因此，中位數是 4


## 7. 複雜度分析

### 時間複雜度

- 首先將較長數組放在 nums2 位置：O(1)
- 二分查找過程：在長度為 m 的數組上進行二分查找，每次將搜索空間減半
    - 總共需要 O(log m) 次迭代
- 在每次迭代中，進行常數時間的操作
- 因此，總時間複雜度為 O(log m)，其中 m <= n
- 由於 m <= n，所以 O(log m) <= O(log n)，而且 O(log m) <= O(log(m+n))
- 所以最終時間複雜度是 O(log(min(m, n)))，這滿足題目要求的 O(log(m+n))

### 空間複雜度

- 只使用了常數額外空間來存儲變量
- 沒有使用與輸入大小相關的額外數據結構
- 因此，空間複雜度為 O(1)

## 8. 優化與改進

的解決方案已經達到了時間複雜度 O(log(min(m, n)))，這是最優的。可能的一些改進和變體：

1. **異常處理**：增加對空數組的處理
2. **簡化邊界條件**：可以通過添加"虛擬元素"（無窮大或無窮小）來簡化邊界條件的處理
3. **遞迴實現**：也可以使用遞迴方式實現二分查找，可能在某些情況下更容易理解

## 9. 測試策略

這個測試套件包含了各種情況：
1. 來自問題描述的基本示例
2. 邊界情況：空數組
3. 長度差異大的數組
4. 包含重複元素的數組
5. 包含負數的數組
6. 極端情況：接近約束限制的大值

總結：這道題的關鍵在於將"尋找中位數"轉化為"尋找第 k 小的元素"的問題，然後使用二分查找的思想逐步縮小搜索範圍。這種方法不僅達到了 O(log(min(m,n))) 的時間複雜度，還只使用 O(1) 的額外空間，是一個非常優秀的解法。

理解這個問題的關鍵是掌握如何在兩個排序數組中高效地找到特定位置的元素，這也是類似問題（如第 k 小元素、排序數組的中間值等）的基礎。


## 尋找兩個排序數組的中位數 - 核心思想

### 問題的本質

想像你有兩堆已經排好序的卡片，每張卡片上有一個數字。你需要找出如果把這兩堆卡片合併後，中間位置的那張卡片是什麼。但是，你不能真的把卡片全部合併排序，因為那樣太慢了。

### 更直觀的思路

如果直接合併兩個數組，時間複雜度是 O(m+n)。題目要求 O(log(m+n))，這意味著需要更聰明的方法，通常這暗示著二分查找。

讓換個思路：**中位數其實就是第 (m+n)/2 小的元素**（或者是第 (m+n)/2 和第 (m+n)/2+1 小元素的平均值，如果總長度是偶數）。

### 方法解析：二分排除法

這個方法的核心是：**不斷縮小搜索範圍，排除一定不包含答案的部分**。

讓我用一個生活中的例子來解釋：

想像你和朋友各有一堆已排序的撲克牌（只看牌面數字，不考慮花色）。你想知道把兩堆牌合在一起後，中間的那張牌是什麼。

1. **確定目標位置**：假設總共有 7 張牌，要找第 4 小的牌。

2. **比較中間位置**：
  - 你從你的牌堆中取出第 2 張牌（假設是 3）
  - 朋友從他的牌堆中取出第 2 張牌（假設是 4）

3. **排除不可能的部分**：
  - 你的第 2 張牌是 3，比朋友的第 2 張牌 4 小
  - 這告訴什麼？**你牌堆的前 2 張牌肯定在合併後的前 4 張牌中**，但不可能是第 4 小的牌
  - 為什麼？因為即使朋友的所有牌都比你的第 2 張牌大，你的第 2 張牌最多也只能是第 3 小的

4. **縮小範圍**：
  - 可以安全地排除你牌堆的前 2 張牌
  - 現在要在剩下的牌中找第 4-2=2 小的牌

### 用具體例子詳細演示

讓用實例演示這個過程：
```
你的牌堆：[1, 3, 5, 7]
朋友的牌堆：[2, 4, 6]
```

1. **目標**：找出合併後第 4 小的元素（總共 7 張牌，中位數是第 4 小）

2. **第一輪比較**：
  - 比較你的第 2 張牌（值為 3）和朋友的第 2 張牌（值為 4）
  - 3 < 4，說明你的前 2 張牌（1 和 3）肯定不是第 4 小的元素
  - 圖示：[1, 3, |5, 7] 和 [2, 4, 6]（| 表示排除分界線）

3. **更新搜索**：
  - 現在牌堆變為：[5, 7] 和 [2, 4, 6]
  - 已經排除了 2 張牌，現在要找第 4-2=2 小的元素

4. **第二輪比較**：
  - 比較你的第 1 張牌（值為 5）和朋友的第 1 張牌（值為 2）
  - 5 > 2，說明朋友的第 1 張牌（2）肯定不是第 2 小的元素
  - 圖示：[5, 7] 和 [|2, 4, 6]（| 表示排除分界線）

5. **再次更新**：
  - 牌堆變為：[5, 7] 和 [4, 6]
  - 排除了 1 張牌，現在找第 2-1=1 小的元素

6. **最後一輪**：
  - 比較 5 和 4
  - 4 < 5，所以第 1 小的元素是 4
  - 因此，原始牌堆合併後的第 4 小元素（即中位數）是 4

### 為什麼這個方法有效？

每次比較時，可以確定性地排除一些元素：

- 如果 nums1[k/2-1] < nums2[k/2-1]，那麼 nums1 的前 k/2 個元素絕對不可能是第 k 小的元素
- 因為即使 nums2 中的前 k/2-1 個元素全部小於 nums1[k/2-1]，那麼 nums1[k/2-1] 最多只能是第 (k/2-1) + k/2 = k-1 小的元素

每次都能排除 k/2 個元素，這就是為什麼時間複雜度是 O(log(m+n))。

### 視覺化理解

想像有兩個排序數組：
```
nums1: [1, 3, 5, 7]
nums2: [2, 4, 6]
```

合併後會是：[1, 2, 3, 4, 5, 6, 7]

的目標是找出第 4 個元素，即 4。但不通過合併來找，而是使用二分排除法：

```
比較 nums1[1]=3 和 nums2[1]=4：
3 < 4，排除 nums1 的前 2 個元素

剩下：
nums1: [5, 7]
nums2: [2, 4, 6]
找第 2 小的元素

比較 nums1[0]=5 和 nums2[0]=2：
5 > 2，排除 nums2 的前 1 個元素

剩下：
nums1: [5, 7]
nums2: [4, 6]
找第 1 小的元素

比較 nums1[0]=5 和 nums2[0]=4：
4 < 5，所以第 1 小的元素是 4
```
