# LeetCode 91: Decode Ways (解碼方法)

## 1. 問題定義

### Original Problem (English)
```
A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"

To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)

Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.
```

### 問題翻譯（繁體中文）
```
一個包含A-Z字母的訊息可以使用以下映射編碼成數字：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"

要解碼一個編碼訊息，所有數字必須分組，然後使用上述映射的反向映射回字母（可能有多種方式）。例如，"11106"可以映射為：

"AAJF"，分組為(1 1 10 6)
"KJF"，分組為(11 10 6)

請注意，分組(1 11 06)是無效的，因為"06"不能映射成'F'，因為"6"與"06"不同。

給定一個只包含數字的字串s，回傳解碼它的方法數量。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: s = "12"
  輸出: 2
  解釋: "12" 可以解碼為 "AB" (1 2) 或 "L" (12)
  ```
- **範例 2:**
  ```
  輸入: s = "226"
  輸出: 3
  解釋: "226" 可以解碼為 "BZ" (2 26), "VF" (22 6), 或 "BBF" (2 2 6)
  ```
- **範例 3:**
  ```
  輸入: s = "06"
  輸出: 0
  解釋: "06" 不能映射到 "F"，因為 "06" 不等同於 "6"。此外，"06" 也不能作為 "A" 到 "Z" 的任何字母的組合。
  ```

- **限制條件:**
    - 1 <= s.length <= 100
    - s 只包含數字且可能包含前導零

## 2. 問題理解

### 初始反應與心理建模
- 第一反應：這看起來是一個需要考慮多種可能性的問題，很可能是動態規劃或遞迴問題。
- 範例解讀：每個數字可以單獨解碼（如果不是0），或與前一個數字一起解碼（如果它們組合在1到26範圍內）。
- 輸入、輸出和轉換：輸入是一個數字字串，輸出是解碼方法的總數，轉換涉及確定有效分組的所有可能方式。
- 視覺化：我可以將這個問題視為在字串上選擇分割點的問題，每一種有效的分割方式都代表一種解碼方法。

### 問題分解
- 核心子問題：確定從位置i開始的子字串有多少種解碼方式。
- 必要操作：判斷單個數字是否有效（非0）；判斷兩個連續數字是否有效（10-26範圍內）。
- 假設與邊界情況：處理以0開頭的情況；處理連續的0；處理空字串。
- 問題拆分：遞迴思考 - 當前位置的解碼方式取決於後續位置的解碼方式。

### 視覺表示
```
解碼樹狀圖：
"226"
/    \
"2"    "22"
/ \       \
"2" "6"    "6"

"2"分支：繼續解碼"26" -> 有2種方式
"22"分支：繼續解碼"6" -> 有1種方式
總計：2 + 1 = 3種解碼方式
```

- 視覺化澄清：這個樹狀圖説明了如何從左到右遍歷字串，在每一步考慮取1位或2位數字的可能性。
- 模式洞察：我們可以看到重疊子問題，例如對於"226"，我們需要多次計算解碼"6"的方式數。

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於哪些常見算法模式？
    - [ ] 陣列/字串操作
    - [ ] 雙指標/滑動窗口
    - [ ] 二分搜索/二元答案
    - [ ] 深度優先搜索 (DFS)
    - [ ] 廣度優先搜索 (BFS)
    - [ ] 回溯法
    - [x] 動態規劃 (DP)
    - [ ] 貪心算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 這個問題中，我們需要計算所有可能的解碼方式，且存在重疊子問題。
    - 問題具有最優子結構特性：解碼整個字串的問題可以分解為解碼子字串的問題。

### 知識連接
- 這個問題涉及字串處理、遞迴思想和動態規劃。
- 相關的計算機科學概念：記憶化搜索、自底向上的動態規劃、狀態轉移函數。
- 需要應用的理論知識：動態規劃的基本原理，特別是如何定義狀態和狀態轉移函數。

### 相似問題比較
- LeetCode 70: Climbing Stairs - 也是一個使用動態規劃計算不同方式數量的問題。
- LeetCode 509: Fibonacci Number - 基本的動態規劃問題，解決方案結構類似。
- LeetCode 139: Word Break - 使用動態規劃確定字串是否可以被分割成有效單詞。
- 相似之處在於這些問題都可以使用動態規劃，且狀態轉移函數涉及前面一個或多個狀態的組合。

## 4. 算法直覺發展

### 直覺建立
- 現實世界類比：這像是翻譯密碼，我們嘗試所有可能的解讀方式，並計算有效解讀的總數。
- 初始直覺：從字串左側開始，我們可以選擇解碼一個數字或兩個數字（如果有效），然後繼續處理剩餘部分。
- 系統性驗證：通過手動跟踪一些簡單範例（如"12"、"226"）來確認直覺的正確性。

### 多角度思考
- 不同角度的思考：
    - 自頂向下 vs. 自底向上：我們可以使用遞迴（自頂向下）或迭代（自底向上）解決此問題。
    - 迭代 vs. 遞迴：遞迴更直觀地表達問題，但迭代更高效。
    - 基於狀態 vs. 基於轉換：我們可以定義狀態為"解碼到位置i的方法數"，轉換則是根據當前數字是否可以單獨解碼或與前一個數字一起解碼。
- 最有前景的視角：對於這個問題，自底向上的動態規劃方法最為有效，避免了遞迴調用的開銷。

## 5. 解決方案發展過程

### 方法 1：暴力遞迴解法

#### 思考過程
- 最直接的方法是使用遞迴枚舉所有可能的解碼方式。
- 從字串左側開始，我們可以嘗試解碼一個數字或兩個數字，然後遞迴處理剩餘部分。
- 這種方法雖然直觀，但可能存在許多重複計算。

#### 算法設計
```
函數 numDecodings(s, index):
    如果 index == s.length:
        return 1  // 找到一種有效解碼方式
    
    如果 s[index] == '0':
        return 0  // 0無法單獨解碼
    
    // 嘗試解碼一個數字
    一位數解碼方式 = numDecodings(s, index + 1)
    
    // 嘗試解碼兩個數字（如果可能）
    兩位數解碼方式 = 0
    如果 index + 1 < s.length 且 s[index:index+2]表示的數字在10到26之間:
        兩位數解碼方式 = numDecodings(s, index + 2)
    
    return 一位數解碼方式 + 兩位數解碼方式
```

#### 實作詳情
- 使用的Go特定資料結構：主要使用字串操作和遞迴函數調用。
- 使用的Go慣用方式：字元處理使用byte型別，字串索引返回字元的byte值。
- 潛在的實作陷阱：需要仔細處理字元到數字的轉換，確保正確計算一位數和兩位數的數值。

#### 複雜度分析
- **時間複雜度**：O(2^n) — 在最壞情況下，每個位置都可以解碼為單個數字或與前一個數字結合，形成二叉遞迴樹。
- **空間複雜度**：O(n) — 遞迴調用堆疊的深度與字串長度成正比。

#### 解法評估
- 優點：算法直觀易懂，直接模擬了解碼過程。
- 缺點：存在大量重疊子問題，導致許多計算被重複執行，效率非常低。
- 面試背景下的評價：雖然是一個合理的起點，但在面試中需要優化到更高效的解法。

### 方法 2：帶記憶化的遞迴解法

#### 關鍵洞見
- 暴力遞迴方法中存在大量重疊子問題，例如在解碼"1234"時，我們可能多次計算從索引2開始的解碼方式數。
- 我們可以使用記憶化技術（提前記錄計算結果）來避免重複計算。
- 記憶化將使算法從指數時間複雜度降至線性時間複雜度。

#### 優化策略
```
使用記憶數組memo來存儲已計算的結果：
memo[i] = 從索引i開始的解碼方式數

函數 numDecodings(s, index, memo):
    如果 memo[index] 已計算:
        return memo[index]
    
    如果 index == s.length:
        return 1
    
    如果 s[index] == '0':
        memo[index] = 0
        return 0
    
    // 嘗試解碼一個數字
    一位數解碼方式 = numDecodings(s, index + 1, memo)
    
    // 嘗試解碼兩個數字（如果可能）
    兩位數解碼方式 = 0
    如果 index + 1 < s.length 且 s[index:index+2]表示的數字在10到26之間:
        兩位數解碼方式 = numDecodings(s, index + 2, memo)
    
    memo[index] = 一位數解碼方式 + 兩位數解碼方式
    return memo[index]
```

#### 實作改進
- 使用記憶化數組避免重複計算，每個子問題只計算一次。
- 使用Go的切片作為記憶化數組，利用切片的動態特性。
- 初始化記憶化數組為-1，表示尚未計算過的狀態。

#### 複雜度分析
- **時間複雜度**：O(n) — 每個子問題只計算一次，且有n個可能的子問題（即字串的每個索引位置）。
- **空間複雜度**：O(n) — 記憶化數組的大小與字串長度成正比，再加上遞迴調用堆疊的空間也是O(n)。

#### 解法評估
- 為什麼這個優化有效：避免了重複計算相同的子問題，顯著提高了效率。
- 在什麼情況下特別有價值：當字串較長，有許多重疊子問題時尤其有效。
- 權衡取捨：使用了額外的記憶體來存儲中間結果，但換來了時間效率的顯著提升。

### 方法 3：自底向上的動態規劃解法

#### 突破性思考
- 我們可以完全避免遞迴調用，使用迭代的方式自底向上計算解碼方式數。
- 定義dp[i]為字串s的前i個字元的解碼方式數。
- 通過分析狀態轉移，我們可以直接計算出最終結果，無需回溯。

#### 最佳算法
```
初始化 dp[0] = 1（空字串有一種解碼方式）
初始化 dp[1]：如果 s[0] != '0'，則為1，否則為0

對於 i = 2 到 n：
    // 考慮單個數字解碼
    如果 s[i-1] != '0'：
        dp[i] += dp[i-1]
    
    // 考慮兩個數字解碼
    如果 s[i-2:i] 在 10 到 26 之間：
        dp[i] += dp[i-2]

返回 dp[n]
```

#### 實作優化
- 利用Go的切片實現動態規劃數組，清晰反映狀態轉移過程。
- 仔細處理特殊情況和邊界條件，特別是與'0'相關的處理。
- 代碼簡潔明了，直接體現了動態規劃的思想。

#### 複雜度分析
- **時間複雜度**：O(n) — 單次遍歷字串，每個位置的計算是常數時間。
- **空間複雜度**：O(n) — 需要一個長度為n+1的dp數組。

#### 從暴力到最優的思維演變
- 思考進程如何演變：從直觀的遞迴枚舉，到使用記憶化避免重複計算，最後到自底向上的動態規劃完全消除遞迴調用。
- 每個優化階段解決的具體問題：記憶化解決了重複計算問題，自底向上解決了遞迴調用的開銷問題。
- Go實現如何反映思維演變：從純遞迴函數，到帶有記憶化數組的遞迴，再到純迭代的dp數組實現。
- 如何將這種思維模式應用於其他問題：識別重疊子問題和最優子結構是應用動態規劃的關鍵。

### 進一步優化：空間優化版動態規劃

#### 空間優化思路
- 觀察到當前狀態 dp[i] 只依賴於 dp[i-1] 和 dp[i-2]。
- 我們可以只使用兩個變量而不是整個數組來存儲必要的狀態。

#### 複雜度分析
- **時間複雜度**：O(n) — 與前一個方法相同，單次遍歷字串。
- **空間複雜度**：O(1) — 只使用常數級別的額外空間，不再需要整個dp數組。

## 6. 範例演練

### 完整範例追蹤
使用最優解法追蹤範例輸入 "226"：

1. 初始狀態：
    - dp_prev_prev = 1 (空字串的解碼方式數)
    - dp_prev = 1 (字串 "2" 的解碼方式數)

2. i = 2（考慮字串 "22"）：
    - 考慮單個數字：s[1] = '2' != '0'，所以 current += dp_prev = 1
    - 考慮兩個數字：s[0:2] = "22" = 22，在10到26之間，所以 current += dp_prev_prev = 1
    - current = 1 + 1 = 2
    - 更新：dp_prev_prev = 1, dp_prev = 2

3. i = 3（考慮字串 "226"）：
    - 考慮單個數字：s[2] = '6' != '0'，所以 current += dp_prev = 2
    - 考慮兩個數字：s[1:3] = "26" = 26，在10到26之間，所以 current += dp_prev_prev = 1
    - current = 2 + 1 = 3
    - 更新：dp_prev_prev = 2, dp_prev = 3

4. 最終狀態：
    - 輸出：3

### 所有方法的性能比較
```
| 方法                   | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|-----------------------|-----------|-----------|-------------|
| 暴力遞迴                | O(2^n)    | O(n)      | ~10-100ms   |
| 帶記憶化的遞迴           | O(n)      | O(n)       | ~1-5ms      |
| 自底向上的動態規劃       | O(n)       | O(n)       | ~0.5-2ms    |
| 空間優化版動態規劃       | O(n)       | O(1)       | ~0.5-1ms    |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解法使用Go的切片進行動態規劃，符合Go的資料結構使用習慣。
- 利用了Go對字串的字元訪問方式（字串索引返回byte）。
- 確保代碼簡潔清晰，遵循Go的命名慣例和風格指南。

### 錯誤處理與邊界情況
- 仔細處理了'0'字元的特殊情況，包括開頭為'0'和中間出現'0'的情況。
- 考慮了空字串和長度為1的字串的特殊情況。
- 對於超出有效範圍（10-26）的兩位數數字，確保不計入有效解碼方式中

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3分鐘，確保明白解碼規則和有效性條件
- 初始解法提案：~5分鐘，提出遞迴解法並分析其限制
- 最佳化討論：~5-7分鐘，從記憶化到動態規劃的優化過程
- 代碼書寫：~10-15分鐘，實現空間優化的動態規劃解法
- 測試與除錯：~5分鐘，用提供的測試案例驗證解法

### 面試官互動模擬
- 向面試官解釋我的Go實現：
  "我會使用動態規劃來解決這個問題。首先我們定義狀態dp[i]為字串前i個字元的解碼方式數。然後考慮狀態轉移：如果當前字元不是'0'，可以單獨解碼，所以dp[i]+=dp[i-1]；如果當前字元與前一個字元組成的兩位數在10到26之間，可以一起解碼，所以dp[i]+=dp[i-2]。最後我們進一步觀察到狀態轉移只依賴於前兩個狀態，因此可以優化空間複雜度至O(1)。"

- 潛在提示和引導問題：
    - "你能解釋一下為什麼我們初始化dp[0]=1嗎？"
    - "如果連續出現兩個'0'，你的算法會如何處理？"
    - "我們是否可以進一步優化空間複雜度？"

- 我會清晰地傳達我的實現決策，解釋每個邊界條件的處理方式，以及優化思路。

### 潛在後續問題
- 如果輸入規模大幅增加，你如何修改你的Go代碼？
    - 答：當前的空間優化版動態規劃已經具有最佳的時間和空間複雜度，但對於超大輸入，可能需要考慮大數運算，因為解碼方式數可能超出整數範圍。Go有big包可以處理這種情況。

- 如果記憶體受限，你會應用哪些Go特定的優化？
    - 答：當前的空間優化方法已經將空間複雜度降至O(1)，已是最優解。如果還有額外的記憶體限制，可以考慮使用特定變數型別（如uint8）來減少每個變數的記憶體佔用。

- 如何擴展你的解法來處理更複雜的問題，例如解碼方式中包含特殊字元？
    - 答：我會修改狀態轉移邏輯，添加更多的條件檢查來處理特殊字元。例如，如果某些特定的數字組合映射到特殊字元，我們需要額外的狀態轉移規則來處理這些情況。基本的動態規劃框架仍然適用，但需要擴展轉移邏輯。

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會我在Go中實現動態規劃的技巧，特別是狀態定義和轉移函數的設計。
- 更深入理解了Go中字串處理、切片操作和記憶化技術的應用。
- 需要加強的領域：處理更複雜的狀態轉移和進一步的空間優化技巧。

### 心智模型構建
- 從這個經驗中抽象出的通用解題框架：
    1. 識別問題是否具有重疊子問題和最優子結構特性
    2. 定義清晰的狀態和轉移函數
    3. 考慮自頂向下（記憶化）和自底向上（動態規劃）的實現方式
    4. 尋找空間優化的可能性，通常通過觀察狀態依賴關係

- 此框架可應用於各種類型的動態規劃問題，包括路徑計數、最優化和字串處理問題。

### 錯誤模式識別
- 實現過程中的常見錯誤：處理邊界情況不當，特別是與'0'相關的情況。
- 這些錯誤揭示了我在動態規劃初始條件設置方面的盲點。
- 預防類似錯誤的策略：仔細分析特殊輸入，如空字串、單字元字串和包含'0'的情況，並為每種情況設計測試案例。

### 知識圖譜擴展
- 相關Go編程資源：《Effective Go》、Go官方文檔中的動態規劃示例。
- 進階Go模式和技術：記憶化與閉包結合、使用函數選項模式處理多種解法變體。
- 這個實現如何融入我的Go知識體系：增強了我對Go實現動態規劃的理解，尤其是空間優化技術