# 1. Original Problem:

Given a string `s`, return the longest palindromic substring in `s`.

A palindrome is a string that reads the same backward as forward.

**Example 1:**
```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

**Example 2:**
```
Input: s = "cbbd"
Output: "bb"
```

**Constraints:**
- 1 <= s.length <= 1000
- s consists only of lowercase English letters.

# 1. 原題目：

給定一個字符串 `s`，返回 `s` 中最長的回文子串。

回文是指從左向右讀和從右向左讀都相同的字符序列。

**示例 1：**
```
輸入: s = "babad"
輸出: "bab"
解釋: "aba" 也是一個有效答案。
```

**示例 2：**
```
輸入: s = "cbbd"
輸出: "bb"
```

**約束條件：**
- 1 <= s.length <= 1000
- s 僅由小寫英文字母組成。

# 2. 問題理解：

這個問題要求在給定的字符串中找出最長的回文子串。回文是從左到右讀和從右到左讀都一樣的字符串。

**核心要點：**
- 需要找的是子串（連續字符序列），而不是子序列
- 如果有多個同樣長度的回文子串，返回任意一個即可
- 字符串僅包含小寫英文字母
- 字符串長度最大為1000

**邊界情況：**
- 單個字符：任何單個字符都是回文
- 整個字符串都相同：整個字符串是回文
- 沒有長度大於1的回文：那麼答案是任意單個字符

**主要挑戰：**
- 暴力檢查所有可能的子串是O(n³)時間複雜度，效率較低
- 需要找出一種有效方法來識別回文，避免重複計算

# 3. 視覺解釋：

# 4. 思考過程：

在解決最長回文子串問題時，有幾種不同的方法，來逐一探討：

## 方法一：暴力法
最直接的方法是檢查所有可能的子串，並驗證每個子串是否為回文。

**優點**：簡單易懂，容易實現。
**缺點**：時間複雜度為O(n³)，對於長度接近1000的字符串效率很低。

## 方法二：動態規劃法
可以使用動態規劃來避免重複的回文檢查。定義 `DP[i][j]` 表示子串 `s[i...j]` 是否為回文。

**遞推關係**：
- `DP[i][i] = true`（單個字符總是回文）
- `DP[i][i+1] = (s[i] == s[i+1])`（兩個相同字符是回文）
- 對於長度大於2的子串：`DP[i][j] = (s[i] == s[j]) && DP[i+1][j-1]`

**時間複雜度**：O(n²)
**空間複雜度**：O(n²)

## 方法三：中心擴展法
回文串具有對稱性，因此可以從每個可能的"中心"開始，向兩側擴展，直到不再形成回文為止。

對於長度為n的字符串，有2n-1個可能的中心點：
- n個單字符中心（奇數長度回文）
- n-1個相鄰字符對中心（偶數長度回文）

**時間複雜度**：O(n²)
**空間複雜度**：O(1)

## 方法四：Manacher算法
這是一個專門解決回文子串問題的高級算法，時間複雜度為O(n)。但由於實現較為複雜，對於本題的約束條件（最大長度1000），方法三已足夠高效。

**比較與選擇**：
- 考慮到實現難度和效率，中心擴展法是最佳選擇
- 雖然動態規劃和中心擴展法都是O(n²)時間複雜度，但中心擴展法不需要額外的O(n²)空間
- Manacher算法雖然更快，但實現複雜度高，不如中心擴展法直觀

因此，選擇中心擴展法作為本題的最優解法。

# 5. 最優解方案開發：

中心擴展法的核心思想是：對於每個可能的回文中心，嘗試向兩側擴展，尋找以該點為中心的最長回文子串。

讓以例子"babad"詳細演示整個過程：

1. **初始化**：`start = 0, maxLength = 1`（至少有一個字符的回文）

2. **遍歷每個可能的中心點**：

   **中心點0（字符'b'）**：
    - 擴展奇數長度：只有'b'本身，長度為1
    - 擴展偶數長度：檢查'b'和'a'，不匹配，無法擴展

   **中心點1（字符'a'）**：
    - 擴展奇數長度：先是'a'本身，長度為1
        - 再檢查'b'和'b'，匹配！
        - 擴展到"bab"，長度為3，更新`start = 0, maxLength = 3`
    - 擴展偶數長度：檢查'a'和'b'，不匹配，無法擴展

   **中心點2（字符'b'）**：
    - 擴展奇數長度：先是'b'本身，長度為1
        - 再檢查'a'和'a'，匹配！
        - 擴展到"aba"，長度為3，但與當前最大長度相同，不更新
    - 擴展偶數長度：檢查'b'和'a'，不匹配，無法擴展

   **中心點3（字符'a'）**：
    - 擴展奇數長度：只有'a'本身，長度為1
    - 擴展偶數長度：檢查'a'和'd'，不匹配，無法擴展

   **中心點4（字符'd'）**：
    - 擴展奇數長度：只有'd'本身，長度為1
    - 擴展偶數長度：已達字符串末尾，無法擴展

3. **最終結果**：最長回文子串為"bab"，長度為3

這個方法的關鍵在於考慮了所有可能的中心點，包括單個字符（奇數長度回文）和相鄰字符對（偶數長度回文）。

# 6. Golang實現：

# 7. 複雜度分析：

## 時間複雜度
- 需要遍歷字符串中的每個位置作為可能的中心點，總共有 n 個位置。
- 對於每個中心點，執行兩次擴展：一次針對奇數長度回文，一次針對偶數長度回文。
- 每次擴展最多需要 O(n) 時間，因為最壞情況下可能從字符串中間擴展到兩端。
- 因此，總時間複雜度為 O(n) × O(n) = O(n²)。

## 空間複雜度
- 算法只使用了少量變數（start、maxLength 等）來跟踪最長回文子串的位置和長度。
- 沒有使用任何與輸入大小相關的額外空間。
- 因此，空間複雜度為 O(1)，即常數空間。

推導過程：
- 最外層for循環執行n次，每次循環執行兩次expandAroundCenter函數。
- expandAroundCenter函數在最壞情況下執行O(n)次（例如，當整個字符串都是相同字符時）。
- 因此，總的時間複雜度為O(n) × O(n) = O(n²)。

這個解法達到了當前問題條件下的最優時間複雜度。Manacher算法雖然可以達到O(n)時間複雜度，但實現更為複雜，而且當n不是特別大時（如本題最大為1000），中心擴展法的效率已經足夠好。

# 8. 優化與改進：

雖然中心擴展法已經相當高效，但仍有一些優化方向可以考慮：

## 1. 提前終止策略：
如果已經找到了一個長度為 L 的回文子串，那麼當處理到字符串後半部分時，如果剩餘未處理的字符數量小於 L/2，則可以提前終止搜索，因為不可能找到更長的回文子串了。

```go
// 在for循環中添加提前終止條件
if len(s) - i <= maxLength/2 {
    break
}
```

## 2. Manacher算法：
對於需要處理大量數據的場景，可以考慮實現Manacher算法，它具有O(n)的時間複雜度。該算法利用之前計算的回文信息來避免不必要的字符比較。

## 3. 預處理優化：
針對特殊情況，可以進行預處理：
- 如果字符串全部由相同字符組成，直接返回整個字符串
- 通過快速檢查確定字符串中是否存在長度大於1的回文

## 相關問題：
- LeetCode 647: 回文子串的數量 (Palindromic Substrings)
- LeetCode 516: 最長回文子序列 (Longest Palindromic Subsequence)
- LeetCode 214: 最短回文串 (Shortest Palindrome)

這些問題都與回文相關，掌握了中心擴展法和動態規劃的思想後，解決這些問題會更加容易。

# 9. 測試策略：



設計了全面的測試策略來驗證算法的正確性和效率。測試用例涵蓋了各種情況：

1. **基本測試用例**：
    - 來自問題描述的示例
    - 有多個解的情況（"babad" → "bab"或"aba"）

2. **邊界情況**：
    - 單個字符
    - 兩個相同字符
    - 兩個不同字符
    - 全部相同字符的字符串

3. **特殊位置測試**：
    - 回文在字符串開頭
    - 回文在字符串結尾
    - 回文在字符串中間

4. **多重回文測試**：
    - 字符串包含多個不同長度的回文

5. **性能測試**：
    - 長字符串（接近約束限制的1000字符）

由於某些情況下可能有多個正確答案（例如，"babad"的答案可以是"bab"或"aba"），不僅檢查結果是否與預期完全匹配，還確保結果是回文且長度與預期相同。

這種測試策略確保了的解決方案在各種情況下都能正確運行，並能有效處理邊界情況和特殊輸入。它也有助於檢測潛在的性能問題，特別是對於接近約束限制的大型輸入。