# 1. Original Problem:

Given a string `s`, return the longest palindromic substring in `s`.

A palindrome is a string that reads the same backward as forward.

**Example 1:**
```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

**Example 2:**
```
Input: s = "cbbd"
Output: "bb"
```

**Constraints:**
- 1 <= s.length <= 1000
- s consists only of lowercase English letters.

# 1. 原題目：

給定一個字串 `s`，返回 `s` 中最長的回文子串。

回文是指從左向右讀和從右向左讀都相同的字序列。

**示例 1：**
```
輸入: s = "babad"
輸出: "bab"
解釋: "aba" 也是一個有效答案。
```

**示例 2：**
```
輸入: s = "cbbd"
輸出: "bb"
```

**約束條件：**
- 1 <= s.length <= 1000
- s 僅由小寫英文字母組成。

# 2. 問題理解：

這個問題要求在給定的字串中找出最長的回文子串。回文是從左到右讀和從右到左讀都一樣的字串。

**核心要點：**
- 需要找的是子串（連續字序列），而不是子序列
- 如果有多個同樣長度的回文子串，返回任意一個即可
- 字串僅包含小寫英文字母
- 字串長度最大為1000

**邊界情況：**
- 單個字：任何單個字都是回文
- 整個字串都相同：整個字串是回文
- 沒有長度大於1的回文：那麼答案是任意單個字

**主要挑戰：**
- 暴力檢查所有可能的子串是O(n³)時間複雜度，效率較低
- 需要找出一種有效方法來識別回文，避免重複計算

# 3. 視覺解釋：

# 4. 思考過程：

在解決最長回文子串問題時，有幾種不同的方法，來逐一探討：

## 方法一：暴力法
最直接的方法是檢查所有可能的子串，並驗證每個子串是否為回文。

**優點**：簡單易懂，容易實現。
**缺點**：時間複雜度為O(n³)，對於長度接近1000的字串效率很低。

## 方法二：動態規劃法
可以使用動態規劃來避免重複的回文檢查。定義 `DP[i][j]` 表示子串 `s[i...j]` 是否為回文。

**遞推關係**：
- `DP[i][i] = true`（單個字總是回文）
- `DP[i][i+1] = (s[i] == s[i+1])`（兩個相同字是回文）
- 對於長度大於2的子串：`DP[i][j] = (s[i] == s[j]) && DP[i+1][j-1]`

**時間複雜度**：O(n²)
**空間複雜度**：O(n²)

## 方法三：中心擴展法
回文串具有對稱性，因此可以從每個可能的"中心"開始，向兩側擴展，直到不再形成回文為止。

對於長度為n的字串，有2n-1個可能的中心點：
- n個單字中心（奇數長度回文）
- n-1個相鄰字對中心（偶數長度回文）

**時間複雜度**：O(n²)
**空間複雜度**：O(1)

## 方法四：Manacher算法
這是一個專門解決回文子串問題的高級算法，時間複雜度為O(n)。但由於實現較為複雜，對於本題的約束條件（最大長度1000），方法三已足夠高效。

**比較與選擇**：
- 考慮到實現難度和效率，中心擴展法是最佳選擇
- 雖然動態規劃和中心擴展法都是O(n²)時間複雜度，但中心擴展法不需要額外的O(n²)空間
- Manacher算法雖然更快，但實現複雜度高，不如中心擴展法直觀

因此，選擇中心擴展法作為本題的最優解法。

# 5. 最優解方案開發：

中心擴展法的核心思想是：對於每個可能的回文中心，嘗試向兩側擴展，尋找以該點為中心的最長回文子串。

讓以例子"babad"詳細演示整個過程：

1. **初始化**：`start = 0, maxLength = 1`（至少有一個字的回文）

2. **遍歷每個可能的中心點**：

   **中心點0（字'b'）**：
    - 擴展奇數長度：只有'b'本身，長度為1
    - 擴展偶數長度：檢查'b'和'a'，不匹配，無法擴展

   **中心點1（字'a'）**：
    - 擴展奇數長度：先是'a'本身，長度為1
        - 再檢查'b'和'b'，匹配！
        - 擴展到"bab"，長度為3，更新`start = 0, maxLength = 3`
    - 擴展偶數長度：檢查'a'和'b'，不匹配，無法擴展

   **中心點2（字'b'）**：
    - 擴展奇數長度：先是'b'本身，長度為1
        - 再檢查'a'和'a'，匹配！
        - 擴展到"aba"，長度為3，但與當前最大長度相同，不更新
    - 擴展偶數長度：檢查'b'和'a'，不匹配，無法擴展

   **中心點3（字'a'）**：
    - 擴展奇數長度：只有'a'本身，長度為1
    - 擴展偶數長度：檢查'a'和'd'，不匹配，無法擴展

   **中心點4（字'd'）**：
    - 擴展奇數長度：只有'd'本身，長度為1
    - 擴展偶數長度：已達字串末尾，無法擴展

3. **最終結果**：最長回文子串為"bab"，長度為3

這個方法的關鍵在於考慮了所有可能的中心點，包括單個字（奇數長度回文）和相鄰字對（偶數長度回文）。

# 6. Golang實現：

# 7. 複雜度分析：

## 時間複雜度
- 需要遍歷字串中的每個位置作為可能的中心點，總共有 n 個位置。
- 對於每個中心點，執行兩次擴展：一次針對奇數長度回文，一次針對偶數長度回文。
- 每次擴展最多需要 O(n) 時間，因為最壞情況下可能從字串中間擴展到兩端。
- 因此，總時間複雜度為 O(n) × O(n) = O(n²)。

## 空間複雜度
- 算法只使用了少量變數（start、maxLength 等）來跟蹤最長回文子串的位置和長度。
- 沒有使用任何與輸入大小相關的額外空間。
- 因此，空間複雜度為 O(1)，即常數空間。

推導過程：
- 最外層for循環執行n次，每次循環執行兩次expandAroundCenter函數。
- expandAroundCenter函數在最壞情況下執行O(n)次（例如，當整個字串都是相同字時）。
- 因此，總的時間複雜度為O(n) × O(n) = O(n²)。

這個解法達到了當前問題條件下的最優時間複雜度。Manacher算法雖然可以達到O(n)時間複雜度，但實現更為複雜，而且當n不是特別大時（如本題最大為1000），中心擴展法的效率已經足夠好。

# 8. 優化與改進：

雖然中心擴展法已經相當高效，但仍有一些優化方向可以考慮：

## 1. 提前終止策略：
如果已經找到了一個長度為 L 的回文子串，那麼當處理到字串後半部分時，如果剩餘未處理的字數量小於 L/2，則可以提前終止搜索，因為不可能找到更長的回文子串了。

```go
// 在for循環中添加提前終止條件
if len(s) - i <= maxLength/2 {
    break
}
```

## 2. Manacher算法：
對於需要處理大量數據的場景，可以考慮實現Manacher算法，它具有O(n)的時間複雜度。該算法利用之前計算的回文信息來避免不必要的字比較。

## 3. 預處理優化：
針對特殊情況，可以進行預處理：
- 如果字串全部由相同字組成，直接返回整個字串
- 通過快速檢查確定字串中是否存在長度大於1的回文

## 相關問題：
- LeetCode 647: 回文子串的數量 (Palindromic Substrings)
- LeetCode 516: 最長回文子序列 (Longest Palindromic Subsequence)
- LeetCode 214: 最短回文串 (Shortest Palindrome)

這些問題都與回文相關，掌握了中心擴展法和動態規劃的思想後，解決這些問題會更加容易。

# 9. 測試策略：



設計了全面的測試策略來驗證算法的正確性和效率。測試用例涵蓋了各種情況：

1. **基本測試用例**：
    - 來自問題描述的示例
    - 有多個解的情況（"babad" → "bab"或"aba"）

2. **邊界情況**：
    - 單個字
    - 兩個相同字
    - 兩個不同字
    - 全部相同字的字串

3. **特殊位置測試**：
    - 回文在字串開頭
    - 回文在字串結尾
    - 回文在字串中間

4. **多重回文測試**：
    - 字串包含多個不同長度的回文

5. **性能測試**：
    - 長字串（接近約束限制的1000字）

由於某些情況下可能有多個正確答案（例如，"babad"的答案可以是"bab"或"aba"），不僅檢查結果是否與預期完全匹配，還確保結果是回文且長度與預期相同。

這種測試策略確保了的解決方案在各種情況下都能正確運行，並能有效處理邊界情況和特殊輸入。它也有助於檢測潛在的性能問題，特別是對於接近約束限制的大型輸入。


# 從根本理解 Manacher 算法的設計原理

## 設計思想的演變

想像我們正在解決"尋找最長回文子串"這個問題時的思考過程：

### 階段一：原始問題與挑戰

最初，我們面臨兩個主要挑戰：
1. 回文檢查本身需要 O(n) 時間
2. 有太多可能的子串需要檢查 (O(n²))

組合起來，這導致了 O(n³) 的暴力解法，太慢了。

### 階段二：利用回文的對稱性質

注意一個重要特性：回文是對稱的。如果我知道 "aba" 是回文，我不需要逐字檢查 - 一旦知道了中心，其他就確定了。

這讓我們想到了中心擴展法：從每個可能的中心開始，向外擴展，直到不再形成回文。這將時間複雜度降到了 O(n²)。

### 階段三：尋找更多優化機會

在尋找更多優化時，我有了一個關鍵洞察：**回文中的回文也是回文**。

例如，在回文 "racecar" 中：
- "cec" 也是回文
- "a" 也是回文

如果我已經知道 "racecar" 是回文，我已經隱含地知道了許多其他回文的信息。**能否重用這些信息？**

### 階段四：對稱性的更深層次利用

我發現了一個驚人的性質：如果以 C 為中心的大回文包含了位置 i，那麼 i 關於 C 的鏡像位置 i' 也在這個回文內。**而且，以 i 和 i' 為中心的回文結構是相同的！**

這是 Manacher 算法的核心閃光點：**我可以重用已計算的回文信息，而不必每次都從頭開始**。

## 算法設計的基本原理

基於上述思考，Manacher 算法的設計有三個基本原理：

### 1. 信息重用原理

如果我已經確定了一個位置的回文半徑，當處理它的鏡像位置時，我可以重用這個信息。

例如，如果我知道位置 3 的回文半徑是 2，當我處理它關於中心的鏡像位置 7 時，我可以直接從半徑 2 開始擴展，而不是從 0 開始。

### 2. 範圍限制原理

重用信息時，我必須確保不超出已知的回文範圍。如果鏡像位置的回文延伸超出了大回文的邊界，我只能確定到邊界的部分是回文。

這就是為什麼我們取 `min(R-i, P[i_mirror])` - 我們只能確定這個範圍內的字是回文的。

### 3. 擴展更新原理

每次找到一個延伸更遠的回文，就更新中心和右邊界，為後續處理提供更多可重用的信息。

這三個原理組合起來，創造了一個優雅的算法，可以在線性時間內解決問題。

## 為什麼這個設計有效？

你可能會想：為什麼這個設計能保證 O(n) 的時間複雜度？

關鍵在於：**右邊界 R 只會向右移動，每個位置最多被擴展一次**。

雖然我們仍然需要擴展檢查，但由於重用了已知信息，大部分字比較被跳過了。具體來說：

1. 每次成功擴展，右邊界 R 就會增加 1
2. R 最多增加到 n（字串長度）
3. 因此，總擴展次數不會超過 O(n)

這就是為什麼 Manacher 算法能夠在線性時間內找到最長回文子串。

## 預處理的設計目的

至於預處理（在每個字間插入 #），這是為了統一處理奇偶長度的回文。

沒有這個處理，我們需要分別處理：
- 以單個字為中心的回文（奇數長度）
- 以兩個字之間為中心的回文（偶數長度）

通過插入 #，所有回文都變成了奇數長度，大大簡化了算法。

## 總結：設計的優雅之處

Manacher 算法的優雅之處在於：

1. 它不是創造了全新的解法，而是極大地優化了中心擴展法
2. 它充分利用了問題的固有結構（回文的對稱性）
3. 它重用了已計算的信息，避免了重複工作
4. 它通過簡單的預處理統一了不同情況的處理

這種"利用結構重用信息"的思想在很多高效算法中都能看到，是算法設計中的重要思維模式。

理解了這些基本原理，你應該能更好地掌握 Manacher 算法，甚至將類似的思考方式應用到其他問題上。

# 從問題到程式碼：如何構思出算法的實現

你提出了一個非常重要的問題，關於如何將算法思路轉化為具體的程式碼和變數。這是算法設計中最關鍵的一步，也是許多人學習算法時面臨的挑戰。讓我以 Manacher 算法為例，解釋這個從思路到程式碼的轉化過程。

## 識別需要的變數

當你面對一個問題時，確定需要哪些變數的步驟如下：

### 1. 確定你需要追蹤什麼信息

首先問自己：「為了解決這個問題，我需要知道哪些信息？」

對於尋找最長回文子串問題：
- 我需要知道每個位置為中心的回文半徑 → `P[]` 數組
- 我需要記住找到的最大回文 → `maxLen` 和 `centerIndex`

### 2. 確定優化所需的額外信息

然後問：「為了避免重複計算，我還需要追蹤什麼？」

對於 Manacher 算法：
- 我需要記住當前發現的最右回文的中心 → `C`
- 我需要記住這個回文的右邊界 → `R`

### 3. 整理變數的數據類型和初始值

最後，確定每個變數的數據類型和初始值：
- `P[]`：整數數組，初始全為 0
- `C`：整數，初始為 0
- `R`：整數，初始為 0
- `maxLen`：整數，初始為 0
- `centerIndex`：整數，初始為 0

## 將思路轉化為程式碼結構

一旦確定了需要的變數，下一步是將算法思路轉化為程式碼結構：

### 1. 主要步驟轉化為程式碼區塊

每個主要步驟轉化為一個程式碼區塊：
- 預處理字串 → 一個字串處理語句
- 遍歷每個位置 → 一個 for 循環
- 處理每個位置 → 循環內的程式碼
- 找出最大回文 → 另一個循環或處理邏輯
- 轉換回原始字串 → 最後的返回語句

### 2. 算法邏輯轉化為控制流結構

將邏輯判斷和操作轉化為條件語句和循環：
- 「如果位置在右邊界內」→ `if R > i`
- 「嘗試擴展回文」→ `for T[i+1+P[i]] == T[i-1-P[i]]`
- 「如果找到更遠的回文」→ `if i + P[i] > R`

## 案例分析：`if i + P[i] > R { C, R = i, i + P[i] }`

讓我們深入分析這行程式碼是如何從思想轉化而來的：

### 思路發展過程

1. **初始想法**：「當我找到一個新的、延伸更遠的回文時，我應該更新我的參考點」

2. **具體化這個想法**：
   - 「延伸更遠」意味著什麼？當前回文的右端超過了之前記錄的右邊界
   - 當前回文的右端是什麼？位置 `i` 加上回文半徑 `P[i]`
   - 之前的右邊界是什麼？變數 `R`

3. **轉化為條件**：「如果 `i + P[i]` 大於 `R`」→ `if i + P[i] > R`

4. **確定操作**：
   - 需要更新中心 → `C = i`
   - 需要更新右邊界 → `R = i + P[i]`

5. **整合為程式碼**：`if i + P[i] > R { C, R = i, i + P[i] }`

### 工作原理說明

這段程式碼的工作原理是：

1. `i + P[i]` 計算當前發現的回文的右邊界位置
2. 與已知的最右邊界 `R` 比較
3. 如果新發現的回文延伸得更遠，更新參考中心 `C` 和右邊界 `R`
4. 這樣，後續處理的位置就可以利用這個更大範圍內的對稱性

## 練習方法：從思路到程式碼的五步法

當你面對一個新問題時，可以嘗試這個五步法來構建程式碼：

1. **分解問題**：將問題拆分為小塊
   - 例如：預處理、計算回文半徑、找最大值、返回結果

2. **確定核心數據**：決定需要什麼變數
   - 例如：回文半徑數組、當前中心、右邊界等

3. **寫出核心邏輯**：先用偽程式碼表達主要邏輯
   ```
   對於每個位置 i：
     如果 i 在右邊界內，利用對稱性設置初始值
     嘗試擴展找到真正的回文半徑
     如果找到更大的回文，更新中心和右邊界
   ```

4. **細化控制結構**：將偽程式碼轉換為實際控制結構
   ```go
   for i := 1; i < n-1; i++ {
     if R > i {
       // 利用對稱性
     }
     // 擴展回文
     if i + P[i] > R {
       // 更新中心和右邊界
     }
   }
   ```

5. **實現細節**：填充每個控制結構中的具體程式碼
   ```go
   for i := 1; i < n-1; i++ {
     if R > i {
       P[i] = min(R-i, P[2*C-i])
     }
     for T[i+1+P[i]] == T[i-1-P[i]] {
       P[i]++
     }
     if i + P[i] > R {
       C, R = i, i + P[i]
     }
   }
   ```

這種方法可以幫助你將複雜的算法思路逐步細化為可執行的程式碼。

## 總結

將算法思路轉化為程式碼是一項需要練習的技能。關鍵步驟是：
1. 識別需要追蹤的信息，轉化為變數
2. 將主要步驟轉化為程式碼區塊
3. 將邏輯判斷轉化為控制流結構
4. 逐步細化，直到完成實現

透過這種方法，你可以更系統地將抽象算法思想轉化為具體的程式碼實現。隨著練習的增加，這個過程會變得越來越自然，你會開始直覺地知道需要哪些變數和控制結構來實現你的算法思想。