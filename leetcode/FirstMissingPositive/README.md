# First Missing Positive (#41) - LeetCode Solution

## 1. Original Problem

### English Version
Given an unsorted integer array `nums`, find the smallest missing positive integer.

You must implement an algorithm that runs in O(n) time and uses constant extra space.

**Example 1:**
```
Input: nums = [1,2,0]
Output: 3
```

**Example 2:**
```
Input: nums = [3,4,-1,1]
Output: 2
```

**Example 3:**
```
Input: nums = [7,8,9,11,12]
Output: 1
```

**Constraints:**
- 1 <= nums.length <= 5 * 10^5
- -2^31 <= nums[i] <= 2^31 - 1

### 繁體中文版本
給定一個未排序的整數數組 `nums`，找到最小的缺失正整數。

你必須實現一個在 O(n) 時間內運行並使用常數額外空間的算法。

**示例 1:**
```
輸入: nums = [1,2,0]
輸出: 3
```

**示例 2:**
```
輸入: nums = [3,4,-1,1]
輸出: 2
```

**示例 3:**
```
輸入: nums = [7,8,9,11,12]
輸出: 1
```

**約束條件:**
- 1 <= nums.length <= 5 * 10^5
- -2^31 <= nums[i] <= 2^31 - 1

## 2. 問題理解

### 核心要求與約束
- 需要找到最小的缺失正整數（即 1, 2, 3, ...中第一個不在數組中的數）
- 算法必須在 O(n) 時間內運行
- 算法必須使用常數額外空間（即 O(1) 空間複雜度）
- 輸入數組可能包含負數、零和重複值

### 輸入/輸出特性
- 輸入：一個整數數組，可能包含任何範圍的整數
- 輸出：最小的缺失正整數（永遠是正數）
- 如果所有正整數 1 到 n 都在數組中，那麼輸出應該是 n+1

### 可能的難點和關鍵挑戰
1. 常數空間限制意味著不能使用哈希表或額外數組
2. O(n) 時間複雜度限制意味著不能使用排序算法（通常是 O(n log n)）
3. 處理負數和超出數組大小的正數
4. 原地修改數組而不丟失信息

## 3. 視覺解釋

讓以示例 2 來可視化問題和解決方案：
```
輸入: nums = [3,4,-1,1]
```

關鍵洞察：在長度為 n 的數組中，最小缺失正整數一定在範圍 [1, n+1] 內。為什麼？因為最壞情況下，數組包含了 1 到 n 的所有正整數，那麼答案就是 n+1。

### 解決方案流程
1. **關鍵洞察**：在長度為 n 的數組中，最小缺失正整數只能在 [1, n+1] 範圍內
2. **使用索引作標記**：可以使用數組本身作為標記系統，通過將對應位置的元素標記為負數
3. **尋找未標記的位置**：最後，第一個沒有被標記的位置 i，對應的答案就是 i+1

以示例 [3,4,-1,1] 演示：

1. 數組長度為 4，所以只關心數值在 [1,4] 範圍內的元素
2. 遍歷數組：
    - 值 3：標記 nums[2] 為負值 → [-1,-1,**-1**,1]
    - 值 4：超出關心的範圍，忽略
    - 值 -1：負數，忽略
    - 值 1：標記 nums[0] 為負值 → [**-1**,4,-1,1]
3. 再次遍歷數組，發現 nums[1] 是第一個正數，對應的缺失正整數為 1+1 = 2

## 4. 思考過程

### 潛在解決方案策略
讓考慮幾種可能的解決方案：

#### 方法 1：排序後查找
最直觀的方法是先排序數組，然後線性掃描尋找第一個缺失的正整數。
- 優點：簡單直觀
- 缺點：排序需要 O(n log n) 時間，不符合 O(n) 的要求

#### 方法 2：使用哈希表
將所有正整數存入哈希表，然後從 1 開始逐個檢查。
- 優點：時間複雜度為 O(n)
- 缺點：需要 O(n) 額外空間，不符合 O(1) 空間的要求

#### 方法 3：原地標記（最優解）
利用數組索引與數值的對應關係，直接在數組上標記。
- 優點：時間複雜度 O(n)，空間複雜度 O(1)
- 缺點：需要謹慎處理，避免數據丟失

### 最適方法分析
「原地標記」方法是最適合的，因為：
1. 它完全符合問題的時間和空間複雜度要求
2. 利用了一個關鍵洞察：長度為 n 的數組中，缺失的最小正整數一定在 [1, n+1] 範圍內
3. 通過巧妙地使用元素值的正負號作為標記，避免了使用額外空間

### 識別類似問題模式
這種「原地標記」技術在其他問題中也很有用：
- 當問題在有限範圍內尋找缺失/重複元素時
- 當空間複雜度嚴格限制為 O(1) 時
- 當可以使用原數組的索引作為哈希表的「鍵」時

## 5. 最優解決方案開發

### 從簡單到最優
讓從概念上理解這個問題：
1. 如果數組包含所有從 1 到 n 的正整數，那麼答案是 n+1
2. 否則，答案是第一個缺失的正整數（一定在 1 到 n+1 之間）

最優解決方案利用以下策略：
1. 因為只關心 1 到 n 的正整數，將數組值視為索引來標記已存在的數
2. 對每個在[1,n]範圍內的數 x，將第 (x-1) 個位置的數標記為負數
3. 遍歷標記後的數組，第一個正數的索引 i 對應的缺失值為 i+1

### 具體步驟示例
以 [3,4,-1,1] 為例：

**步驟 1**：忽略無效數字（<= 0 或 > n）
- 數組長度 n = 4，只關心 [1,4] 範圍內的數

**步驟 2**：標記有效數字
- 遇到 3：標記 nums[2] 為負數（如果它已經是負數，保持不變）
    - 數組變為：[3,4,**-1**,1]
- 遇到 4：標記 nums[3] 為負數
    - 數組變為：[3,4,-1,**-1**]
- 遇到 -1：無效數字，跳過
- 遇到 1：標記 nums[0] 為負數
    - 數組變為：[**-3**,4,-1,-1]

**步驟 3**：找到第一個未標記的位置
- 遍歷數組 [-3,4,-1,-1]
- nums[1] = 4 是第一個正數
- 答案是 1+1 = 2

### 關鍵洞察
1. 只需要關注 [1,n] 範圍內的數字
2. 可以用數組元素的正負號來標記數字是否存在
3. 對於重複的數字，要確保不會重複標記導致符號翻轉

## 7. 複雜度分析

### 時間複雜度
- 第一次遍歷：O(n) - 標記非正數
- 第二次遍歷：O(n) - 標記有效範圍內的數字
- 第三次遍歷：O(n) - 尋找第一個未標記的位置
- 總時間複雜度：O(n)

### 空間複雜度
- 只使用了常數級別的額外變量
- 所有操作都是原地進行的
- 總空間複雜度：O(1)

### 為什麼無法進一步改進
- 時間複雜度已經是最優的 O(n)，至少需要讀取每一個元素
- 空間複雜度 O(1) 也是最優的，因為至少需要存儲結果
- 對數組進行了三次線性掃描，每次都執行簡單操作，常數因子已經很小

## 8. 優化與改進

### 潛在優化方向
1. **單次遍歷優化**：理論上可能，但會使代碼更複雜且難以理解
2. **避免修改原數組**：如果需要保持原數組不變，可以使用 O(n) 空間的方法

### 不同解決方案比較
| 方法 | 時間複雜度 | 空間複雜度 | 優點 | 缺點 |
|------|------------|------------|------|------|
| 排序 | O(n log n) | O(1) | 簡單直觀 | 不符合時間要求 |
| 哈希表 | O(n) | O(n) | 直接且易於理解 | 不符合空間要求 |
| 原地標記 | O(n) | O(1) | 完全符合要求 | 修改了原數組 |

### 進一步學習建議
1. 學習更多「原地修改」技巧的問題，如：
    - LeetCode #268: Missing Number
    - LeetCode #287: Find the Duplicate Number
2. 深入研究如何在空間受限的情況下創造性地使用數據結構
3. 練習如何識別可以使用陣列索引作為哈希映射的問題

### 測試案例說明

1. **基本測試**：
    - 驗證算法在常見輸入下的正確性
    - 包含問題描述中的示例

2. **邊緣情況**：
    - 數組只有一個元素
    - 數組只包含負數或零
    - 空數組 (雖然約束條件指定最小長度為 1)

3. **特殊情況**：
    - 數組包含重複元素
    - 數組包含所有從 1 到 n 的正整數
    - 數組中的元素順序不同

測試策略確保了解決方案在各種可能的輸入下都能正確工作，特別關注了容易出錯的邊緣情況。

## 總結

「First Missing Positive」是一個經典問題，乍看簡單，但要在線性時間和常數空間內解決卻很有挑戰性。其核心思想是利用數組索引與數值的對應關係，通過原地標記的方式避免使用額外空間。這種技巧在處理數組中的缺失/重複元素問題時非常有用。

解決這個問題的過程讓學到：
1. 如何識別問題的關鍵限制和可能的突破口
2. 如何創造性地使用現有數據結構（數組）作為標記系統
3. 如何在不使用額外空間的情況下處理標記和查找

這種「原地標記」的思想可以應用到許多其他問題中，是算法設計中的一個重要技巧。