## 循環排序解法分析

這個解法的核心思想是：**把每個在範圍[1,n]內的數放到它應該在的位置上**（數字k應該放在索引k-1的位置）。

### 詳細步驟解釋

```go
func firstMissingPositive(nums []int) int {
    // 第一步：將每個數字放到"正確"的位置上
    for i := range nums {
        // 當數字在有效範圍內且不在正確位置時進行交換
        for nums[i] > 0 && nums[i] <= len(nums) && nums[nums[i] - 1] != nums[i] {
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
        }
    }
    
    // 第二步：找出第一個不在正確位置上的數
    for i := range nums {
        if nums[i] != i + 1 {
            return i + 1
        }
    }
    
    // 如果所有數都在正確位置，返回n+1
    return len(nums) + 1
}
```

### 解法追蹤示例

讓以 `[3, 4, -1, 1]` 為例：

1. **第一輪循環(i=0)**:
    - nums[0] = 3，應該在索引2的位置
    - 交換 nums[0] 和 nums[2]：`[-1, 4, 3, 1]`
    - 現在 nums[0] = -1，不符合內部循環條件，進入下一個i

2. **第一輪循環(i=1)**:
    - nums[1] = 4，應該在索引3的位置
    - 交換 nums[1] 和 nums[3]：`[-1, 1, 3, 4]`
    - 現在 nums[1] = 1，它應該在索引0的位置
    - 再次交換 nums[1] 和 nums[0]：`[1, -1, 3, 4]`
    - 現在 nums[1] = -1，不符合內部循環條件，進入下一個i

3. **第一輪循環(i=2,3)**:
    - nums[2] = 3 已經在正確位置上
    - nums[3] = 4 已經在正確位置上

4. **排序完成後的數組**：`[1, -1, 3, 4]`

5. **第二輪循環**:
    - i=0: nums[0] = 1 = i+1 ✓
    - i=1: nums[1] = -1 ≠ i+1=2 ✗
    - 返回 i+1 = 2 作為答案

### 複雜度分析

1. **時間複雜度**: O(n)
    - 雖然有嵌套循環，但每個元素最多被交換n次，總的交換次數不超過2n
    - 實際上，內部循環的總執行次數是有限的，因為每次交換都會把一個元素放到正確位置

2. **空間複雜度**: O(1)
    - 只使用了常數級別的額外空間

### 與前一個解法比較

1. **標記法（前一個解法）**:
    - 使用數字的正負號來標記數字的存在
    - 不改變數組的相對順序
    - 需要三次遍歷數組

2. **循環排序法（這個解法）**:
    - 實際重排數組，使每個數字都在"正確"的位置上
    - 可能進行更多的交換操作
    - 需要兩次遍歷數組
    - 代碼更簡潔

兩種方法都是 O(n) 時間和 O(1) 空間的最優解，選擇哪一個取決於個人偏好和具體場景。如果原始數組的順序很重要或不應被修改，那麼標記法更好；如果交換操作成本較低，循環排序法可能更簡潔直觀。

這個循環排序的解法確實非常優雅，尤其是第二步檢查時非常直觀：如果數組已正確排序，第一個不在正確位置上的索引i就對應著缺失的數字i+1。