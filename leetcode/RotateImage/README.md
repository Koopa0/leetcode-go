# Rotate Image

## 1. Original Problem:

You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:
```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

Example 2:
```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

Constraints:
- n == matrix.length == matrix[i].length
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000

## 旋轉圖像

給你一個 n × n 的二維矩陣表示一個圖像，請你將圖像順時針旋轉 90 度。

你必須在原地旋轉圖像，這意味著你需要直接修改輸入的二維矩陣。請不要使用另一個矩陣來旋轉圖像。

示例 1：
```
輸入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
輸出：[[7,4,1],[8,5,2],[9,6,3]]
```

示例 2：
```
輸入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
輸出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

限制：
- n == matrix.length == matrix[i].length
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000

## 2. 初始問題解析與心智建模

當我們第一次看到這個問題時，我們需要理解「將圖像順時針旋轉90度」意味著什麼。讓我們通過觀察示例來進行理解：

以示例1為例：
```
原始矩陣:       旋轉後:
[1, 2, 3]      [7, 4, 1]
[4, 5, 6]  ->  [8, 5, 2]
[7, 8, 9]      [9, 6, 3]
```

從這個例子中，我們可以觀察到一些模式：
- 原矩陣的第一列(row)變成了新矩陣的最後一列(column)（但順序相反）
- 原矩陣的第二列變成了新矩陣的倒數第二列
- 原矩陣的第三列變成了新矩陣的第一列

更精確地說，對於位置 (i, j) 的元素，旋轉後的新位置是 (j, n-1-i)。

注意：問題強調要「原地」旋轉圖像，這意味著我們不能使用額外的二維矩陣來存儲旋轉結果，必須直接修改輸入矩陣。

## 3. 問題理解與核心挑戰

核心要求：
- 將 n×n 矩陣順時針旋轉90度
- 必須原地修改，不能使用額外矩陣

主要挑戰：
1. 如何在不使用額外空間的情況下進行旋轉
2. 如何設計交換元素的方式以避免數據丟失
3. 理解原始位置與旋轉後位置之間的數學關係

轉換為計算問題：對於矩陣中位置 (i, j) 的元素，旋轉後的新位置是 (j, n-1-i)。但是，如果我們直接按順序修改每個元素，則已修改的元素會影響後續的旋轉操作。

邊界情況：
- 1×1 矩陣（旋轉後保持不變）
- 偶數大小與奇數大小的矩陣（中心點的處理有所不同）

## 4. 視覺問題表示

讓我們通過視覺化來理解矩陣旋轉。以3×3矩陣為例：

```
[1, 2, 3]    旋轉90度    [7, 4, 1]
[4, 5, 6]  ---------->  [8, 5, 2]
[7, 8, 9]                [9, 6, 3]
```

觀察元素的移動：
- (0,0) 中的 1 移動到 (0,2)
- (0,1) 中的 2 移動到 (1,2)
- (0,2) 中的 3 移動到 (2,2)
- ...等等

這形成了一個循環模式，對於每四個位置：
(i, j) → (j, n-1-i) → (n-1-i, n-1-j) → (n-1-j, i) → (i, j)

例如，在3×3矩陣中：
(0,0) → (0,2) → (2,2) → (2,0) → (0,0)

我們可以將這種旋轉視為「分層」進行，從外層向內層處理：

```
外層:    [1, 2, 3]    內層:    [ ,  , ]
         [4,  , 6]             [ , 5, ]
         [7, 8, 9]             [ ,  , ]
```

## 5. 問題模式識別

這是一個矩陣變換問題，具體是幾何旋轉問題。在算法問題中，矩陣變換是一種常見模式，包括：
- 矩陣旋轉（90度、180度、270度）
- 矩陣轉置（行變列，列變行）
- 矩陣鏡像（水平或垂直翻轉）

觀察示例後，我們可以識別出一個關鍵特性：90度旋轉可以分解為「矩陣轉置」加「水平翻轉（或垂直翻轉）」兩個操作。

這個問題特徵：
- 空間限制（原地操作）
- 一對多的元素映射關係（一個位置的元素影響多個位置）
- 循環依賴問題（修改一個元素會影響到其他元素的原始位置）

## 6. 策略性問題解決框架

對於矩陣旋轉問題，有兩種主要解決方法：

1. **分層旋轉法**：
    - 將矩陣視為一系列嵌套的圓環
    - 從外層向內層處理
    - 每層中，以組為單位旋轉四個元素

2. **數學變換法**：
    - 利用線性代數的性質
    - 將90度旋轉分解為兩個基本操作：轉置和反射
    - 先轉置矩陣（交換行和列），再水平反射（反轉每一行）

解決此類問題的思維框架：
1. 觀察初始狀態和目標狀態之間的數學關係
2. 尋找可能的分解步驟（將複雜變換分解為簡單變換）
3. 確保操作順序不會造成數據丟失

## 7. 算法設計

我們將採用數學變換法，因為它更直觀且易於實現：

1. 首先對矩陣進行轉置（交換行和列）：
   ```
   [1, 2, 3]    轉置後    [1, 4, 7]
   [4, 5, 6]  -------->  [2, 5, 8]
   [7, 8, 9]              [3, 6, 9]
   ```

2. 然後水平反射矩陣（反轉每一行）：
   ```
   [1, 4, 7]    反射後    [7, 4, 1]
   [2, 5, 8]  -------->  [8, 5, 2]
   [3, 6, 9]              [9, 6, 3]
   ```

偽代碼：
```
function rotate(matrix):
    n = matrix.length
    
    // 步驟1：轉置矩陣
    for i from 0 to n-1:
        for j from i to n-1:
            swap matrix[i][j] with matrix[j][i]
    
    // 步驟2：水平反射
    for i from 0 to n-1:
        for j from 0 to n/2-1:
            swap matrix[i][j] with matrix[i][n-1-j]
```

## 8. 視覺化解釋

讓我們以示例1的矩陣為例，視覺化整個過程：

原始矩陣：
```
[1, 2, 3]
[4, 5, 6]
[7, 8, 9]
```

步驟1：矩陣轉置（交換行和列）

轉置過程中的交換：
- 交換(0,1)和(1,0)：1和4交換
- 交換(0,2)和(2,0)：3和7交換
- 交換(1,2)和(2,1)：6和8交換

轉置後：
```
[1, 4, 7]
[2, 5, 8]
[3, 6, 9]
```

步驟2：水平反射（每行反轉）

反轉過程：
- 第1行：[1,4,7] → [7,4,1]
- 第2行：[2,5,8] → [8,5,2]
- 第3行：[3,6,9] → [9,6,3]

最終結果：
```
[7, 4, 1]
[8, 5, 2]
[9, 6, 3]
```

這正是我們想要的順時針旋轉90度的結果！

## 9. 解決方案發展歷程

1. **初始解決思路**：
   最直觀的方法是創建一個新矩陣，按照旋轉關係填充元素。但這違反了「原地修改」的要求。

2. **問題關鍵點發現**：
   觀察元素移動規律，發現存在循環依賴問題。直接按順序修改會破壞尚未處理的元素的原始位置。

3. **解決方法改進**：
    - 考慮分層處理法：把矩陣分成多個同心環，逐環處理
    - 考慮數學變換法：將旋轉分解為基本操作

4. **最終解決方案**：
   選擇數學變換法，因為它更優雅且易於理解：
    - 轉置：交換matrix[i][j]和matrix[j][i]
    - 水平反射：交換matrix[i][j]和matrix[i][n-1-j]

每一步的操作都能獨立完成，不會相互干擾，避免了原地修改時的數據丟失問題。

## 10. 實例演算步驟

以示例1的3×3矩陣為例：`[[1,2,3],[4,5,6],[7,8,9]]`

**步驟1：矩陣轉置**
- i=0, j=0：對角線元素，不需交換
- i=0, j=1：交換(0,1)和(1,0)的元素
    - 交換2和4：矩陣變為 [[1,4,3],[2,5,6],[7,8,9]]
- i=0, j=2：交換(0,2)和(2,0)的元素
    - 交換3和7：矩陣變為 [[1,4,7],[2,5,6],[3,8,9]]
- i=1, j=1：對角線元素，不需交換
- i=1, j=2：交換(1,2)和(2,1)的元素
    - 交換6和8：矩陣變為 [[1,4,7],[2,5,8],[3,6,9]]
- i=2, j=2：對角線元素，不需交換

轉置後的矩陣：`[[1,4,7],[2,5,8],[3,6,9]]`

**步驟2：水平反射**
- i=0（第一行）：
    - j=0：交換(0,0)和(0,2)的元素
        - 交換1和7：第一行變為 [7,4,1]
- i=1（第二行）：
    - j=0：交換(1,0)和(1,2)的元素
        - 交換2和8：第二行變為 [8,5,2]
- i=2（第三行）：
    - j=0：交換(2,0)和(2,2)的元素
        - 交換3和9：第三行變為 [9,6,3]

最終結果：`[[7,4,1],[8,5,2],[9,6,3]]`

這就完成了矩陣的順時針旋轉90度！

## 11. Golang實現

## 12. 實現執行步驟解析

讓我們使用示例1的矩陣 `[[1,2,3],[4,5,6],[7,8,9]]` 追蹤Golang代碼的執行過程：

初始狀態：
```
matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
n = 3
```

**步驟1：轉置矩陣**
```go
for i := 0; i < n; i++ {
    for j := i; j < n; j++ {
        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    }
}
```

執行過程：
- i=0, j=0：交換matrix[0][0]和matrix[0][0]，保持不變（對角線元素）
- i=0, j=1：交換matrix[0][1]和matrix[1][0]，即交換2和4
    - 矩陣變為 [[1,4,3],[2,5,6],[7,8,9]]
- i=0, j=2：交換matrix[0][2]和matrix[2][0]，即交換3和7
    - 矩陣變為 [[1,4,7],[2,5,6],[3,8,9]]
- i=1, j=1：交換matrix[1][1]和matrix[1][1]，保持不變（對角線元素）
- i=1, j=2：交換matrix[1][2]和matrix[2][1]，即交換6和8
    - 矩陣變為 [[1,4,7],[2,5,8],[3,6,9]]
- i=2, j=2：交換matrix[2][2]和matrix[2][2]，保持不變（對角線元素）

轉置後的矩陣：
```
matrix = [
  [1, 4, 7],
  [2, 5, 8],
  [3, 6, 9]
]
```

**步驟2：水平反射**
```go
for i := 0; i < n; i++ {
    for j := 0; j < n/2; j++ {
        matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
    }
}
```

執行過程：
- i=0（第一行）：
    - j=0：交換matrix[0][0]和matrix[0][2]，即交換1和7
        - 第一行變為 [7,4,1]
- i=1（第二行）：
    - j=0：交換matrix[1][0]和matrix[1][2]，即交換2和8
        - 第二行變為 [8,5,2]
- i=2（第三行）：
    - j=0：交換matrix[2][0]和matrix[2][2]，即交換3和9
        - 第三行變為 [9,6,3]

最終結果：
```
matrix = [
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

這個實現的精髓在於：
1. 通過「j從i開始」的遍歷方式，確保只處理矩陣的上三角部分，避免重複交換
2. 水平反射時，只需要交換到矩陣中間位置（n/2）即可完成整行的反轉

## 13. 複雜度分析

**時間複雜度分析**：
- 步驟1（轉置矩陣）：
    - 外層循環執行n次
    - 內層循環平均執行(n+1)/2次
    - 總操作數約為n*(n+1)/2，即O(n²)
- 步驟2（水平反射）：
    - 外層循環執行n次
    - 內層循環執行n/2次
    - 總操作數為n*n/2，即O(n²)
- 總體時間複雜度：O(n²)

**空間複雜度分析**：
- 僅使用常數級別的額外變數（如循環變數i、j等）
- 不需要額外的矩陣或數組
- 空間複雜度：O(1)

這個解決方案已經達到了時間和空間的最優解，因為：
- 要旋轉矩陣，至少需要訪問所有n²個元素一次，所以時間複雜度的下限是O(n²)
- 問題要求原地旋轉，所以空間複雜度O(1)已經是最優

## 14. 優化與改進

**已有方案的優點**：
- 時間複雜度最優：O(n²)
- 空間複雜度最優：O(1)
- 代碼簡潔明了，易於理解

**可能的替代解決方案**：
1. **分層旋轉法**：
    - 從外層向內層處理矩陣
    - 每次旋轉四個角落的元素
    - 時間複雜度和空間複雜度與當前解決方案相同
    - 但實現較為複雜，容易出錯

2. **一次性四點交換法**：
    - 直接計算旋轉後的四個位置，一次性完成四個點的交換
    - 避免了兩步操作（轉置+反射）
    - 時間和空間複雜度與當前解決方案相同
    - 但計算旋轉位置的邏輯較為複雜

**進一步學習方向**：
- 研究矩陣的其他變換方法（如180度旋轉、270度旋轉等）
- 探索三維矩陣的旋轉算法
- 學習矩陣相關的線性代數知識，增強對矩陣操作的理解

## 15. 通用解題智慧

本問題帶給我們的核心啟示：
1. **複雜問題分解**：將90度旋轉分解為轉置和反射兩個基本操作，大大簡化了問題
2. **尋找數學關係**：發現原始位置和旋轉後位置之間的關係是解決問題的關鍵
3. **考慮操作順序**：在原地修改時，操作順序至關重要，需要避免數據覆蓋

這些思維模式可應用於其他算法問題：
- 當面對複雜的數據變換時，嘗試將其分解為多個簡單操作
- 尋找問題中的數學模式和規律
- 在設計算法時，要特別注意操作順序和數據依賴關係

提高算法直覺的建議：
- 練習可視化數據結構和算法過程
- 培養對數學關係的敏感度
- 通過手動模擬算法執行過程來加深理解

## 16. 測試策略

1. **基本功能測試**：
    - 3×3矩陣（來自問題示例1）
    - 4×4矩陣（來自問題示例2）

2. **邊界情況**：
    - 1×1矩陣（最小尺寸）
    - 2×2矩陣（偶數尺寸）

3. **特殊值測試**：
    - 包含負數的矩陣
    - 全零矩陣

測試策略的幾個重點：
1. 為每個測試案例提供清晰的名稱和描述
2. 在測試執行前創建輸入矩陣的深拷貝，避免原始測試數據被修改
3. 使用reflect.DeepEqual進行二維矩陣的比較
4. 測試失敗時提供詳細的錯誤信息，包括輸入、期望輸出和實際輸出
