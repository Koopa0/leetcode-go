# LeetCode 75: 顏色排序 (Sort Colors)

## 1. 問題定義

### 原始問題 (英文)
```
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.
```

### 問題翻譯 (繁體中文)
```
給定一個包含 n 個物件的陣列 nums，物件顏色為紅色、白色或藍色。請將陣列中的物件按照紅色、白色、藍色的順序進行原地排序，使得相同顏色的物件相鄰。

我們將使用整數 0、1、2 分別代表紅色、白色和藍色。

你必須在不使用程式語言內建的排序函式的情況下解決此問題。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: nums = [2,0,2,1,1,0]
  輸出: [0,0,1,1,2,2]
  ```
- **範例 2:**
  ```
  輸入: nums = [2,0,1]
  輸出: [0,1,2]
  ```

- **限制條件:**
    - n == nums.length
    - 1 <= n <= 300
    - nums[i] 的值只能是 0、1 或 2

## 2. 問題理解

### 初始反應與心智模型
- 這是一個經典的荷蘭國旗問題（Dutch National Flag Problem），由 Edsger W. Dijkstra 提出
- 我們需要將三種顏色（用數字表示）進行排序，且必須是原地排序（in-place）
- 初看可能會想用常見排序算法，但由於只有三種值，可能有更高效的方法
- 由於數值範圍有限，可以嘗試使用計數排序的思路

### 問題分解
- 核心子問題：如何在單次遍歷中將三種元素按順序排列
- 需要追蹤三種顏色的邊界位置
- 需要維持原地排序的特性，即空間複雜度為 O(1)
- 關鍵操作是元素的交換

### 視覺表示
```
初始狀態: [2, 0, 2, 1, 1, 0]
          ↑
         current

我們設置三個指針：
- left: 指向 0 (紅色) 區域的右邊界
- current: 當前處理的元素
- right: 指向 2 (藍色) 區域的左邊界

[2, 0, 2, 1, 1, 0]
 ↑        ↑     ↑
left    current right

排序過程會將陣列分為三個區域：
- [0...left-1]: 全部是 0 (紅色)
- [left...right-1]: 全部是 1 (白色)
- [right...n-1]: 全部是 2 (藍色)
```

## 3. 模式識別與知識映射

### 算法模式分類
- 此問題屬於以下算法模式:
    - [x] 陣列/字串操作
    - [x] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [x] 排序算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 問題本質是排序問題，但具有特殊性質（只有三種值）
    - 需要使用指針技巧在陣列上進行原地操作
    - 這是一個經典的分區問題，類似於快速排序中的分區操作

### 知識連接
- 涉及的基本CS概念：陣列操作、指針操作、原地算法設計
- 與快速排序中的分區（partition）操作相關
- 需要應用分治的思想，但實現方式更為特殊

### 相似問題比較
- LeetCode 215: Kth Largest Element in an Array（快速選擇算法）
- LeetCode 283: Move Zeroes（移動特定元素）
- LeetCode 905: Sort Array By Parity（按奇偶性排序）
- 這些問題都涉及到陣列中元素的重新排列，但本題特殊之處在於處理三種顏色而不是兩種

## 4. 算法直覺發展

### 直覺建立
- 由於只有三種值，我們可以用計數法：先統計每種顏色的數量，再重建陣列
- 另一種更優雅的方法是三路快排（Three-way Partitioning）的思想
- 如果把紅色（0）放在左側，藍色（2）放在右側，則白色（1）自然會在中間

### 多角度思考
- 從計數排序角度：簡單但需要兩次遍歷
- 從分區排序角度：可以在一次遍歷中完成，但實現較複雜
- 從指針操作角度：使用三個指針（左、中、右）可以高效地解決問題

## 5. 解決方案開發歷程

### 方法 1: 計數排序

#### 思考過程
- 計數排序是處理有限範圍整數的有效方法
- 由於只有 0、1、2 三種值，我們可以輕鬆統計每種顏色的數量
- 然後根據計數重建陣列

#### 算法設計
```
1. 統計陣列中 0、1、2 的出現次數
2. 按照順序重寫陣列：先放入所有的 0，再放入所有的 1，最後放入所有的 2
```

#### 實現細節
- 使用固定大小的陣列進行計數，適合於數值範圍小的情況
- 遍歷陣列兩次：一次用於計數，一次用於重建
- 此方法簡單易懂，適合作為初始解法

#### 複雜度分析
- **時間複雜度**: O(n) — 需要遍歷陣列兩次，但次數為常數
- **空間複雜度**: O(1) — 只使用了固定大小的額外空間（計數陣列）

#### 解法評估
- 優點：簡單易懂，容易實現
- 缺點：需要兩次遍歷，不是單次遍歷的解法
- 在面試中可接受，但可能被要求優化為單次遍歷的解法

### 方法 2: 三路快排（Three-way Partitioning）

#### 關鍵洞察
- 計數排序需要兩次遍歷，效率不是最佳
- 我們可以使用三路快排的思想，在單次遍歷中完成排序
- 使用三個指針來維護三個區域：小於（紅色）、等於（白色）、大於（藍色）

#### 優化策略
```
使用三個指針：
- left: 紅色區域的右界（下一個紅色應放入的位置）
- current: 當前處理的元素
- right: 藍色區域的左界（下一個藍色應放入的位置）

遍歷時：
1. 如果當前元素是 0（紅色），將其與 left 指針處的元素交換，並將 left 和 current 都向右移動
2. 如果當前元素是 1（白色），僅將 current 向右移動
3. 如果當前元素是 2（藍色），將其與 right 指針處的元素交換，並將 right 向左移動（current 不移動，因為需要再次檢查交換後的元素）
```

#### 實現改進
- 單次遍歷完成排序，不需要額外的空間
- 使用指針技巧，保證原地排序
- 特別注意處理藍色元素時 current 指針不前進的細節

#### 複雜度分析
- **時間複雜度**: O(n) — 只需一次遍歷，每個元素最多被訪問/移動常數次
- **空間複雜度**: O(1) — 只使用了常數額外空間

#### 解法評估
- 優點：單次遍歷，原地排序，最優的時間和空間複雜度
- 缺點：實現較為複雜，需要小心處理指針移動
- 這是面試中的理想解法，體現了對算法的深入理解

### 方法 3: 雙指針技巧

#### 突破性思考
- 可以將問題簡化為兩次分區操作
- 第一次將所有的 0 移到前面
- 第二次將所有的 1 移到 0 之後的位置

#### 最優算法
```
1. 使用 p0 指針跟踪所有 0 應該放置的位置
2. 使用 p1 指針跟踪所有 1 應該放置的位置（p1 >= p0）
3. 遍歷陣列，遇到 0 時，與 p0 處交換，並同時更新 p0 和 p1
4. 遇到 1 時，與 p1 處交換，並更新 p1
```

#### 實現卓越性
- 這個方法也是單次遍歷，原地排序
- 比三路快排的實現稍微直觀一些
- 特別注意處理 p0 < p1 時的額外交換操作

#### 複雜度分析
- **時間複雜度**: O(n) — 單次遍歷，每個元素最多被移動常數次
- **空間複雜度**: O(1) — 只使用常數額外空間

#### 從暴力到最優的思考演化
- 暴力解法考慮了計數排序，需要兩次遍歷
- 優化方法使用三路快排，單次遍歷中處理三種顏色
- 最優解法使用雙指針技巧，將問題轉化為兩次分區操作
- 這反映了從基本排序到特殊情況優化的思考過程

## 6. 範例演算與 Go 實現

### 完整範例追蹤
使用最優解法追蹤輸入: [2,0,2,1,1,0]

1. 初始狀態:
    - 輸入: `[2,0,2,1,1,0]`
    - p0 = 0, p1 = 0, i = 0

2. i = 0 時:
    - nums[0] = 2，不做任何操作
    - p0 = 0, p1 = 0, i = 1

3. i = 1 時:
    - nums[1] = 0，交換 nums[1] 和 nums[p0]: [0,2,2,1,1,0]
    - 由於 p0 = p1，所以不需要額外交換
    - p0 = 1, p1 = 1, i = 2

4. i = 2 時:
    - nums[2] = 2，不做任何操作
    - p0 = 1, p1 = 1, i = 3

5. i = 3 時:
    - nums[3] = 1，交換 nums[3] 和 nums[p1]: [0,1,2,2,1,0]
    - p0 = 1, p1 = 2, i = 4

6. i = 4 時:
    - nums[4] = 1，交換 nums[4] 和 nums[p1]: [0,1,1,2,2,0]
    - p0 = 1, p1 = 3, i = 5

7. i = 5 時:
    - nums[5] = 0，交換 nums[5] 和 nums[p0]: [0,1,1,2,2,0] -> [0,0,1,2,2,1]
    - 由於 p0 < p1，需要再交換 nums[5] 和 nums[p1]: [0,0,1,2,2,1] -> [0,0,1,1,2,2]
    - p0 = 2, p1 = 4, i = 6

8. 最終狀態:
    - 輸出: `[0,0,1,1,2,2]`

### 所有方法的效能比較
```
| 方法            | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|-----------------|------------|------------|--------------|
| 計數排序        | O(n)       | O(1)       | 0 ms         |
| 三路快排        | O(n)       | O(1)       | 0 ms         |
| 雙指針          | O(n)       | O(1)       | 0 ms         |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 使用多指針技巧處理陣列操作是 Go 中常見的模式
- 使用簡潔的交換語法 `a, b = b, a` 來交換元素
- 保持程式碼的可讀性和簡潔性

### 錯誤處理與邊界情況
- 處理空陣列情況：由於限制條件保證了 n >= 1，實際上不需要特別處理
- 特別注意指針的移動和元素交換的順序，避免邏輯錯誤

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2-3 分鐘
- 初始解法提案: ~5 分鐘
- 優化討論: ~5-7 分鐘
- 程式碼編寫: ~10-15 分鐘
- 測試與除錯: ~5 分鐘

### 面試官互動模擬
- 解釋三路快排方法的核心思想：「我使用了三路快排的思想，將陣列分為三個區域：紅色（0）、白色（1）和藍色（2）。通過三個指針維護這些區域的邊界。」
- 可能的提示問題：
    - 為什麼在處理藍色元素時 current 指針不移動？
    - 這個解法是否適用於所有輸入情況？
    - 如果元素數量遠大於顏色數量，這個方法的優勢是什麼？
- 清晰地解釋實現決策：「我選擇三路快排而不是計數排序，因為它可以在單次遍歷中完成排序，而且不需要額外的空間。」

### 潛在的後續問題
- 如果顏色數量增加到 k 種，如何修改你的解法？
- 當記憶體受限時，如何優化你的解法？
- 如何推廣這個解法到其他問題，比如按多個屬性排序？

## 9. 知識整合與學習

### 問題解決洞察
- 這個問題教會了我如何利用問題特性（有限種類）進行高效排序
- 深化了對指針操作和原地算法設計的理解
- 認識到了如何將通用算法（快速排序）特化以解決特定問題

### 心智模型建構
- 從這個問題中抽象出的框架：對於有限種類元素的排序，可以使用分區技巧
- 這個框架可以應用於其他分類問題，如將奇偶數分開、將正負數分開等
- 將此經驗內化為解決類似問題的直覺

### 錯誤模式識別
- 實現三路快排時容易犯的錯誤：忘記處理藍色元素後檢查交換後的元素
- 這反映了對指針移動順序的盲點
- 可以通過更仔細的模擬和測試來避免這類錯誤

### 知識圖譜擴展
- 相關 Go 學習資源：
    - Go 語言中的排序包 `sort`
    - 快速排序的進階實現
- 進階模式：如何處理多指針問題
- 此實現如何融入我的整體 Go 知識體系：強化了對 Go 中陣列操作的理解