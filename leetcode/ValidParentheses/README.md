## 1. Original Problem

**Valid Parentheses (English)**

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.
3. Every close bracket has a corresponding open bracket of the same type.

**有效的括號 (繁體中文)**

給定一個只包含字 '('，')'，'{'，'}'，'[' 和 ']' 的字串 s，判斷字串是否有效。

如果字串滿足以下條件，則有效：
1. 左括號必須用相同類型的右括號閉合。
2. 左括號必須以正確的順序閉合。
3. 每個右括號都有一個對應的同類型左括號。

**Examples:**

Example 1:
```
Input: s = "()"
Output: true
```

Example 2:
```
Input: s = "()[]{}"
Output: true
```

Example 3:
```
Input: s = "(]"
Output: false
```

**Constraints:**
- 1 <= s.length <= 10^4
- s consists of parentheses only '()[]{}'

## 2. Problem Understanding

這個問題本質上是要求我們驗證括號字串的有效性。一個有效的括號字串需要滿足：

1. **配對規則**：每種類型的括號必須與相同類型配對（'(' 與 ')'，'{' 與 '}'，'[' 與 ']'）
2. **順序規則**：括號必須按照正確的嵌套順序閉合，即最後打開的括號必須最先閉合
3. **完整性規則**：每個閉合括號都必須有一個對應的開放括號

這個問題的挑戰在於處理嵌套的括號結構。例如 `([{}])` 是有效的，而 `([)]` 是無效的，因為括號閉合的順序不正確。

邊界情況需要考慮：
- 空字串（按題目約束不會出現）
- 只有單個字的字串
- 只有開放括號或只有閉合括號的字串

## 3. Visual Explanation

括號匹配問題可以通過堆疊（Stack）數據結構來解決。我們可以將問題可視化如下：

假設我們有輸入 `"({[]})"`:

```
步驟 1: 讀取 '('
  堆疊: ['(']
  
步驟 2: 讀取 '{'
  堆疊: ['(', '{']
  
步驟 3: 讀取 '['
  堆疊: ['(', '{', '[']
  
步驟 4: 讀取 ']'
  檢查堆疊頂部是否為 '['? 是的，彈出
  堆疊: ['(', '{']
  
步驟 5: 讀取 '}'
  檢查堆疊頂部是否為 '{'? 是的，彈出
  堆疊: ['(']
  
步驟 6: 讀取 ')'
  檢查堆疊頂部是否為 '('? 是的，彈出
  堆疊: []
  
最終堆疊為空，因此字串有效。
```

對比無效的例子 `"([)]"`:

```
步驟 1: 讀取 '('
  堆疊: ['(']
  
步驟 2: 讀取 '['
  堆疊: ['(', '[']
  
步驟 3: 讀取 ')'
  檢查堆疊頂部是否為 '('? 不是，頂部是 '['，因此無效
  立即返回 false
```

## 4. Thought Process

對於括號匹配問題，我們可以考慮以下幾種解決方案：

**方法一：使用堆疊（Stack）**
- 遍歷字串，遇到開放括號就入堆疊
- 遇到閉合括號就檢查堆疊頂部是否為對應的開放括號
- 如果不匹配或堆疊為空，則字串無效
- 最終檢查堆疊是否為空（確保所有開放括號都有對應的閉合括號）

**方法二：計數法（不適用於多種括號類型）**
- 對於只有一種括號的情況（如只有小括號），可以使用計數器
- 但對於多種括號類型，這種方法難以處理嵌套順序問題

**方法三：替換法**
- 不斷尋找並替換有效的括號對（如 "()"，"[]"，"{}"）
- 如果最終字串變為空，則原字串有效
- 這種方法效率較低，特別是對於長字串

分析後，堆疊方法是最適合此問題的：
- 它能有效處理多種括號類型
- 它能正確處理嵌套順序問題
- 它的時間複雜度為 O(n)，空間複雜度也為 O(n)

這類問題是辨識堆疊應用的典型例子。當我們需要處理"最近優先"或"後進先出"的情境時，堆疊通常是最佳選擇。

## 5. Optimal Solution Development

最佳解決方案是使用堆疊。讓我們詳細說明演算法步驟：

1. 創建一個空堆疊來存儲開放括號
2. 定義一個映射，將閉合括號映射到其對應的開放括號
3. 遍歷字串中的每個字：
    - 如果是開放括號，入堆疊
    - 如果是閉合括號：
        - 如果堆疊為空，返回 false（沒有對應的開放括號）
        - 如果堆疊頂部不是對應的開放括號，返回 false（順序錯誤）
        - 否則，彈出堆疊頂部的開放括號
4. 檢查堆疊是否為空：
    - 如果為空，返回 true（所有開放括號都已匹配）
    - 如果不為空，返回 false（有未閉合的開放括號）

這個解決方案非常高效，且能處理所有類型的括號和嵌套情況。

## 7. Complexity Analysis

**時間複雜度**：
- 我們需要遍歷字串中的每個字一次，這需要 O(n) 時間
- 對於每個字，堆疊操作（入堆疊、出堆疊、檢查堆疊頂部）都是 O(1) 時間
- 因此，總體時間複雜度為 O(n)，其中 n 是字串的長度

**空間複雜度**：
- 最壞情況下，我們需要將所有開放括號入堆疊，這可能需要 O(n) 空間
- 例如，字串 "(((((" 將導致堆疊大小為 n
- 因此，空間複雜度為 O(n)

這個解決方案已經是最優的，無法再進一步優化時間複雜度，因為我們至少需要讀取每個字一次。

## 8. Optimization & Improvements

雖然該解決方案已經是最優的，但我們可以考慮一些小的改進或變體：

1. **提前檢查長度**：如果字串長度為奇數，則它不可能是有效的括號字串，可以直接返回 false。

2. **優化空間使用**：雖然時間複雜度無法進一步優化，但在某些情況下，我們可以減少堆疊的實際大小，例如，當堆疊大小超過字串長度的一半時，我們可以確定字串無效。

3. **使用數組替代映射**：在這種特定情況下，我們可以使用字的ASCII值建立一個簡單的數組映射，可能比使用映射更高效。

相關問題：
- LeetCode 20: Valid Parentheses（即本題）
- LeetCode 22: Generate Parentheses
- LeetCode 32: Longest Valid Parentheses
- LeetCode 921: Minimum Add to Make Parentheses Valid
- LeetCode 1249: Minimum Remove to Make Valid Parentheses

## 9. Testing Strategy

這個測試覆蓋了以下情況：
1. 基本的有效和無效括號字串
2. 各種類型括號的嵌套
3. 括號順序錯誤的情況
4. 不平衡的括號（只有開放或只有閉合）
5. 單字輸入
6. 複雜的嵌套結構
