# LeetCode 88: 合併排序陣列（Merge Sorted Array）

## 1. 問題定義

### 原始問題（英文）
```
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.
```

### 問題翻譯（繁體中文）
```
給定兩個按非降序排列的整數陣列 nums1 和 nums2，以及兩個整數 m 和 n，分別表示 nums1 和 nums2 中的元素數量。

將 nums1 和 nums2 合併為一個按非降序排列的陣列。

最終排序後的陣列不應由函式返回，而是存儲在陣列 nums1 中。為了實現這一點，nums1 的長度為 m + n，其中前 m 個元素表示應合併的元素，最後 n 個元素設為 0 且應被忽略。nums2 的長度為 n。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
  輸出: [1,2,2,3,5,6]
  解釋: 陣列 nums1 和 nums2 的合併結果為 [1,2,2,3,5,6]。
  ```
- **範例 2:**
  ```
  輸入: nums1 = [1], m = 1, nums2 = [], n = 0
  輸出: [1]
  解釋: 由於 nums2 為空，因此結果仍為 [1]。
  ```
- **範例 3:**
  ```
  輸入: nums1 = [0], m = 0, nums2 = [1], n = 1
  輸出: [1]
  解釋: 由於 nums1 的有效元素為 0 個，因此將 nums2 的元素複製到 nums1 中，最終結果為 [1]。
  ```

- **限制條件:**
    - nums1.length == m + n
    - nums2.length == n
    - 0 <= m, n <= 200
    - 1 <= m + n <= 200
    - -10^9 <= nums1[i], nums2[j] <= 10^9

## 2. 問題理解

### 初始反應與心智模型
- 這是一個關於合併兩個已排序陣列的問題，但需要直接在第一個陣列上操作，而非創建新的陣列。
- 這類問題在實際應用中很常見，例如合併兩個已排序的數據庫查詢結果。
- 核心挑戰在於如何有效地利用 nums1 末尾的空間，避免覆蓋尚未處理的原始元素。
- 從範例中可以看出，我們需要保持陣列的排序性質，同時將兩個陣列的元素進行合併。

### 問題分解
- 我們需要合併兩個已排序的陣列，結果存儲在第一個陣列中。
- 由於 nums1 的後半部分有足夠的空間，我們必須利用這一特性進行合併。
- 兩個關鍵操作：比較兩個陣列中的元素，將較小的元素放入結果陣列。
- 需要考慮的情況：其中一個陣列的元素全部處理完畢時如何處理。
- 邊界情況：空陣列、只有一個元素的陣列等。

### 視覺表示
```
nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3

步驟 1: 比較兩個陣列的最大元素
   nums1: [1,2,3,0,0,0]  <- 最大元素是 3
               ^
   nums2: [2,5,6]        <- 最大元素是 6
                ^
   將較大的元素 6 放在 nums1 的最後一個位置
   nums1: [1,2,3,0,0,6]

步驟 2: 繼續比較剩餘元素
   nums1: [1,2,3,0,0,6]  <- 現在最大元素是 3
               ^
   nums2: [2,5]          <- 最大元素是 5
              ^
   將較大的元素 5 放在 nums1 的倒數第二個位置
   nums1: [1,2,3,0,5,6]

... 依此類推
```

- 這個視覺表示幫助我理解可以從後向前填充 nums1，這樣可以避免覆蓋尚未處理的 nums1 原始元素。
- 這種方法的優勢在於不需要額外的空間來存儲中間結果。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下演算法模式：
    - [x] 陣列/字串操作
    - [x] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪心演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 問題涉及操作兩個已排序的陣列，需要在原地合併，這是典型的陣列操作問題。
    - 可以使用雙指針技術來追踪兩個陣列中的元素位置，從而實現高效合併。
    - 由於陣列已排序，我們可以利用這一特性進行高效的合併操作。

### 知識連結
- 這個問題與合併排序（Merge Sort）算法中的合併操作非常相似。
- 在合併排序中，我們將兩個已排序的子陣列合併為一個有序陣列。
- 不同之處在於，此問題要求我們直接在 nums1 中進行合併，而不是使用額外的空間。
- 基本的比較和選擇操作是合併已排序序列的核心概念。

### 相似問題比較
- LeetCode 21: 合併兩個有序鏈表（Merge Two Sorted Lists）
    - 相似之處：都需要合併兩個已排序的數據結構。
    - 差異：一個操作陣列，一個操作鏈表；一個原地修改，一個創建新結構。
- LeetCode 977: 有序數組的平方（Squares of a Sorted Array）
    - 相似之處：都需要考慮從兩端處理陣列元素。
    - 差異：本題合併兩個陣列，而 977 是處理單一陣列的平方值。

## 4. 演算法直覺發展

### 直覺建立
- 如果從前向後合併，我們可能會覆蓋 nums1 中尚未處理的元素，所以需要額外的空間。
- 如果從後向前合併，可以利用 nums1 末尾的空間，避免覆蓋問題。
- 從後向前處理，每次選擇兩個陣列中較大的元素放入 nums1 的末尾，是一個自然的思路。
- 這就像在堆疊中，我們總是先處理最大的元素，然後是次大的，依此類推。

### 多角度思考
- 前向合併 vs 後向合併：
    - 前向合併需要額外空間，後向合併可以在原地完成。
    - 後向合併更符合題目要求，也更節省空間。
- 迭代 vs 遞迴：
    - 此問題適合用迭代方式解決，遞迴會增加不必要的複雜性。
- 原地操作 vs 創建新陣列：
    - 題目要求原地修改 nums1，所以我們應該專注於原地操作的解決方案。

## 5. 解決方案開發歷程

### 方法 1: 使用額外空間的解決方案

#### 思考過程
- 最直觀的方法是創建一個新的陣列來存儲合併結果，然後將結果複製回 nums1。
- 這種方法簡單明了，易於理解和實現。
- 雖然不是最優的空間利用方式，但可以作為基本解決方案。

#### 演算法設計
```
1. 創建一個新的陣列 result，長度為 m + n
2. 使用兩個指針 i 和 j 分別指向 nums1 和 nums2 的開始
3. 比較 nums1[i] 和 nums2[j]，將較小的元素加入 result，並移動相應的指針
4. 當某一個陣列的元素全部處理完時，將另一個陣列的剩餘元素加入 result
5. 最後，將 result 中的所有元素複製回 nums1
```

#### 實現細節
- 使用了 Go 的 `make` 函數創建一個長度為 m+n 的新陣列。
- 使用三個指針 i, j, k 分別追踪 nums1, nums2 和 result 中的位置。
- 將結果複製回 nums1 時使用了一個簡單的迴圈。
- 這種實現方式清晰易懂，但需要額外的 O(m+n) 空間。

#### 複雜度分析
- **時間複雜度**: O(m+n) — 我們需要遍歷兩個陣列的所有元素，然後再把結果複製回 nums1。
- **空間複雜度**: O(m+n) — 我們創建了一個新的陣列來存儲合併結果。

#### 解決方案評估
- 優點：簡單直觀，容易實現和理解。
- 缺點：需要額外的空間，不符合原地修改的要求。
- 在面試情境下，這個解決方案可能被視為初步解答，但面試官可能會要求優化空間使用。

### 方法 2: 從後向前合併的最優解決方案

#### 關鍵洞見
- nums1 的後部分有空間可以用來存放合併結果。
- 如果從後向前合併，可以避免覆蓋尚未處理的 nums1 元素。
- 由於兩個陣列都是已排序的，我們可以從最大的元素開始，逐步填充 nums1 的末尾。

#### 優化策略
```
1. 使用三個指針：p1 指向 nums1 有效元素的末尾，p2 指向 nums2 的末尾，p 指向 nums1 的最後一個位置
2. 比較 nums1[p1] 和 nums2[p2]，將較大的元素放到 nums1[p] 的位置
3. 根據選擇的元素，移動相應的指針
4. 如果 p2 小於 0，表示 nums2 中的所有元素都已合併，結束操作
5. 如果 p1 小於 0，將 nums2 中剩餘的元素複製到 nums1 的前部
```

#### 實現改進
- 這個實現直接在 nums1 上操作，無需額外空間。
- 從後向前合併的策略避免了覆蓋尚未處理的 nums1 元素。
- 使用三個指針來追踪兩個陣列和結果陣列的位置。
- 當 nums2 中的元素都處理完畢時，不需要進一步操作 nums1 中的元素，因為它們已經在正確的位置。

#### 複雜度分析
- **時間複雜度**: O(m+n) — 最壞情況下，我們需要遍歷兩個陣列的所有元素。
- **空間複雜度**: O(1) — 只使用了常數額外空間，符合原地修改的要求。

#### 解決方案評估
- 優點：空間利用率高，不需要額外空間；時間複雜度優越，只需遍歷一次。
- 這個解決方案是最優的，因為它達到了時間和空間的最佳平衡。
- 在面試情境下，這是一個完美的解答，展示了對陣列操作的深入理解。

## 6. 範例演練與 Go 實現

### 完整範例追蹤
追蹤輸入範例: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 的最優解決方案:

1. 初始狀態:
    - nums1 = [1,2,3,0,0,0]
    - nums2 = [2,5,6]
    - p1 = 2 (指向 nums1[2]=3)
    - p2 = 2 (指向 nums2[2]=6)
    - p = 5 (指向 nums1[5]=0)

2. 第一步:
    - 比較 nums1[p1]=3 和 nums2[p2]=6
    - 3 < 6，所以 nums1[p] = nums2[p2] = 6
    - p2 減少為 1，p 減少為 4
    - nums1 = [1,2,3,0,0,6]

3. 第二步:
    - 比較 nums1[p1]=3 和 nums2[p2]=5
    - 3 < 5，所以 nums1[p] = nums2[p2] = 5
    - p2 減少為 0，p 減少為 3
    - nums1 = [1,2,3,0,5,6]

4. 第三步:
    - 比較 nums1[p1]=3 和 nums2[p2]=2
    - 3 > 2，所以 nums1[p] = nums1[p1] = 3
    - p1 減少為 1，p 減少為 2
    - nums1 = [1,2,3,3,5,6]

5. 第四步:
    - 比較 nums1[p1]=2 和 nums2[p2]=2
    - 2 = 2，我們選擇 nums2[p2]（這是一個設計選擇，也可以選擇 nums1[p1]）
    - p2 減少為 -1，p 減少為 1
    - nums1 = [1,2,2,3,5,6]

6. 循環結束，因為 p2 < 0

7. 最終狀態:
    - nums1 = [1,2,2,3,5,6]

### 所有方法的性能比較
```
| 方法              | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|-------------------|------------|------------|--------------|
| 使用額外空間      | O(m+n)     | O(m+n)     | 1 ms         |
| 從後向前合併      | O(m+n)     | O(1)       | 0 ms         |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我們的解決方案遵循了 Go 的簡潔性原則，使用了明確的變數命名。
- 使用了 Go 的切片操作，避免了額外的記憶體分配。
- 解決方案中的程式碼結構清晰，容易理解和維護。

### 錯誤處理與邊界情況
- 我們的解決方案正確處理了 nums2 為空的情況。
- 處理了 nums1 為空但 nums2 有元素的情況。
- 對於兩個陣列都有元素的情況，算法也能正確合併。

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2 分鐘
    - 閱讀問題，理解核心要求是合併兩個有序陣列到第一個陣列中
- 初始解決方案提出: ~3 分鐘
    - 提出使用額外空間的方法，並說明其限制
- 優化討論: ~5 分鐘
    - 分析從後向前合併的方法，解釋為什麼它更優
- 程式碼撰寫: ~7 分鐘
    - 實現最優解決方案的程式碼
- 測試與除錯: ~3 分鐘
    - 使用範例進行手動追蹤測試，確保程式碼正確

### 面試官互動模擬
- 解釋我的 Go 實現：
  "我的解決方案使用從後向前合併的方法，這樣可以避免覆蓋尚未處理的 nums1 元素。我使用三個指針來追蹤兩個陣列和結果陣列的位置，每次選擇較大的元素放入結果陣列的末尾。"

- 可能的提示和引導問題:
    - "為什麼選擇從後向前合併而不是從前向後？"
        - 回答：從前向後合併會覆蓋尚未處理的 nums1 元素，需要額外空間。從後向前合併可以利用 nums1 末尾的空間，實現原地修改。
    - "如果兩個陣列大小差異很大，例如 m >> n 或 n >> m，你的解決方案是否還是最優的？"
        - 回答：是的，即使在極端情況下，該解決方案仍然是時間最優的，因為時間複雜度為 O(m+n)，這是必須的，因為我們至少需要處理所有元素一次。空間複雜度仍為 O(1)。

### 潛在後續問題
- 如果輸入規模大幅增加，你會如何修改你的 Go 程式碼？
    - 對於極大規模的輸入，我們可能需要考慮分塊處理或並行處理，但基本算法仍然是最優的。
- 如果記憶體受限，你會如何優化你的解決方案？
    - 目前的解決方案已經是空間最優的，使用 O(1) 的額外空間。
- 如何擴展你的解決方案來處理更複雜的問題，例如合併 k 個已排序陣列？
    - 可以使用優先佇列（小頂堆）來高效地合併多個已排序陣列，或者可以兩兩合併。

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會了我從多角度思考陣列操作問題的重要性。
- 我現在更深入理解了如何利用 Go 的切片特性進行原地操作。
- 學習到了從後向前處理陣列以避免覆蓋元素的技巧，這在處理其他原地修改問題時也很有用。

### 心智模型建構
- 此問題可以抽象為一個更一般的框架：從兩個已排序的集合中選擇元素，形成一個新的排序集合。
- 這種合併的思維模式可以應用於各種數據結構，如鏈表、堆等。
- 當面對需要原地修改的問題時，我應該首先考慮如何利用現有空間，而不是立即尋求額外空間。

### 錯誤模式識別
- 在初次解決此類問題時，容易忽略原地修改的可能性，直接使用額外空間。
- 容易忽略邊界情況，如一個陣列為空的情況。
- 合併時的比較邏輯必須謹慎處理，特別是當有相等元素時，選擇哪個元素可能會影響結果。

### 知識圖譜擴展
- 相關的 Go 程式設計資源：[Go by Example](https://gobyexample.com/) 提供了優秀的 Go 程式設計實例。
- 進階的 Go 模式和技術：[Effective Go](https://golang.org/doc/effective_go) 提供了編寫清晰、慣用的 Go 程式碼的指南。
- 這個實現與排序算法的合併步驟相關聯，加深了對排序算法的理解