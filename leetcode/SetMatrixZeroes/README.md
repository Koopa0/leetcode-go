# LeetCode 73: 矩陣歸零 (Set Matrix Zeroes)

## 1. 問題定義

### 原始問題 (英文)
```
Given an m x n integer matrix, if an element is 0, set its entire row and column to 0's.
You must do it in place.
```

### 問題翻譯 (繁體中文)
```
給定一個 m x n 的整數矩陣，如果某個元素為 0，則將其所在的整行和整列都設為 0。
你必須原地進行操作。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: matrix = [[1,1,1],[1,0,1],[1,1,1]]
  輸出: [[1,0,1],[0,0,0],[1,0,1]]
  解釋: 由於矩陣中的元素 (1,1) 為 0，因此將第 2 行和第 2 列都設為 0。
  ```
- **範例 2:**
  ```
  輸入: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
  輸出: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
  解釋: 由於矩陣中的元素 (0,0) 和 (0,3) 為 0，因此將第 1 行、第 1 列和第 4 列都設為 0。
  ```

- **限制條件:**
    - `m == matrix.length`
    - `n == matrix[0].length`
    - `1 <= m, n <= 200`
    - `-2^31 <= matrix[i][j] <= 2^31 - 1`

## 2. 問題理解

### 初始反應與心智模型
- 這個問題乍看之下相對直觀：找出所有的 0，然後將對應的行和列都設置為 0。
- 但關鍵在於「原地操作」的要求，也就是說我們不能使用額外的矩陣來存儲結果。
- 主要的挑戰在於：如果我們直接修改矩陣，可能會導致後續判斷時出現錯誤，因為無法區分原始的 0 和新設置的 0。

### 問題分解
- 核心子問題：如何識別矩陣中所有原始為 0 的元素位置。
- 如何在不影響未處理位置的情況下標記需要被設為 0 的行和列。
- 如何有效地將標記的行和列設為 0，而不引入額外的大型數據結構。

### 視覺表示
```
原始矩陣:          處理後:
[1, 1, 1]         [1, 0, 1]
[1, 0, 1]   →     [0, 0, 0]
[1, 1, 1]         [1, 0, 1]
```

- 這個視覺模型清楚地展示了問題的要求：原矩陣中 (1,1) 位置的 0 導致整個第 2 行和第 2 列都變成了 0。
- 一個關鍵洞見：在原矩陣中多個 0 的情況下，一個位置是否變為 0 取決於它是否在某個 0 元素的行或列上。

## 3. 模式識別與知識映射

### 算法模式分類
- 這個問題屬於以下常見算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [x] 雜湊映射/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [ ] 其他: 矩陣操作

- 識別依據：
    - 問題需要對二維矩陣進行操作，這是典型的陣列操作問題。
    - 需要追蹤哪些行和列含有 0，可以使用集合來高效存儲。

### 知識連結
- 此問題涉及的基本CS概念包括：2D陣列操作、原地算法、標記技術。
- 需要理解矩陣的行列表示法，以及如何有效遍歷矩陣。
- 需要考慮空間複雜度最佳化的策略。

### 相似問題比較
- LeetCode 289: Game of Life (生命遊戲) - 同樣要求原地修改矩陣，但規則不同。
- LeetCode 566: Reshape the Matrix (重塑矩陣) - 涉及矩陣操作但較為簡單。
- LeetCode 867: Transpose Matrix (轉置矩陣) - 也是對矩陣進行操作，但不需要處理特殊元素。

## 4. 算法直覺發展

### 直覺建立
- 最直觀的想法是先遍歷整個矩陣找出所有的 0，然後再進行行列的修改。
- 但如果直接修改，會因為新增的 0 而影響後續判斷。
- 一個改進思路是使用額外的記錄來追蹤哪些行列需要被設為 0。

### 多角度思考
- 從上到下 vs 從左到右：可以先遍歷整個矩陣標記需要修改的行列，再進行實際修改。
- 使用額外空間 vs 利用矩陣本身：可以用額外陣列標記，也可以考慮使用矩陣的第一行和第一列作為標記。
- 使用布林值 vs 使用特殊值：可以用布林陣列表示是否需要置 0，也可以用矩陣中不會出現的特殊值作為標記。

## 5. 解決方案發展歷程

### 方法 1：暴力解法

#### 思考過程
- 最直觀的方法是使用一個額外的矩陣複製原始狀態，然後根據原始狀態來修改原矩陣。
- 這個方法簡單明瞭，但需要 O(mn) 的額外空間，不符合原地操作的要求。
- 不過，作為起點，這個方法有助於理解問題並演示基本思路。

#### 算法設計
```
1. 創建一個與原矩陣相同大小的副本
2. 遍歷原始矩陣找出所有的 0
3. 對於每個找到的 0，將對應的行和列都在原矩陣中設為 0
```

#### 實作細節
- 使用了 Go 的二維切片來存儲矩陣副本。
- 這個實作的一個優化點是：一旦確定某行或某列需要設為 0，就可以立即進行設置，而不需要再次檢查該行或列中的其他元素。

#### 複雜度分析
- **時間複雜度**: O(m * n * (m + n)) — 遍歷矩陣需要 O(m * n)，對於每個 0，設置行列需要 O(m + n)
- **空間複雜度**: O(m * n) — 需要一個與原矩陣大小相同的副本

#### 解法評估
- 優點：簡單易懂，直接對應問題描述
- 缺點：空間複雜度高，未達到「原地操作」的要求；時間複雜度也不夠優化
- 在面試情境下，這個解法可以作為初步思路，但應立即提出優化方案

### 方法 2：優化解法

#### 關鍵洞察
- 我們不需要存儲整個矩陣的副本，只需要記錄哪些行和列包含 0。
- 可以使用兩個布林陣列分別記錄哪些行和哪些列需要設為 0。

#### 優化策略
```
1. 使用兩個布林陣列 rowZero 和 colZero 分別記錄哪些行和列應該被設為 0
2. 遍歷矩陣，當找到 0 時，標記對應的行和列
3. 再次遍歷矩陣，根據標記將相應的行和列設為 0
```

#### 實作改進
- 使用了兩個布林陣列代替整個矩陣副本，大幅減少了空間使用。
- 實作分為標記階段和設置階段，避免了新設置的 0 影響判斷。
- 使用了 Go 的 make 函數來初始化布林陣列，預設值為 false，符合我們的需求。

#### 複雜度分析
- **時間複雜度**: O(m * n) — 兩次完整遍歷矩陣
- **空間複雜度**: O(m + n) — 需要兩個大小分別為 m 和 n 的布林陣列

#### 解法評估
- 相比暴力解法，時間複雜度從 O(m * n * (m + n)) 降至 O(m * n)
- 空間複雜度從 O(m * n) 降至 O(m + n)
- 在面試情境下，這是一個很好的改進，但還可以進一步優化空間使用

### 方法 3：最佳解法

#### 突破性思考
- 我們能否利用矩陣自身來存儲標記，而不使用額外的陣列？
- 關鍵洞察：可以用矩陣的第一行和第一列來記錄其餘行列是否需要設為 0。
- 但這樣會影響第一行和第一列本身的判斷，因此需要單獨處理。

#### 最佳算法
```
1. 首先檢查第一行和第一列是否自身包含 0，並用兩個變量記錄
2. 用矩陣的第一行和第一列來標記其餘行列是否包含 0
3. 根據第一行和第一列的標記，更新矩陣中的其他元素
4. 最後根據步驟 1 中的標記，更新第一行和第一列
```

#### 實作精進
- 這個實作巧妙地利用了矩陣的第一行和第一列作為標記空間。
- 透過兩個布林變量來處理第一行和第一列的特殊情況。
- 實作順序很重要：先標記，再根據標記更新其他位置，最後處理第一行和第一列。

#### 複雜度分析
- **時間複雜度**: O(m * n) — 依然需要遍歷整個矩陣
- **空間複雜度**: O(1) — 只使用了兩個布林變量，實現了真正的原地操作

#### 從暴力到最佳的思維演進
- 從直觀的暴力解法開始，我們識別出了關鍵問題：需要區分原始的 0 和新設置的 0。
- 在優化階段，我們採用了額外的陣列來記錄需要設置為 0 的行和列，減少了空間使用。
- 在最佳解法中，我們進一步優化了空間使用，利用矩陣自身的第一行和第一列作為標記空間。
- 這種思維演進展示了如何通過分析問題特性來逐步優化解法，是演算法解題的典型思路。

## 6. 範例演算過程與 Go 實作

### 完整範例追蹤
使用我們的最佳解法追蹤範例輸入：`[[1,1,1],[1,0,1],[1,1,1]]`

1. 初始狀態：
    - 輸入：`[[1,1,1],[1,0,1],[1,1,1]]`
    - firstRowHasZero = false (檢查第一行)
    - firstColHasZero = false (檢查第一列)

2. 用第一行和第一列作為標記：
    - 在位置 (1,1) 發現 0
    - 標記 matrix[1][0] = 0 (第二行需要設為 0)
    - 標記 matrix[0][1] = 0 (第二列需要設為 0)
    - 矩陣變為：`[[1,0,1],[0,0,1],[1,1,1]]`

3. 根據標記更新矩陣：
    - 對於位置 (1,2)，因為 matrix[1][0] = 0，所以設為 0
    - 對於位置 (2,1)，因為 matrix[0][1] = 0，所以設為 0
    - 矩陣變為：`[[1,0,1],[0,0,0],[1,0,1]]`

4. 處理第一行和第一列：
    - firstRowHasZero = false，不需要更改第一行
    - firstColHasZero = false，不需要更改第一列

5. 最終狀態：
    - 輸出：`[[1,0,1],[0,0,0],[1,0,1]]`

### 所有方法的性能比較
```
| 方法             | 時間複雜度        | 空間複雜度      | 範例執行時間    |
|-----------------|-----------------|----------------|----------------|
| 暴力解法         | O(m*n*(m+n))    | O(m*n)         | 約 2-5 ms      |
| 優化解法         | O(m*n)          | O(m+n)         | 約 1-2 ms      |
| 最佳解法         | O(m*n)          | O(1)           | 約 1-2 ms      |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我們的解法遵循了 Go 的簡潔性和可讀性原則。
- 使用了 Go 的切片和基本類型，無需引入複雜的數據結構。
- 變量命名清晰，邏輯分段明確，方便維護和理解。

### 錯誤處理與邊界情況
- 在實作中，我們檢查了矩陣是否為空的情況。
- 對於單行或單列的特殊矩陣，我們的解法也能正確處理。
- 矩陣元素的具體數值不影響我們的算法，只關注是否為 0。

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2 分鐘
- 初始解法提案：~3 分鐘
- 最佳化討論：~5 分鐘
- 程式碼撰寫：~10 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實作：
  "我的解法利用了矩陣自身的第一行和第一列來標記其他行列是否需要設為 0，這樣可以將空間複雜度降至 O(1)。關鍵在於先單獨標記第一行和第一列是否包含 0，然後用它們來標記其他位置，最後再根據標記更新矩陣。"

- 可能的提示和引導問題：
    - "你能否解釋為什麼要單獨處理第一行和第一列？"
    - "當矩陣很大時，你的解法會有什麼優勢？"
    - "有沒有可能進一步優化時間複雜度？"

### 潛在的後續問題
- 如果輸入規模大幅增加，你會如何修改你的 Go 程式碼？
- 如果記憶體受限，你會使用哪些 Go 特定的優化？
- 如果問題改為「將該值所在的行和列都乘以 -1」，你的解法需要如何調整？

## 9. 知識整合與學習

### 解題洞察
- 這個問題教會了我們如何巧妙利用問題本身的空間進行標記。
- 深化了對原地算法的理解，尤其是如何避免新設置的值影響後續判斷。
- 強化了對 Go 切片操作和二維陣列處理的熟練度。

### 心智模型構建
- 解決這類矩陣問題的一般框架：
    1. 考慮是否需要保存原始狀態
    2. 尋找可能的標記方法和空間
    3. 正確處理標記和更新的順序
- 這種思考方式適用於許多需要原地操作的問題。

### 錯誤模式識別
- 在實作過程中容易犯的錯誤包括：
    - 沒有區分原始的 0 和新設置的 0
    - 標記和更新的順序不當
    - 忽略邊界情況，如空矩陣或單元素矩陣

### 知識圖譜擴展
- 相關 Go 學習資源：
    - Effective Go 中關於切片操作的章節
    - Go 中的記憶體優化策略
- 這個實作如何融入整體 Go 知識體系：
    - 強化了對切片的理解和使用
    - 展示了 Go 處理二維陣列的有效方式