# Next Permutation - 下一個排列

## 1. Original Problem

### English:
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).

The replacement must be in place and use only constant extra memory.

**Examples:**
- Input: `nums = [1,2,3]` → Output: `[1,3,2]`
- Input: `nums = [3,2,1]` → Output: `[1,2,3]`
- Input: `nums = [1,1,5]` → Output: `[1,5,1]`

**Constraints:**
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 100

### 繁體中文:
實現下一個排列，它將數字重新排列成字典序中下一個更大的數字排列。

如果無法實現這樣的排列，則必須將其重新排列為最低可能的順序（即按升序排序）。

替換必須就地進行，並且只使用常數額外內存。

**示例：**
- 輸入：`nums = [1,2,3]` → 輸出：`[1,3,2]`
- 輸入：`nums = [3,2,1]` → 輸出：`[1,2,3]`
- 輸入：`nums = [1,1,5]` → 輸出：`[1,5,1]`

**約束條件：**
- 1 <= nums.長度 <= 100
- 0 <= nums[i] <= 100

## 2. 問題理解

這個問題本質上是要求我們找到給定數組的下一個字典序排列，即在所有可能的排列中，比當前排列大的最小排列。

**核心要求：**
- 我們需要找到比當前排列大的排列中最小的一個
- 如果不存在更大的排列（如降序排列[3,2,1]），則返回最小排列（升序[1,2,3]）
- 必須在原地修改數組，只使用O(1)的額外空間

**輸入/輸出特徵：**
- 輸入是一個整數數組，輸出也是同一個數組經過重排後的結果
- 數組長度可能從1到100不等
- 數組元素是0到100之間的整數

**邊界情況：**
- 數組只有一個元素時，不變
- 數組已經是最大排列（降序）時，需要轉為最小排列（升序）
- 存在重複元素的情況需要特別處理

**挑戰：**
- 理解什麼是"字典序的下一個更大排列"
- 設計一個在不生成所有可能排列的情況下，直接找到下一個排列的算法
- 在O(1)空間複雜度的約束下實現原地修改

## 3. 視覺化解釋

### 算法流程圖解

上圖展示了尋找下一個排列的算法流程，以數組 `[1,4,3,2]` 為例：

1. **從右向左找到第一個遞減的元素**：
    - 對比 2 和 3：2 < 3（遞增）
    - 對比 3 和 4：3 < 4（遞增）
    - 對比 4 和 1：4 > 1（找到遞減元素，i=0，值為1）

2. **從右向左找到第一個大於 arr[i] 的元素**：
    - 尋找大於 1 的元素：2 > 1（找到 j=3，值為2）

3. **交換元素並反轉 i+1 之後的子數組**：
    - 交換 1 和 2，得到 `[2,4,3,1]`
    - 反轉從 i+1 開始的子數組 `[4,3,1]`，得到 `[1,3,4]`
    - 最終結果為 `[2,1,3,4]`

## 4. 思考過程

要解決這個問題，首先需要了解什麼是"字典序的下一個排列"。字典序就像字典中單詞的排列順序，對於數字序列來說，它是按照從左到右比較每個位置上的數字大小來確定先後順序的。

### 觀察與分析：

觀察以下排列順序：
```
[1,2,3] → [1,3,2] → [2,1,3] → [2,3,1] → [3,1,2] → [3,2,1]
```

從中我們可以發現一些規律：
1. 當序列完全降序時（如[3,2,1]），它已經是最大的排列，下一個排列應該是最小的排列（[1,2,3]）
2. 對於其他情況，要找到下一個排列，需要找到一個位置，使得將這個位置的元素與後面某個元素交換後，整體變大，但增幅最小

### 可能的解決策略：

**策略 1: 暴力枚舉**
- 生成所有可能的排列
- 找到當前排列，然後返回下一個排列
- 時間複雜度：O(n!)，不適合實際使用

**策略 2: 基於觀察的算法**
- 從右向左找到第一個遞減的元素
- 找到這個元素右側最接近但大於它的元素
- 交換這兩個元素
- 反轉右側部分以獲得最小的增幅
- 時間複雜度：O(n)，空間複雜度：O(1)

**策略 3: 使用C++的next_permutation函數**
- 直接使用標準庫函數
- 但不符合題目要求手動實現的初衷

### 策略選擇分析

策略2是最適合本題的方法，因為：
- 它不需要生成所有可能的排列（避免O(n!)的時間複雜度）
- 它滿足O(1)的空間複雜度要求
- 它可以在O(n)的時間內完成操作
- 它直接找到下一個排列，不需要從頭開始枚舉

### 問題類型識別

這是一個**排列問題**，與字典序相關。識別類似問題的關鍵詞包括：
- "下一個排列"或"前一個排列"
- "字典序"
- "按特定順序排列元素"

當遇到此類問題時，我們可以考慮是否可以直接找到下一個狀態，而不是生成所有可能的狀態。

## 5. 最優解決方案開發

讓我們一步步開發最優解決方案。

### 初步想法：

要找到字典序的下一個排列，我們需要：
1. 盡可能保持左側的元素不變
2. 在某個位置進行調整，使得數組整體變大，但增幅最小

### 算法發展：

從對排列的觀察中，我們發現：
- 如果數組完全降序排列，沒有更大的排列
- 否則，一定存在一個位置i，使得arr[i] < arr[i+1]
- 這個位置i是從右向左看到的第一個"遞減"位置

從這個觀察出發，我們可以設計完整算法：

1. **找到第一個遞減的元素**：從右向左掃描數組，找到第一個滿足arr[i] < arr[i+1]的位置i
2. **如果沒有找到**：說明數組完全降序，將整個數組反轉（變為升序）
3. **如果找到了**：
    - 從右向左找到第一個大於arr[i]的元素arr[j]
    - 交換arr[i]和arr[j]
    - 反轉i+1到末尾的子數組（這部分原本是降序，反轉使其變為升序，保證最小增幅）

### 核心洞見：

關鍵洞見是理解為什麼上述算法能找到字典序的下一個排列：
- 位置i是我們需要改變的最右側位置（保證左側盡量不變）
- 與arr[i]交換的arr[j]是大於arr[i]的最小元素（保證增幅最小）
- 反轉i+1到末尾的子數組，將其從降序變為升序，確保得到的是下一個排列而不是跳過多個排列

## 6. 實例演練

讓我們用一個例子詳細演示算法流程：以`[1,3,5,4,2]`為例。

### 1. 從右向左找到第一個遞減元素：
```
... [1, 3, 5, 4, 2]
           ^
```
從右往左比較：2<4，4<5（遞增），但5>3（遞減）。所以i=1，arr[i]=3。

### 2. 找到右側最小的大於arr[i]的元素：
```
... [1, 3, 5, 4, 2]
    ^     ^
```
從右往左找大於3的最小元素：2不符合，4符合。所以j=3，arr[j]=4。

### 3. 交換這兩個元素：
```
... [1, 3, 5, 4, 2] → [1, 4, 5, 3, 2]
    ^     ^
```

### 4. 反轉i+1到末尾的子數組：
```
... [1, 4, 5, 3, 2] → [1, 4, 2, 3, 5]
       ^---------^
```
反轉[5,3,2]得到[2,3,5]，最終結果為[1,4,2,3,5]。

### 驗證結果：
可以確認[1,4,2,3,5]是[1,3,5,4,2]的下一個字典序排列：
- 它比原始排列大（因為第二位從3變成了4）
- 它是所有可能的更大排列中最小的一個（因為我們選擇了最小的大於arr[i]的元素進行交換，並且將右側子數組變為最小可能的排列）

### 關鍵洞見：
- 找到i位置是關鍵，它是我們需要改變的最右側位置
- 交換後反轉子數組非常重要，確保我們得到的是下一個排列而不是跳過多個排列

## 7. Golang 實現

下面是完整的 Golang 實現：

## 8. 代碼執行演練

讓我們以前面使用的例子 `[1,3,5,4,2]` 來演示代碼的執行過程。

### 變量初始化：
```go
n = 5  // 數組長度
```

### 步驟1：尋找第一個遞減元素
```go
i = 3  // 初始化 i = n - 2 = 3
// 檢查 nums[3] >= nums[4]：4 >= 2，條件成立
i = 2  // i--
// 檢查 nums[2] >= nums[3]：5 >= 4，條件成立
i = 1  // i--
// 檢查 nums[1] >= nums[2]：3 >= 5，條件不成立
// 退出循環，i = 1
```

### 步驟2：找到右側大於 nums[i] 的元素並交換
```go
// i = 1，nums[i] = 3
j = 4  // 初始化 j = n - 1 = 4
// 檢查 nums[4] <= nums[1]：2 <= 3，條件成立
j = 3  // j--
// 檢查 nums[3] <= nums[1]：4 <= 3，條件不成立
// 退出循環，j = 3

// 交換 nums[1] 和 nums[3]
nums[1], nums[3] = nums[3], nums[1]
// 數組變為 [1,4,5,3,2]
```

### 步驟3：反轉從 i+1 到末尾的子數組
```go
// 調用 reverse(nums, i+1, n-1) = reverse(nums, 2, 4)
// 開始反轉 nums[2]到nums[4] 即 [5,3,2]

start = 2, end = 4
// 檢查 start < end：2 < 4，條件成立
// 交換 nums[2] 和 nums[4]
nums[2], nums[4] = nums[4], nums[2]
// 數組變為 [1,4,2,3,5]
start = 3, end = 3
// 檢查 start < end：3 < 3，條件不成立
// 退出循環
```

### 最終結果：
```go
// 數組變為 [1,4,2,3,5]
```

這正是 `[1,3,5,4,2]` 的下一個字典序排列。

### 關鍵Go語言特性解析：

1. **多值賦值交換**：`nums[i], nums[j] = nums[j], nums[i]` 是Go語言中交換兩個變量的簡潔方式，不需要使用臨時變量。

2. **切片處理**：雖然我們處理的是數組，但函數簽名 `func nextPermutation(nums []int)` 使用的是切片，這允許我們直接修改原數組而不需要返回新數組。

3. **輔助函數分離**：我們將反轉數組的邏輯抽離到 `reverse` 函數中，提高了代碼的可讀性和可維護性。

## 9. 複雜度分析

### 時間複雜度

1. **找尋第一個遞減元素**：
    - 最壞情況下需要遍歷整個數組一次
    - 時間複雜度：O(n)

2. **尋找右側大於nums[i]的元素**：
    - 最壞情況下需要從右向左遍歷整個數組
    - 時間複雜度：O(n)

3. **反轉子數組**：
    - 最壞情況下需要反轉整個數組（當沒有下一個排列時）
    - 時間複雜度：O(n)

綜合上述步驟，**總時間複雜度為O(n)**。

### 空間複雜度

整個算法只使用了有限的額外變量（如i、j、start、end等），不隨輸入規模變化。因此，**空間複雜度為O(1)**。

### 複雜度分析說明

- 時間複雜度O(n)已經是此問題的最優解，因為我們至少需要遍歷一次數組才能確定下一個排列
- 空間複雜度O(1)符合題目原地修改的要求
- 這個算法的效率不會受到輸入數據分佈的影響，在最好、平均和最壞情況下的複雜度都是一致的

## 10. 優化與改進

當前算法已經達到了最優的時間和空間複雜度，但仍有一些可以考慮的優化方向：

### 潛在優化：

1. **提前終止**：
    - 如果數組完全降序，我們可以在第一個循環後立即判斷，然後直接反轉整個數組，不需要進行第二個循環的查找
    - 但這只是微小的優化，不會改變時間複雜度的級別

2. **二分查找優化**：
    - 在步驟2中，我們可以使用二分查找來尋找右側大於nums[i]的最小元素，因為i之後的子數組是降序的
    - 這可以將第二步的時間複雜度從O(n)降低到O(log n)
    - 但總體時間複雜度仍為O(n)，因為其他步驟的複雜度為O(n)

### 與其他算法比較：

1. **與暴力枚舉比較**：
    - 暴力枚舉所有排列的時間複雜度為O(n!)
    - 我們的算法時間複雜度為O(n)，效率提升極其顯著

2. **與標準庫函數比較**：
    - 許多語言的標準庫中有next_permutation函數
    - 我們的實現與標準庫的實現原理相似，效率相當

### 推薦學習方向：

對於想要深入理解排列問題的讀者，推薦探索以下相關主題：
- 排列生成算法（如字典序算法、Johnson-Trotter算法）
- 組合數學中的排列和組合
- 回溯法解決排列問題

## 11. 測試策略

### 測試設計說明

1. **基本測試**：
    - 簡單遞增數組 `[1,2,3]`
    - 完全降序數組 `[3,2,1]`
    - 包含重複元素的數組 `[1,1,5]`

2. **邊界情況**：
    - 單元素數組 `[1]`
    - 所有元素相同 `[1,1,1]`
    - 兩個元素的數組 `[1,2]` 和 `[2,1]`

3. **複雜情況**：
    - 部分遞增部分遞減的數組 `[1,3,5,4,2]`
    - 包含零和重複元素的數組 `[0,1,2,5,3,3,0]`

4. **性能測試**：
    - 生成包含100個元素的較大數組，測試算法的性能和穩定性

### 測試方法與驗證：

每個測試用例都包含以下信息：
- 測試名稱（name）
- 輸入數組（input）
- 期望輸出（expected）
- 測試描述（desc）

測試流程如下：
1. 複製輸入數組以避免修改原始測試數據
2. 調用 `nextPermutation` 函數進行處理
3. 使用 `reflect.DeepEqual` 比較結果是否符合預期
4. 對於性能測試，我們不檢查具體結果，只測試不會崩潰
