# 1. Original Problem: Regular Expression Matching

## English Version
Given an input string `s` and a pattern `p`, implement regular expression matching with support for '.' and '*' where:
- '.' Matches any single character.
- '*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

**Example 1:**
```
Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

**Example 2:**
```
Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
```

**Example 3:**
```
Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
```

**Constraints:**
- 1 <= s.length <= 20
- 1 <= p.length <= 30
- s contains only lowercase English letters.
- p contains only lowercase English letters, '.', and '*'.
- It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.

## 繁體中文版本
給你一個字符串 `s` 和一個模式 `p`，實現支持 '.' 和 '*' 的正則表達式匹配：
- '.' 匹配任意單個字符。
- '*' 匹配零個或多個前面的元素。

匹配應覆蓋整個字符串（而非部分匹配）。

**示例 1:**
```
輸入: s = "aa", p = "a"
輸出: false
解釋: "a" 無法匹配整個字符串 "aa"。
```

**示例 2:**
```
輸入: s = "aa", p = "a*"
輸出: true
解釋: '*' 表示零個或多個前面的元素，即 'a'。因此，重複 'a' 一次，就可以得到 "aa"。
```

**示例 3:**
```
輸入: s = "ab", p = ".*"
輸出: true
解釋: ".*" 表示零個或多個（*）任意字符（.）。
```

**約束條件:**
- 1 <= s.length <= 20
- 1 <= p.length <= 30
- s 僅包含小寫英文字母。
- p 僅包含小寫英文字母、'.' 和 '*'。
- 對於字符 '*' 的每次出現，前面都保證有一個有效的字符匹配。

# 2. 問題理解

## 核心要求與約束
這個問題要求我們實現一個支持兩種特殊字符的正則表達式匹配器：
- '.' 可以匹配任何單一字符
- '*' 可以匹配零個或多個前面的元素

匹配必須覆蓋整個輸入字符串，而不僅僅是部分匹配。

## 輸入/輸出特性
- 輸入：字符串 `s` 和模式 `p`
- 輸出：布爾值，表示 `s` 是否完全匹配 `p`

## 邊界情況
- 空字符串 `s` 或 `p`
- 模式開始就是 '*'（根據約束條件，這種情況不會出現）
- 模式中有連續的 '*'（根據約束條件，這種情況不會出現）
- 模式結束是 '*'（這是合法的）
- 組合模式如 ".*"（它可以匹配任意數量的任意字符）

## 潛在困難和關鍵挑戰
- 理解 '*' 運算符的語義，它可以匹配零個、一個或多個前面的字符
- 處理 '.' 和 '*' 的組合
- 確保模式匹配整個輸入字符串
- 當一個匹配失敗時處理回溯（backtracking）
- 正確處理 '*' 匹配零次的情況

# 3. 視覺解釋

讓我們通過一些例子來視覺化理解匹配過程：

另外，讓我們看看動態規劃解法的狀態轉移表格，以例子 2（s = "aa", p = "a*"）為例：



# 4. 思考過程

對於這個正則表達式匹配問題，我們可以考慮以下幾種解題策略：

## 方法一：遞歸法（帶備忘錄）
最直觀的方法是使用遞歸。我們可以按字符逐一比較，並針對特殊字符 '.' 和 '*' 做特殊處理：
- 如果當前字符匹配或模式是 '.'，則繼續匹配下一個字符
- 如果模式中有 '*'，我們需要考慮以下情況：
    - 匹配零次前面的字符（跳過當前模式字符和 '*'）
    - 匹配一次或多次前面的字符（如果當前字符匹配）

然而，純遞歸可能導致重複計算，我們需要使用備忘錄（memoization）來優化。

## 方法二：動態規劃法
我們可以定義一個二維數組 `dp[i][j]`，表示字符串 `s` 的前 `i` 個字符是否能匹配模式 `p` 的前 `j` 個字符。

基本情況：
- `dp[0][0] = true`（空字符串匹配空模式）
- `dp[i][0] = false` 對於 `i > 0`（空模式不能匹配非空字符串）
- `dp[0][j]` 需要根據模式而定（例如，模式如 "a*b*c*" 可以匹配空字符串）

狀態轉移：
1. 如果 `p[j-1]` 不是 '*'：
    - `dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')`
2. 如果 `p[j-1]` 是 '*'：
    - `dp[i][j] = dp[i][j-2]` (匹配零次) ||
      `(dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == '.'))` (匹配一次或多次)

## 方法三：非確定性有限自動機（NFA）
我們可以將正則表達式轉換為 NFA，然後模擬 NFA 在輸入字符串上的執行。這種方法適用於更複雜的正則表達式，但對於這個問題來說可能過於複雜。

## 適合度分析
- 遞歸法非常直觀，易於理解，但可能存在效率問題。
- 動態規劃法更高效，且思路清晰。
- NFA 方法對於本題而言過於複雜。

因此，動態規劃是這個問題的最佳解決方案。

## 識別相似模式
這類問題屬於字符串匹配與動態規劃的結合。當遇到需要處理複雜匹配規則的問題時，我們應該考慮使用動態規劃，尤其是當問題具有重疊子問題和最優子結構時。

# 5. 最優解決方案開發

讓我們逐步構建動態規劃解決方案：

## 初步思路
首先，我們需要定義狀態：`dp[i][j]` 表示字符串 `s` 的前 `i` 個字符是否能匹配模式 `p` 的前 `j` 個字符。

## 基本情況
- `dp[0][0] = true`（空字符串匹配空模式）
- 對於 `j > 0`，`dp[0][j]` 取決於模式中的 '*'。如果 `p[j-1] == '*'`，則 `dp[0][j] = dp[0][j-2]`，因為 '*' 可以匹配零次前面的元素。

## 狀態轉移方程
1. 如果 `p[j-1]` 不是 '*'：
    - 如果 `s[i-1] == p[j-1]` 或 `p[j-1] == '.'`，則 `dp[i][j] = dp[i-1][j-1]`
    - 否則 `dp[i][j] = false`

2. 如果 `p[j-1]` 是 '*'：
    - 匹配零次：`dp[i][j] = dp[i][j-2]`
    - 匹配一次或多次：如果 `s[i-1] == p[j-2]` 或 `p[j-2] == '.'`，則 `dp[i][j] = dp[i][j] || dp[i-1][j]`

## 範例推導
讓我們通過示例 `s = "aa"`, `p = "a*"` 來推導：

1. `dp[0][0] = true`（空匹配空）
2. `dp[0][1] = false`（'a' 不匹配空）
3. `dp[0][2] = dp[0][0] = true`（'a*' 可以匹配零次 'a'，所以匹配空）
4. `dp[1][0] = false`（空模式不匹配非空）
5. `dp[1][1] = dp[0][0] && ('a' == 'a') = true`
6. `dp[1][2] = dp[1][0] || (dp[0][2] && ('a' == 'a')) = false || (true && true) = true`
7. `dp[2][0] = false`
8. `dp[2][1] = dp[1][0] && ('a' == 'a') = false`
9. `dp[2][2] = dp[2][0] || (dp[1][2] && ('a' == 'a')) = false || (true && true) = true`

所以 `dp[2][2] = true`，表示 "aa" 可以被 "a*" 匹配。

## 關鍵洞察
處理 '*' 是本題的關鍵。'*' 可以匹配零次、一次或多次前面的元素，這導致我們需要考慮多種可能性。動態規劃可以有效地處理這些可能性，避免重複計算。

# 6. Golang 實現

以下是動態規劃解決方案的 Golang 實現：



# 7. 複雜度分析

## 時間複雜度分析

### 動態規劃解法:
- 我們需要填充大小為 (m+1) × (n+1) 的 dp 數組，其中 m 是字符串 s 的長度，n 是模式 p 的長度
- 對於每個單元格 dp[i][j]，我們需要常數時間的計算
- 因此，總時間複雜度為 O(m × n)

### 遞歸解法（帶備忘錄）:
- 最壞情況下，我們需要計算所有可能的 (i, j) 組合，總共有 (m+1) × (n+1) 種組合
- 對於每個組合，計算需要常數時間
- 由於使用備忘錄，每個組合最多計算一次
- 因此，總時間複雜度為 O(m × n)

## 空間複雜度分析

### 動態規劃解法:
- 我們需要一個大小為 (m+1) × (n+1) 的二維數組來存儲中間結果
- 因此，空間複雜度為 O(m × n)

### 遞歸解法（帶備忘錄）:
- 我們使用大小為 (m+1) × (n+1) 的備忘錄數組
- 遞歸調用堆棧最壞情況下的深度為 O(m + n)
- 因此，總空間複雜度為 O(m × n)

## 推導過程
對於動態規劃解法，我們需要計算 dp 數組中的每個元素。數組大小為 (m+1) × (n+1)，每個計算需要常數時間，所以總時間複雜度為 O(m × n)。

對於空間複雜度，我們直接使用了大小為 (m+1) × (n+1) 的數組，因此空間複雜度為 O(m × n)。

## 為什麼無法進一步優化
雖然我們可以嘗試對空間複雜度進行優化，比如使用滾動數組將空間複雜度降低到 O(n)，但這會使程式碼更加複雜，且不會改變總體時間複雜度。

對於這種涉及二維狀態的動態規劃問題，O(m × n) 的時間複雜度通常是最優的，因為我們需要考慮所有可能的狀態組合。

# 8. 優化與改進

## 潛在的優化方向

### 1. 空間優化
我們可以將動態規劃解法的空間複雜度從 O(m × n) 優化到 O(n) 或 O(2n)，只保留當前行和前一行的狀態：

```go
func isMatchOptimized(s string, p string) bool {
    m, n := len(s), len(p)
    
    // 只保留兩行
    prev := make([]bool, n+1)
    curr := make([]bool, n+1)
    
    // 初始化第一行
    prev[0] = true
    for j := 1; j <= n; j++ {
        if p[j-1] == '*' && j >= 2 {
            prev[j] = prev[j-2]
        }
    }
    
    for i := 1; i <= m; i++ {
        // 每行開始時當前行的第一個元素為 false
        curr[0] = false
        
        for j := 1; j <= n; j++ {
            if p[j-1] == '*' {
                if j >= 2 {
                    curr[j] = curr[j-2]
                }
                if j >= 2 && (p[j-2] == '.' || p[j-2] == s[i-1]) {
                    curr[j] = curr[j] || prev[j]
                }
            } else {
                match := p[j-1] == '.' || p[j-1] == s[i-1]
                curr[j] = match && prev[j-1]
            }
        }
        
        // 將當前行複製到前一行
        copy(prev, curr)
    }
    
    return prev[n]
}
```

### 2. 早期終止
如果發現有一整行的 dp 值都為 false，這意味著無論如何都無法匹配，我們可以提早返回 false。但是這種情況實際很少發生，所以對大多數情況幫助不大。

### 3. 預處理模式
我們可以預處理模式 p，將連續的 "x*" 合併，這可能對某些特定輸入有幫助，但是這種情況在實際測試中也很少見。

## 解決方案比較

| 解決方案 | 優點 | 缺點 |
|-------|------|------|
| 動態規劃 | 直觀明確，容易理解 | 空間複雜度較高 |
| 遞歸+備忘錄 | 程式碼簡潔，直接反映了問題定義 | 函數調用開銷，可能導致堆棧溢出 |
| 空間優化的動態規劃 | 空間複雜度更低 | 程式碼更複雜，難以理解 |

## 推薦
對於這個問題，我推薦使用動態規劃解法，因為:
1. 它直觀且容易理解
2. 時間複雜度已是最優 O(m × n)
3. 在實際情況下，字符串和模式的長度通常不會太長，所以空間消耗並不是瓶頸

## 相關問題推薦
1. LeetCode 44: 通配符匹配 (Wildcard Matching)
2. LeetCode 72: 編輯距離 (Edit Distance)
3. LeetCode 97: 交錯字符串 (Interleaving String)
4. LeetCode 115: 不同的子序列 (Distinct Subsequences)
5. LeetCode 132: 分割回文串 II (Palindrome Partitioning II)

# 9. 測試策略

以下是一個全面的測試策略，使用 Go 的表驅動測試方法：





## 測試策略說明

我的測試策略遵循 Go 的表驅動測試最佳實踐，旨在全面驗證解決方案的正確性和健壯性：

### 測試類別概述

1. **基本功能測試**：
    - 無特殊字符的基本字符串匹配
    - 測試正常的匹配和不匹配情況

2. **'.' 字符測試**：
    - 測試 '.' 匹配單個字符
    - 測試多個 '.' 的組合

3. **'*' 字符測試**：
    - 測試 '*' 匹配零次前面的元素
    - 測試 '*' 匹配一次前面的元素
    - 測試 '*' 匹配多次前面的元素

4. **組合測試 ('.' 和 '*')**：
    - 測試 '.*' 匹配任意字符序列
    - 測試複雜的模式組合

5. **邊界情況**：
    - 空字符串匹配空模式
    - 空字符串匹配含 '*' 的模式
    - 空模式匹配非空字符串

6. **極端情況**：
    - 長字符串和長模式的匹配
    - 特殊模式的處理（如連續的特殊字符）
    - 模式以 '*' 結尾的情況

### 性能測試

我還包含了性能基準測試，用於比較動態規劃和遞歸兩種實現方法在不同輸入大小下的性能：
- 短字符串測試
- 中等長度字符串測試
- 長字符串測試

### 運行和驗證

測試框架會運行每個測試用例，並驗證實際結果是否符合預期。如果發現不匹配，測試將失敗並顯示詳細的錯誤信息，包括輸入、預期輸出和實際輸出。

這種結構化的測試確保我們的解決方案能夠正確處理各種情況，從而增強程式碼的可靠性和健壯性。基準測試則有助於比較不同實現方法的性能差異，為我們選擇最佳解決方案提供依據。