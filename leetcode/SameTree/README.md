# LeetCode 100: Same Tree (相同的樹)

## 1. 問題定義

### 原始問題 (英文)
```
Given the roots of two binary trees p and q, write a function to check if they are the same tree.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
```

### 問題翻譯 (繁體中文)
```
給定兩個二元樹的根節點 p 和 q，編寫一個函式來檢查它們是否為相同的樹。

當兩個二元樹在結構上相同，且相應位置的節點具有相同的值時，則認為它們是相同的樹。
```

### 範例與限制
- **範例 1:**
  ```
  輸入: p = [1,2,3], q = [1,2,3]
  輸出: true
  解釋: 兩棵樹結構相同且值相同。
  ```
- **範例 2:**
  ```
  輸入: p = [1,2], q = [1,null,2]
  輸出: false
  解釋: 第一棵樹的左子樹是節點 2，第二棵樹的右子樹是節點 2，結構不同。
  ```
- **範例 3:**
  ```
  輸入: p = [1,2,1], q = [1,1,2]
  輸出: false
  解釋: 雖然節點值都相同，但位置不同，故樹不同。
  ```

- **限制:**
    - 樹中的節點數量範圍是 [0, 100]
    - -10^4 <= Node.val <= 10^4

## 2. 問題理解

### 初始反應與心智模型
- 這是一個關於比較兩個二元樹的問題，看起來相對簡單直觀。
- 我需要檢查兩棵樹的結構和節點值是否完全相同。
- 這個問題本質上是在檢查兩個樹狀結構是否完全等價。
- 視覺化這個問題時，我看到兩棵樹並需要一一對應比較每個節點。

### 問題分解
- 核心子問題：判斷兩個給定節點及其子樹是否相同。
- 必要操作：遍歷兩棵樹並比較相應位置的節點。
- 需要處理的假設或邊界情況：
    - 空樹（null 節點）
    - 單節點樹
    - 不同深度的樹
    - 節點值相同但結構不同的樹
    - 結構相同但節點值不同的樹

### 視覺表示
```
     1          1
    / \        / \
   2   3  vs  2   3
   
   (相同的樹)
   
     1          1
    /          / \
   2     vs   2   3
   
   (不同的樹)
```
- 這種視覺化幫助我理解需要同時比較節點值和結構。
- 當兩棵樹的根節點相同時，問題轉化為比較左子樹和右子樹是否分別相同，這暗示了遞迴的解決方案。

## 3. 模式識別與知識映射

### 演算法模式分類
- 此問題屬於以下演算法模式：
    - [x] 樹問題
    - [x] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 其他

- 識別基礎：
    - 問題直接涉及二元樹結構的比較
    - 需要遞迴或迭代地遍歷樹的所有節點
    - 屬於典型的樹遍歷問題，可以用深度優先或廣度優先實現

### 知識連結
- 二元樹的基本概念和性質
- 樹遍歷技術（先序、中序、後序、層序）
- 遞迴與迭代方法在樹結構上的應用
- 樹的同構問題（這是一個判斷同構的簡化版本，不僅結構要相同，值也要相同）

### 相似問題比較
- LeetCode 101：對稱二元樹 (Symmetric Tree)
- LeetCode 572：另一個樹的子樹 (Subtree of Another Tree)
- LeetCode 1367：二元樹中的鏈表 (Linked List in Binary Tree)

這些問題都涉及樹結構的比較或匹配，需要類似的遍歷和比較策略。

## 4. 演算法直覺發展

### 直覺建立
- 最自然的思路是：同時遍歷兩棵樹，比較相應位置的節點。
- 如同檢查兩個文件是否相同，我們需要逐字元比較。
- 這個問題可以遞迴地解決：如果兩個節點相同，則它們的子樹也必須相同。

### 多重視角
- 從上到下 vs 從下到上：
    - 上到下（先序遍歷）：先比較當前節點，再比較子樹。
    - 下到上（後序遍歷）：先確定子樹相同，再匯總結果。
- 迭代 vs 遞迴：
    - 遞迴：代碼簡潔但可能有堆疊溢出風險。
    - 迭代：使用顯式堆疊，避免遞迴開銷。
- 對於這種問題，上到下的遞迴方法最為直觀和簡潔。

## 5. 解決方案開發歷程

### 方法 1：遞迴解決方案

#### 思考過程
- 最直觀的方法是遞迴比較兩棵樹的每個節點。
- 如果兩個當前節點都為 null，則它們相同。
- 如果只有一個節點為 null 或兩個節點的值不同，則它們不同。
- 否則，遞迴比較左子樹和右子樹。

#### 演算法設計
```
遞迴比較兩棵樹：
1. 如果 p 和 q 皆為 null，返回 true
2. 如果 p 或 q 任一為 null，返回 false
3. 如果 p.Val != q.Val，返回 false
4. 返回 (遞迴比較 p.Left 和 q.Left) AND (遞迴比較 p.Right 和 q.Right)
```

#### Go 實現
```go
```

#### 實現細節
- 使用 Go 的指針來表示樹節點。
- 利用 Go 的短路邏輯運算符（&&）來簡化代碼。
- 注意處理空節點的情況，這是二元樹問題的常見邊界條件。

#### 複雜度分析
- **時間複雜度**: O(N)，其中 N 是樹中的節點數量。最壞情況下，我們需要訪問每個節點一次。
- **空間複雜度**: O(H)，其中 H 是樹的高度。這是由於遞迴調用堆疊的空間。在最壞情況下（偏斜樹），H 可能達到 N；但在平衡樹的情況下，H 是 log(N)。

#### 解決方案評估
- 優點：代碼簡潔，易於理解和實現。
- 缺點：對於深度很大的樹，可能會導致堆疊溢出。
- 這是一個在面試環境中可接受的解決方案，因為它簡單明了且最優。

### 方法 2：迭代解決方案（使用堆疊）

#### 核心洞察
- 遞迴解決方案可能在極端情況下導致堆疊溢出。
- 我們可以使用顯式堆疊來模擬遞迴過程。
- 這種方法對於深度很大的樹更安全。

#### 優化策略
```
使用堆疊迭代比較：
1. 初始化堆疊，將 (p, q) 對推入堆疊
2. 當堆疊非空時：
   a. 彈出一對節點 (node1, node2)
   b. 如果兩者都為 null，繼續
   c. 如果一個為 null 或值不同，返回 false
   d. 將左子樹對和右子樹對推入堆疊
3. 若完成循環，返回 true
```

#### 實現改進
- 使用 Go 的切片作為堆疊。
- 使用自定義的 NodePair 結構來存儲節點對。
- 這種實現避免了遞迴調用堆疊的限制。

#### 複雜度分析
- **時間複雜度**: O(N)，與遞迴解決方案相同，我們仍需訪問每個節點。
- **空間複雜度**: O(N)，在最壞情況下，堆疊可能需要存儲所有節點。

#### 解決方案評估
- 優點：避免了可能的堆疊溢出問題，適用於非常深的樹。
- 缺點：代碼稍微複雜一些，不如遞迴解決方案直觀。
- 在實際應用中，這種方法對於處理大規模樹更為健壯。

### 方法 3：廣度優先搜尋（BFS）解決方案

#### 突破性思考
- 除了深度優先搜尋（DFS），我們也可以用廣度優先搜尋（BFS）來比較兩棵樹。
- BFS 使用佇列而非堆疊，按層級順序遍歷樹。
- 這種方法在某些情況下可能更早發現不同之處。

#### 最佳演算法
```
使用佇列進行 BFS 比較：
1. 初始化佇列，將 (p, q) 對加入佇列
2. 當佇列非空時：
   a. 取出佇列首部的節點對 (node1, node2)
   b. 如果兩者都為 null，繼續
   c. 如果一個為 null 或值不同，返回 false
   d. 將左子樹對和右子樹對加入佇列
3. 若完成循環，返回 true
```

#### 實現優勢
- 使用 Go 的切片作為佇列。
- 保持代碼的清晰度同時實現最佳性能。
- 按層級遍歷可以在某些情況下更早發現差異。

#### 複雜度分析
- **時間複雜度**: O(N)，與其他解決方案相同。
- **空間複雜度**: O(W)，其中 W 是樹的最大寬度。在最壞情況下，這可能達到 N/2。

#### 從暴力解法到最佳解法的思考演進
- 我們從最直觀的遞迴解決方案開始。
- 然後考慮到堆疊溢出的問題，引入了迭代 DFS 解決方案。
- 最後引入 BFS 解決方案，它在某些情況下可能更有效率。
- 每種方法都有其優缺點和適用場景，理解這些是掌握樹問題的關鍵。

## 6. 實例演練與 Go 實現

### 完整實例追蹤
追蹤範例輸入：p = [1,2,3], q = [1,2,3] 使用我們的遞迴解決方案：

1. 初始狀態：
    - 輸入：p = [1,2,3], q = [1,2,3]
    - 開始比較根節點：p = 1, q = 1

2. 第一步（根節點）：
    - p 和 q 都不為 null
    - p.Val = 1, q.Val = 1，相等
    - 遞迴比較左子樹和右子樹

3. 第二步（左子樹）：
    - p.Left = 2, q.Left = 2
    - 兩者都不為 null
    - p.Left.Val = 2, q.Left.Val = 2，相等
    - 遞迴比較左子樹的左右子樹（都為 null，返回 true）

4. 第三步（右子樹）：
    - p.Right = 3, q.Right = 3
    - 兩者都不為 null
    - p.Right.Val = 3, q.Right.Val = 3，相等
    - 遞迴比較右子樹的左右子樹（都為 null，返回 true）

5. 最終狀態：
    - 所有節點比較都返回 true
    - 最終結果：true

### 所有方法的性能比較
```
| 方法             | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|------------------|------------|------------|--------------|
| 遞迴 (DFS)       | O(N)       | O(H)       | 0 ms         |
| 迭代堆疊 (DFS)   | O(N)       | O(N)       | 0 ms         |
| 迭代佇列 (BFS)   | O(N)       | O(W)       | 0 ms         |
```

## 7. Go 最佳實踐與測試

### Go 慣用解決方案
- 我的解決方案遵循 Go 的簡潔設計理念。
- 使用指針來表示樹節點，符合 Go 的標準庫風格。
- 避免了不必要的複雜性，保持代碼的可讀性。

### 錯誤處理與邊界情況
- 我的解決方案處理了所有可能的邊界情況：
    - 兩個空樹
    - 只有一個空樹
    - 不同深度的樹
    - 不同結構但某些節點值相同的樹
- 不需要特殊的錯誤處理，因為問題本身只要求返回布林值。

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~1-2 分鐘
- 初始解決方案提議：~2-3 分鐘
- 優化討論：~2-3 分鐘
- 代碼編寫：~5-7 分鐘
- 測試與除錯：~2-3 分鐘

### 面試官互動模擬
- 我會這樣解釋我的 Go 實現給面試官：
  "我選擇使用遞迴方法來解決此問題，因為它最為直觀。比較兩棵樹是否相同，我需要檢查每個節點的值和結構是否一致。遞迴允許我簡潔地表達這個邏輯：如果當前節點值相同，則遞迴比較左右子樹。"

- 潛在的提示和引導問題：
    - 面試官：如何處理空節點？
    - 回應：「我在函數開始處檢查空節點情況。如果兩個節點都為 null，則返回 true；如果只有一個為 null，則返回 false。」

    - 面試官：是否有更節省空間的實現方式？
    - 回應：「遞迴實現在最壞情況下可能使用 O(H) 的堆疊空間，其中 H 是樹的高度。對於平衡樹，這是 O(log N)，但對於偏斜樹，可能達到 O(N)。迭代方法也需要 O(N) 的空間，但可以避免系統堆疊溢出的風險。」

### 潛在的後續問題
- 如果輸入規模顯著增加，您會如何修改您的 Go 代碼？
    - 回應：「對於非常大的樹，我會選擇迭代實現以避免堆疊溢出。另外，可以考慮添加提前終止條件，例如當發現第一個不匹配的節點時立即返回。」

- 如果記憶體受限，您會應用哪些 Go 特定的優化？
    - 回應：「我會使用迭代方法並優化節點對結構，可能引入對象池以減少記憶體分配。同時，考慮使用廣度優先搜尋，它在某些情況下可能更早發現差異，從而減少總體記憶體使用。」

## 9. 知識整合與學習

### 問題解決洞察
- 這個問題讓我更深入理解了 Go 中的樹遍歷實現技術。
- 我加深了對遞迴和迭代方法的理解，以及它們各自的優缺點。
- 我需要進一步加強的 Go 知識領域包括記憶體優化和更複雜樹算法的實現。

### 心智模型構建
- 從這個問題中，我抽象出了一個「結構比較框架」：
    1. 檢查當前元素是否相同
    2. 如果相同，遞迴或迭代地比較子結構
    3. 設計適當的終止條件
- 這個框架可以應用於各種需要比較複雜結構的問題。

### 錯誤模式識別
- 在實現過程中，最容易犯的錯誤是忘記檢查空節點情況。
- 這揭示了我在處理邊界條件時需要更加謹慎。
- 通過明確的測試用例，我可以避免類似的盲點