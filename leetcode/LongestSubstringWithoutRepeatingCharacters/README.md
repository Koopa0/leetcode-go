## 1. Original Problem

### English:
Given a string `s`, find the length of the longest substring without repeating characters.

**Example 1:**
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**
```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**
```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**
- 0 <= s.length <= 5 * 10^4
- `s` consists of English letters, digits, symbols and spaces.

### 繁體中文:
給定一個字串 `s`，請找出其中不含有重複字的最長子字串的長度。

**示例 1:**
```
輸入: s = "abcabcbb"
輸出: 3
解釋: 因為無重複字的最長子字串是 "abc"，所以其長度為 3。
```

**示例 2:**
```
輸入: s = "bbbbb"
輸出: 1
解釋: 因為無重複字的最長子字串是 "b"，所以其長度為 1。
```

**示例 3:**
```
輸入: s = "pwwkew"
輸出: 3
解釋: 因為無重複字的最長子字串是 "wke"，所以其長度為 3。
請注意，你的答案必須是子字串的長度，"pwke" 是一個子序列，不是子字串。
```

**約束條件:**
- 0 <= s.length <= 5 * 10^4
- `s` 由英文字母、數字、符號和空格組成。

## 2. 問題理解

這個問題的核心要求是找出一個字串中不含重複字的最長子字串的長度。需要記住以下關鍵點：

1. 需要尋找的是**子字串**（substring）而非子序列（subsequence）。子字串要求連續的字，而子序列可以是原字串中任意順序的字。

2. 關注的是沒有任何重複字的子字串。一旦出現重複字，該子字串就不再符合要求。

3. 如果有多個符合條件的子字串具有相同的最長長度，只需返回長度值，不需要返回具體的子字串內容。

4. 輸入可能包含任何字，包括英文字母、數字、符號和空格，不僅僅限於字母。

5. 邊界情況：
    - 空字串，應返回 0
    - 只有一個字的字串，應返回 1
    - 所有字都相同的字串，應返回 1

6. 挑戰在於如何有效地檢測重複字並且能夠動態地調整子字串的範圍。

## 3. 視覺解釋

讓使用視覺化方式來理解這個問題，以示例 "abcabcbb" 為例：

```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
```

用滑動窗口（左右指針）來表示當前的子字串：

1. 初始狀態：
```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
         ^
         |
        left, right
當前子字串："a"，長度為 1
已訪問字集合：{a}
```

2. 擴展右邊界：
```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
         ^ ^
         | |
        left right
當前子字串："ab"，長度為 2
已訪問字集合：{a, b}
```

3. 繼續擴展右邊界：
```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
         ^   ^
         |   |
        left right
當前子字串："abc"，長度為 3
已訪問字集合：{a, b, c}
```

4. 遇到重複字 'a'：
```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
         ^     ^
         |     |
        left  right
字 'a' 重複了
```

5. 移動左邊界直到不包含重複字：
```
字位置：0 1 2 3 4 5 6 7
字串內容：a b c a b c b b
           ^   ^
           |   |
          left right
當前子字串："bca"，長度為 3
已訪問字集合：{b, c, a}
```

6. 繼續這個過程...

最終，會發現最長的無重複字子字串長度為 3。

## 4. 思考過程

對於這類問題，有幾種常見的解決策略：

### 策略一：暴力解法
枚舉所有可能的子字串，檢查每個子字串是否包含重複字，並找出最長的無重複字子字串。
- 缺點：時間複雜度為 O(n³)，非常低效。

### 策略二：滑動窗口 + 集合
使用兩個指針（左右邊界）表示當前考慮的子字串，使用集合跟蹤已經出現過的字。
- 當右指針指向的字不在集合中時，擴展右邊界
- 當右指針指向的字已在集合中時，縮小左邊界直到不再包含重複字
- 優點：時間複雜度為 O(n)，空間複雜度為 O(min(m, n))，其中 m 是字集大小

### 策略三：滑動窗口 + 哈希表（優化）
與策略二類似，但使用哈希表記錄每個字最後出現的位置，這樣當發現重複字時，可以直接跳過中間的步驟，將左邊界直接移到重複字的下一個位置。
- 優點：時間複雜度仍為 O(n)，但實際執行效率更高

對於這個問題，滑動窗口 + 哈希表的方法是最適合的，因為它能夠在線性時間內解決問題，並且更高效地處理重複字的情況。

## 5. 最佳解決方案開發

讓從滑動窗口 + 哈希表的方法入手，逐步完善解決方案：

1. 初始化：
    - 左右指針 left = 0, right = 0
    - 最大長度 maxLength = 0
    - 創建一個哈希表 charIndex，用於記錄每個字最後出現的位置

2. 遍歷字串：
    - 對於每個字 s[right]，檢查它是否已經在當前窗口中出現過
    - 如果 s[right] 已經在窗口中，且其上次出現的位置 >= left，則將 left 更新為該字上次出現位置的下一個位置
    - 更新字最後出現的位置：charIndex[s[right]] = right
    - 計算當前窗口的長度：right - left + 1，並更新最大長度
    - 右指針向右移動：right++

3. 返回最大長度 maxLength

讓用示例 "abcabcbb" 來說明這個過程：

```
初始狀態：left = 0, right = 0, maxLength = 0, charIndex = {}

1. 處理字 'a'（位置 0）：
   charIndex['a'] 不存在，所以不需要移動 left
   charIndex['a'] = 0
   當前窗口長度 = 0 - 0 + 1 = 1，maxLength = 1
   right = 1

2. 處理字 'b'（位置 1）：
   charIndex['b'] 不存在，所以不需要移動 left
   charIndex['b'] = 1
   當前窗口長度 = 1 - 0 + 1 = 2，maxLength = 2
   right = 2

3. 處理字 'c'（位置 2）：
   charIndex['c'] 不存在，所以不需要移動 left
   charIndex['c'] = 2
   當前窗口長度 = 2 - 0 + 1 = 3，maxLength = 3
   right = 3

4. 處理字 'a'（位置 3）：
   charIndex['a'] = 0，且 0 >= left，所以 left = 0 + 1 = 1
   charIndex['a'] = 3
   當前窗口長度 = 3 - 1 + 1 = 3，maxLength = 3
   right = 4

5. 處理字 'b'（位置 4）：
   charIndex['b'] = 1，且 1 >= left，所以 left = 1 + 1 = 2
   charIndex['b'] = 4
   當前窗口長度 = 4 - 2 + 1 = 3，maxLength = 3
   right = 5

6. ... （繼續處理剩餘字）
```

最終，得到 maxLength = 3，這就是答案。


## 7. 複雜度分析

### 時間複雜度:
- 只需要遍歷字串一次，所以時間複雜度是 O(n)，其中 n 是字串的長度
- 在最壞情況下（所有字都不相同），仍然只需要遍歷一次字串
- 對於哈希表的操作（查詢和插入），均攤時間複雜度為 O(1)

### 空間複雜度:
- 哈希表最多需要存儲所有不同的字，所以空間複雜度是 O(min(m, n))，其中 m 是字集的大小，n 是字串的長度
- 對於 ASCII 字集，m = 128；對於 Unicode 字集，m 可能非常大
- 在實際情況下，對於大多數輸入，空間複雜度接近 O(k)，其中 k 是不同字的數量，通常遠小於 n

## 9. 測試策略

這套測試用例涵蓋了：
1. 基本功能測試（官方示例）
2. 邊界情況（空字串、單字字串）
3. 極端情況（所有字都相同、所有字都不同）
4. 特殊輸入（包含空格、符號、Unicode 字）
5. 性能測試（長字串）

這些測試用例能夠全面驗證的解決方案的正確性和健壯性。

總結：滑動窗口 + 哈希表的方法是解決"無重複字的最長子字串"問題的最佳方案，它能夠在線性時間內解決問題，並且使用適量的額外空間。通過跟蹤每個字最後出現的位置，可以高效地調整滑動窗口的左邊界，避免不必要的重複檢查，從而達到最優的時間複雜度。