# LeetCode 80: 從排序陣列中移除重複項 II

## 1. 問題定義

### 原始問題 (English)
```
Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
```

### 問題翻譯 (繁體中文)
```
給定一個以非遞減順序排序的整數陣列 nums，原地移除某些重複的元素，使得每個獨特的元素最多出現兩次。元素的相對順序應保持不變。

由於在某些程式語言中無法改變陣列的長度，因此必須將結果放置在陣列 nums 的前端。更正式地說，如果移除重複項後有 k 個元素，則 nums 的前 k 個元素應該保存最終結果。超過前 k 個元素的內容無關緊要。

在將最終結果放置在 nums 的前 k 個位置後，返回 k。

不要為其他陣列分配額外的空間。你必須透過使用 O(1) 額外記憶體來原地修改輸入陣列。
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: nums = [1,1,1,2,2,3]
  輸出: 5, nums = [1,1,2,2,3,...]
  說明: 函數應該返回 k = 5，前五個元素分別為 1, 1, 2, 2, 3。不用理會超過返回長度的元素。
  ```
- **範例 2:**
  ```
  輸入: nums = [0,0,1,1,1,1,2,3,3]
  輸出: 7, nums = [0,0,1,1,2,3,3,...]
  說明: 函數應該返回 k = 7，前七個元素分別為 0, 0, 1, 1, 2, 3, 3。不用理會超過返回長度的元素。
  ```

- **限制條件:**
    - 1 <= nums.length <= 3 * 10^4
    - -10^4 <= nums[i] <= 10^4
    - nums 已按非遞減順序排序

## 2. 問題理解

### 初始反應與心智模型
- 第一眼看到這個問題，我發現它是「移除重複項」類型的問題，但與標準版本不同，它允許每個元素最多出現兩次。
- 我們需要原地修改陣列，只允許使用 O(1) 的額外空間。
- 由於陣列已經排序，我們可以利用這一特性來識別重複項。
- 問題的關鍵在於：如何追蹤每個元素已出現的次數，並且只保留每個元素的前兩次出現。

### 問題分解
- 核心子問題：追蹤每個獨特元素的出現次數。
- 必要操作：當檢測到元素第三次出現時，跳過它；否則，保留該元素。
- 需要處理的假設或邊界情況：
    - 空陣列
    - 陣列長度為 1 或 2（可以直接返回原長度）
    - 所有元素都相同
    - 陣列中沒有重複元素（超過兩次的）

### 視覺表示
```
原始陣列: [1,1,1,2,2,3]
處理過程:
- 索引 0: 元素 1 第一次出現，保留 -> [1,...]
- 索引 1: 元素 1 第二次出現，保留 -> [1,1,...]
- 索引 2: 元素 1 第三次出現，跳過
- 索引 3: 元素 2 第一次出現，保留 -> [1,1,2,...]
- 索引 4: 元素 2 第二次出現，保留 -> [1,1,2,2,...]
- 索引 5: 元素 3 第一次出現，保留 -> [1,1,2,2,3]
最終結果: [1,1,2,2,3] 長度為 5
```

- 這個視覺表示幫助我理解了我們需要如何在遍歷陣列時，同時追蹤當前元素的出現次數，並決定是否將其加入結果中。
- 我們可以看出，每當元素第三次出現時，我們就不再將它加入結果中。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見的演算法模式：
    - [x] 陣列/字串操作
    - [x] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據：
    - 問題需要在原地修改陣列，這是典型的陣列操作問題。
    - 我們可以使用雙指針技術：一個指針遍歷原陣列，另一個指針指向結果陣列的當前位置。

### 知識連接
- 這個問題涉及陣列原地修改的基本概念。
- 它也涉及計數和狀態追蹤，需要我們追蹤每個元素出現的次數。
- 這個問題是「移除排序陣列中的重複項」的變體，允許每個元素最多出現兩次而不是一次。

### 相似問題比較
- LeetCode 26: 移除排序陣列中的重複項（每個元素只允許出現一次）
    - 相似點：都需要原地修改排序陣列並返回新長度。
    - 不同點：本題允許每個元素最多出現兩次，而不是僅一次。
- LeetCode 283: 移動零（將所有 0 移到陣列末尾）
    - 相似點：都使用雙指針技術來原地修改陣列。
    - 不同點：移動零問題不涉及移除元素，而是重排元素。

## 4. 演算法直覺發展

### 直覺建立
- 當我們遍歷陣列時，我們可以追蹤當前元素已經出現的次數。如果它出現的次數不超過 2，我們就保留它；否則，我們跳過它。
- 由於陣列已經排序，相同的元素會彼此相鄰，這使得計數變得簡單。

### 多重視角
- 我可以從不同角度思考這個問題：
    - 雙指針方法：使用一個快指針遍歷原陣列，一個慢指針指向結果陣列的當前位置。
    - 計數法：對於每個唯一的元素，我們計數它出現的次數，並只保留前兩次出現。
    - 窗口視圖：可以將問題視為維護一個最多包含每個元素兩次的窗口。

## 5. 解決方案開發旅程

### 方法 1: 暴力解法

#### 思考過程
- 最直觀的方法是使用額外的空間來存儲結果，然後複製回原陣列。
- 我們可以遍歷原陣列，使用計數器來追蹤每個元素的出現次數，只保留每個元素的前兩次出現。
- 雖然這不符合 O(1) 空間的要求，但它提供了一個起點來思考問題。

#### 演算法設計
```
1. 創建一個新的陣列 result 來存儲結果。
2. 遍歷原陣列 nums。
3. 對於每個元素 nums[i]：
   a. 如果 i === 0 或 nums[i] !== nums[i-1]，將元素加入 result 並將計數重置為 1。
   b. 否則，如果 nums[i] === nums[i-1] 且計數 < 2，將元素加入 result 並增加計數。
   c. 否則，跳過該元素。
4. 將 result 複製回 nums 的前端。
5. 返回 result 的長度。
```

#### 實作細節
- 我們使用了 Go 的切片（slice）作為動態陣列來存儲結果。
- 我們使用 append 函數來向結果切片中添加元素。
- 我們追蹤每個元素的計數，並僅在計數不超過 2 時將元素加入結果。

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是陣列的長度。我們需要遍歷整個陣列一次。
- **空間複雜度**: O(n)，因為我們使用了一個額外的陣列來存儲結果。這不符合問題的 O(1) 額外空間要求。

#### 解法評估
- 優點：簡單直觀，容易理解。
- 缺點：使用了 O(n) 額外空間，不符合問題的要求。
- 在面試中，這可以作為第一個解法來展示思考過程，但我們需要進一步優化以滿足 O(1) 空間要求。

### 方法 2: 雙指針解法 

#### 關鍵洞見
- 我們不需要使用額外的空間來存儲結果，而是可以直接在原陣列上操作。
- 使用兩個指針：一個慢指針 slow 指向要寫入結果的位置，一個快指針 fast 用於遍歷原陣列。

#### 最佳化策略
```
1. 初始化慢指針 slow = 2（因為前兩個元素一定會保留）和快指針 fast = 2。
2. 如果陣列長度 <= 2，直接返回長度。
3. 遍歷陣列（從索引 2 開始）：
   a. 如果 nums[fast] 不等於 nums[slow-2]，這意味著當前元素不是第三個重複的元素，所以我們將其寫入 slow 位置，並將 slow 增加 1。
   b. 否則，我們跳過該元素。
4. 返回 slow 作為新的長度。
```

#### 實作改進
- 這個實作直接在原陣列上操作，不需要額外的空間。
- 關鍵在於理解 `nums[fast] != nums[slow-2]` 這個條件：如果當前元素與結果中倒數第二個元素不同，則當前元素不是第三個重複的元素。
- 我們從索引 2 開始遍歷，因為前兩個元素一定會保留在結果中。

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是陣列的長度。我們只需要遍歷陣列一次。
- **空間複雜度**: O(1)，我們只使用了幾個變數，沒有使用與輸入大小相關的額外空間。

#### 解法評估
- 優點：符合問題的 O(1) 額外空間要求，時間複雜度為 O(n)，已經是最優的解法。
- 這種雙指針的方法非常適合這類需要原地修改陣列的問題。

### 方法 3: 計數追蹤法（最優解法）

#### 突破性思考
- 解決這個問題的關鍵洞見在於，我們不需要過於複雜的邏輯來追蹤重複元素——只需要一個簡單的計數器即可。
- 當我們遍歷排序陣列時，只要記錄每個元素連續出現的次數，然後只保留出現次數不超過 2 次的元素。
- 這種直觀的計數方法比較容易理解，同時也能有效地解決問題。

#### 最優演算法
```
1. 初始化 index = 1（指向結果陣列中下一個要填入的位置）
2. 初始化 occurance = 1（假設第一個元素已出現一次）
3. 從索引 1 開始遍歷陣列：
   a. 如果當前元素與前一個元素相同，occurance++
   b. 否則，重置 occurance = 1（新元素的第一次出現）
   c. 如果 occurance <= 2，將當前元素複製到 nums[index]，並增加 index
4. 返回 index 作為新陣列的長度
```

#### 實作卓越性
- 這個 Go 實作極其簡潔明瞭，使用了最少的變數和邏輯來實現問題的要求。
- 程式碼的可讀性非常高，每個變數和步驟都有明確的目的和意義。
- 使用 `occurance` 變數直接追蹤元素出現次數的方法非常直觀，比較符合人類的思考方式。
- 這種方法處理了所有可能的邊界情況，包括空陣列、長度為 1 或 2 的陣列，以及所有元素都相同的情況。

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是陣列的長度。我們只需要遍歷整個陣列一次。
- **空間複雜度**: O(1)，我們只使用了固定數量的變數（index 和 occurance），不需要隨輸入大小增加的額外空間。

#### 從暴力解法到最優解法的思維演進
- 暴力解法使用了額外的空間來存儲結果，雖然直觀但不符合 O(1) 空間要求。
- 方法 2（雙指針比較法）通過比較當前元素與結果中倒數第二個元素來決定是否保留，這是一種隱式的追蹤方法。
- 方法 3（計數追蹤法）則更加直觀，顯式地追蹤每個元素連續出現的次數，使邏輯更加清晰。

相比於方法 2，計數追蹤法的主要優勢在於其思路更加直觀，更容易被解釋和理解。兩種方法在時間和空間複雜度上是相同的，都達到了 O(n) 時間和 O(1) 空間，但計數追蹤法在概念上更加簡單明瞭，這在面試情境中是一個很大的優勢。

這種計數追蹤的思想不僅適用於這個問題，還可以擴展到許多其他類似的問題，如「保留每個元素最多 k 次」的變體。只需將比較條件從 `occurance <= 2` 改為 `occurance <= k` 即可。這種靈活性和可擴展性是這個解法的另一個重要優勢。

## 6. 範例演練與 Go 實作

### 完整範例追蹤
以範例輸入 nums = [1,1,1,2,2,3] 追蹤最佳解法的執行過程：

1. 初始狀態：
    - 輸入: [1,1,1,2,2,3]
    - n = 6
    - slow = 2（指向索引 2）
    - fast = 2（指向索引 2）
    - nums[0:2] = [1,1]（前兩個元素已經是結果的一部分）

2. 第一次迭代 (fast = 2):
    - nums[fast] = 1, nums[slow-2] = 1
    - 1 == 1，這是第三個重複的 1，跳過
    - slow 保持不變，值仍為 2

3. 第二次迭代 (fast = 3):
    - nums[fast] = 2, nums[slow-2] = 1
    - 2 != 1，將 nums[fast] 複製到 nums[slow]
    - nums[slow] = 2
    - slow++ 變為 3
    - 現在 nums = [1,1,2,...]

4. 第三次迭代 (fast = 4):
    - nums[fast] = 2, nums[slow-2] = 1
    - 2 != 1，將 nums[fast] 複製到 nums[slow]
    - nums[slow] = 2
    - slow++ 變為 4
    - 現在 nums = [1,1,2,2,...]

5. 第四次迭代 (fast = 5):
    - nums[fast] = 3, nums[slow-2] = 2
    - 3 != 2，將 nums[fast] 複製到 nums[slow]
    - nums[slow] = 3
    - slow++ 變為 5
    - 現在 nums = [1,1,2,2,3,...]

6. 最終狀態：
    - 遍歷結束，slow = 5
    - 輸出: 5，nums = [1,1,2,2,3,...]

### 所有方法的性能比較
```
| 方法            | 時間複雜度 | 空間複雜度 | 範例執行時間 |
|----------------|------------|------------|--------------|
| 暴力解法        | O(n)       | O(n)       | 較慢         |
| 雙指針解法（最佳）| O(n)       | O(1)       | 較快         |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我們的解法遵循了 Go 的最佳實踐，使用了簡潔明瞭的程式碼。
- 變數命名有意義且符合 Go 的命名規範。
- 我們使用了適當的邊界檢查來處理特殊情況。

### 錯誤處理與邊界情況
- 我們處理了陣列長度 <= 2 的邊界情況，直接返回原長度。
- 此解法對於各種輸入都能正確處理，包括完全相同的元素或完全不同的元素。

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解法提案：~3-4 分鐘
- 最佳化討論：~3-5 分鐘
- 程式碼編寫：~8-10 分鐘
- 測試與除錯：~3-5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現：
  "這個問題要求我們從排序陣列中移除重複項，使每個元素最多出現兩次，同時要求 O(1) 的額外空間。我的方法使用雙指針技術：一個慢指針 slow 指向要寫入結果的位置，一個快指針 fast 用於遍歷原陣列。關鍵洞見是比較當前元素和結果中倒數第二個元素：如果它們不同，則當前元素不是第三個重複的元素，應該保留。"

- 潛在的提示和引導問題：
    - 「如何確定元素是否是第三次出現？」 - 我透過比較當前元素和結果中倒數第二個元素來確定。
    - 「為什麼從索引 2 開始而不是 0？」 - 因為前兩個元素一定會保留在結果中，無需檢查。

### 潛在的後續問題
- Q: 如果允許每個元素最多出現 k 次而不是 2 次，如何修改你的 Go 程式碼？
  A: 我會將 slow 初始化為 k，然後檢查 nums[fast] != nums[slow-k]。這樣，當元素第 k+1 次出現時，我們會跳過它。

- Q: 如果不是排序陣列，如何解決這個問題？
  A: 對於未排序的陣列，我們可以使用雜湊表來計數每個元素的出現次數，然後重建陣列。但這需要 O(n) 的額外空間。

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會了我如何使用雙指針技術在原地修改陣列。
- 我更深入地理解了如何追蹤元素的重複性，特別是在原地演算法中。
- 這種原地修改陣列的方法在解決相似問題時非常有用。

### 心智模型建構
- 從這個問題中，我可以抽象出一個一般性的框架：使用雙指針來原地修改陣列，並保持特定的條件。
- 對於需要原地修改並滿足某些條件的陣列問題，這種方法通常是有效的。

### 錯誤模式識別
- 一個常見的錯誤是忘記處理邊界情況，例如空陣列或長度小於等於 2 的陣列。
- 另一個常見錯誤是比較條件設定不正確，例如誤用 nums[slow-1] 而不是 nums[slow-2]。

### 知識圖譜擴展
- 相關 Go 程式設計資源：
    - 閱讀 "Effective Go" 中關於切片操作的部分。
    - 學習更多關於 Go 中原地演算法的實現。
- 這個實現適合進一步探索處理排序陣列的其他問題