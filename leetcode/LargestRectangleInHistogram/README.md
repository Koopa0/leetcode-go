# LeetCode 84: 柱狀圖中最大的矩形 (Largest Rectangle in Histogram)

## 1. 問題定義

### 原始問題 (英文)
```
Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.

Example 1:
Input: heights = [2,1,5,6,2,3]
Output: 10
Explanation: The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.

Example 2:
Input: heights = [2,4]
Output: 4

Constraints:
1 <= heights.length <= 10^5
0 <= heights[i] <= 10^4
```

### 問題翻譯 (繁體中文)
```
給定一個整數陣列 heights，表示柱狀圖中每個長方形的高度，其中每個長方形的寬度為 1，返回柱狀圖中最大矩形的面積。

範例 1:
輸入: heights = [2,1,5,6,2,3]
輸出: 10
說明: 上圖是一個柱狀圖，每個長方形的寬度為 1。紅色區域表示最大的矩形，其面積為 10 個單位。

範例 2:
輸入: heights = [2,4]
輸出: 4

限制條件:
1 <= heights.length <= 10^5
0 <= heights[i] <= 10^4
```

### 範例和限制條件
- **範例 1:**
  ```
  輸入: heights = [2,1,5,6,2,3]
  輸出: 10
  說明: 柱狀圖中最大的矩形面積是 10 個單位。
  ```
- **範例 2:**
  ```
  輸入: heights = [2,4]
  輸出: 4
  ```

- **限制條件:**
    - 陣列長度在 1 到 10^5 之間
    - 每個高度值在 0 到 10^4 之間

## 2. 問題理解

### 初始反應與心智模型
- 第一反應：這是一個需要找出柱狀圖中最大矩形面積的問題
- 柱狀圖可以視為垂直於 x 軸的長方形集合
- 最大矩形可能橫跨多個柱子，其高度受限於這些柱子中最低的高度
- 面積計算為 寬度 × 高度，其中寬度是橫跨的柱子數量，高度是這些柱子中的最小高度

### 問題分解
- 核心子問題：對於每個柱子，找出以其高度為限的最大矩形
- 需要找出每個柱子左右兩側第一個小於它高度的柱子，確定可擴展的最大寬度
- 邊緣情況：空陣列、只有一個元素的陣列、包含零高度柱子的情況
- 將問題分解為：找每個柱子能向左右延伸的最大距離，然後計算最大面積

### 視覺表示
```
     *
    **
    **    *
*   ***   *
** *****  *
```
- 視覺化有助於理解矩形可以如何橫跨多個柱子
- 最大矩形面積可能不包含最高的柱子，而是由多個中等高度柱子組成

## 3. 模式識別與知識映射

### 演算法模式分類
- 此問題屬於以下常見演算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [x] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 哈希表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: 單調堆疊

- 識別基礎：
    - 問題需要找出每個柱子左右兩側第一個小於其高度的位置，這是單調堆疊的典型應用場景
    - 類似於雨水收集、股票跨度等需要找到「下一個較小元素」或「上一個較小元素」的問題

### 知識連接
- 單調堆疊是解決「下一個較大/較小元素」問題的關鍵資料結構
- 此問題涉及區間查詢（找出每個元素可擴展的最大範圍）
- 連接到前後緣問題的解決方案

### 相似問題比較
- LeetCode 42: 接雨水 (Trapping Rain Water)
- LeetCode 85: 最大矩形 (Maximal Rectangle)
- LeetCode 739: 每日溫度 (Daily Temperatures)
- 這些問題都使用單調堆疊來找出元素之間的關係

## 4. 演算法直覺發展

### 直覺建立
- 最大矩形必定以某個柱子的高度為高，寬度則是向左右延伸到不能再延伸為止
- 對於每個柱子，如果我們知道它能向左右延伸的最大距離，就能計算出以它為高的矩形的最大面積
- 需要一種高效的方法來找出每個柱子左右兩側第一個高度小於它的柱子

### 多重視角
- 可以從左至右和從右至左兩次遍歷陣列來找出每個柱子左右兩側的邊界
- 或者使用單調堆疊在一次遍歷中同時解決這個問題
- 從每個柱子出發，考慮以其高度為限的矩形是一個自下而上的思考方式

## 5. 解決方案發展歷程

### 方法 1: 暴力解法

#### 思考過程
- 最直接的方法是考慮每對柱子 (i, j)，計算它們之間可形成的最大矩形
- 對於每對柱子，找出其中最小的高度，並計算面積
- 這種方法直接但效率低下，適合作為初始理解問題的方法

#### 演算法設計
```
for i = 0 to heights.length - 1:
    for j = i to heights.length - 1:
        min_height = minimum height among heights[i] to heights[j]
        width = j - i + 1
        max_area = max(max_area, min_height * width)
```

#### 實作細節
- 使用了 Go 的基本陣列操作
- 使用兩個嵌套的迴圈來檢查每一對可能的柱子組合
- 關鍵在於維護每個範圍內的最小高度

#### 複雜度分析
- **時間複雜度**: O(n²) — 需要檢查每一對柱子，並計算它們之間的最小高度
- **空間複雜度**: O(1) — 只使用常數額外空間

#### 解法評估
- 優點：簡單直接，容易理解和實作
- 缺點：當輸入規模增大時效率極低，無法在面試時間內處理大型輸入
- 在面試情境下，此解法可作為開始點，但應立即尋求優化

### 方法 2: 優化解法 — 分治法

#### 關鍵洞見
- 暴力解法中，我們重複計算了許多區間的最小高度
- 可以使用分治策略來優化這一過程
- 最大矩形要麼完全在最小高度柱子的左側，要麼完全在右側，要麼包含最小高度柱子

#### 優化策略
```
用分治法解決：
1. 找出整個陣列中最小的柱子
2. 計算包含此最小柱子的矩形面積 (最小高度 * 總寬度)
3. 遞迴處理最小柱子左側的子陣列
4. 遞迴處理最小柱子右側的子陣列
5. 返回三者中的最大值
```

#### 實作改進
- 使用分治策略來減少重複計算
- 這個方法將問題分解為子問題，各自獨立處理
- 充分利用遞迴來簡化程式碼結構

#### 複雜度分析
- **時間複雜度**: 最佳情況 O(n log n)，最壞情況 O(n²)，平均情況接近 O(n log n)
    - 每次遞迴需要 O(n) 時間找出最小值
    - 如果每次都能平均分割陣列，則遞迴深度為 O(log n)
    - 最壞情況發生在陣列已排序時，退化為 O(n²)
- **空間複雜度**: O(log n) — 遞迴調用堆疊的深度

#### 解法評估
- 相比暴力解法有顯著改進
- 在大多數情況下效率較高
- 最壞情況下仍有可能退化為 O(n²)
- 在面試中，這是一個可接受的中間解法

### 方法 3: 最佳解法 — 單調堆疊

#### 突破性思考
- 問題的核心是找出每個柱子左右兩側第一個高度小於它的柱子
- 單調堆疊是解決這類「下一個較小元素」問題的最佳工具
- 通過一次遍歷，可以確定每個柱子能擴展的最大範圍

#### 最佳演算法
```
1. 使用單調遞增堆疊來處理每個柱子
2. 當遇到一個高度小於堆疊頂部的柱子時：
   - 彈出堆疊頂部元素
   - 計算以該元素高度為高的矩形面積
   - 矩形的左界是當前堆疊頂部的右側，右界是當前元素的左側
3. 處理完所有柱子後，清空堆疊並計算剩餘元素的面積
```

#### 實作優點
- 使用單調堆疊可以在線性時間內解決問題
- 避免了重複計算，每個元素最多入堆疊和出堆疊一次
- 程式碼緊湊，邏輯清晰

#### 複雜度分析
- **時間複雜度**: O(n) — 每個元素最多入堆疊和出堆疊一次，所有操作總共為 O(n)
- **空間複雜度**: O(n) — 在最壞情況下，所有元素都可能在堆疊中

#### 從暴力解法到最佳解法的思考演變
- 從最初檢查所有可能組合的 O(n²) 方法
- 到使用分治法減少重複計算的 O(n log n) 方法
- 最終到使用單調堆疊的 O(n) 最佳解法
- 關鍵洞見是將「找最大矩形」轉換為「找每個柱子左右兩側第一個較小元素」
- Go 的實作反映了這種思考的進化，從直接但低效的雙迴圈，到精簡高效的單調堆疊

## 6. 範例演練與 Go 實作

### 完整範例追蹤
追蹤範例輸入 `[2,1,5,6,2,3]` 使用我們的最佳解法：

1. 初始狀態：
    - 輸入：`[2,1,5,6,2,3]`
    - 堆疊：`[]`
    - maxArea = 0

2. 處理索引 0 (高度 2)：
    - 堆疊為空，直接入堆疊
    - 堆疊：`[0]`

3. 處理索引 1 (高度 1)：
    - 1 < heights[0] (1 < 2)，彈出索引 0
    - 計算以索引 0 為高的矩形面積：高度 = 2, 寬度 = 1, 面積 = 2
    - maxArea = 2
    - 將索引 1 入堆疊
    - 堆疊：`[1]`

4. 處理索引 2 (高度 5)：
    - 5 > heights[1] (5 > 1)，直接入堆疊
    - 堆疊：`[1,2]`

5. 處理索引 3 (高度 6)：
    - 6 > heights[2] (6 > 5)，直接入堆疊
    - 堆疊：`[1,2,3]`

6. 處理索引 4 (高度 2)：
    - 2 < heights[3] (2 < 6)，彈出索引 3
    - 計算以索引 3 為高的矩形面積：高度 = 6, 寬度 = 1, 面積 = 6
    - maxArea = 6

    - 2 < heights[2] (2 < 5)，彈出索引 2
    - 計算以索引 2 為高的矩形面積：高度 = 5, 寬度 = 2, 面積 = 10
    - maxArea = 10

    - 2 > heights[1] (2 > 1)，將索引 4 入堆疊
    - 堆疊：`[1,4]`

7. 處理索引 5 (高度 3)：
    - 3 > heights[4] (3 > 2)，直接入堆疊
    - 堆疊：`[1,4,5]`

8. 處理虛擬索引 6 (高度 0)：
    - 清空堆疊並計算剩餘元素的面積
    - 彈出索引 5，計算面積：高度 = 3, 寬度 = 1, 面積 = 3
    - 彈出索引 4，計算面積：高度 = 2, 寬度 = 2, 面積 = 4
    - 彈出索引 1，計算面積：高度 = 1, 寬度 = 6, 面積 = 6

9. 最終狀態：
    - maxArea = 10
    - 輸出：`10`

### 所有方法的效能比較
```
| 方法           | 時間複雜度      | 空間複雜度    | 範例執行時間 |
|----------------|----------------|--------------|-------------|
| 暴力解法       | O(n²)          | O(1)         | 約 15 ms    |
| 分治法         | O(n log n)平均 | O(log n)     | 約 7 ms     |
| 單調堆疊       | O(n)           | O(n)         | 約 3 ms     |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 我的解法遵循 Go 的簡潔風格，使用切片作為堆疊
- 使用明確的變數命名和註解，確保程式碼易於理解
- 避免使用全域變數，保持函數獨立性

### 錯誤處理與邊緣情況
- 明確處理了空陣列的情況
- 通過在遍歷結束後添加一個虛擬的高度為 0 的柱子，確保堆疊中所有元素都能被處理
- 堆疊為空時的特殊處理確保了算法的正確性

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解法提案：~5 分鐘
- 優化討論：~5-7 分鐘
- 程式碼撰寫：~10-15 分鐘
- 測試與除錯：~5 分鐘

### 面試官互動模擬
- 解釋我的 Go 實作時，會強調單調堆疊的核心思想
- 潛在問題和引導性問題：
    - 面試官可能會問："為什麼選擇使用堆疊來解決這個問題？"
    - 回應："堆疊能有效追蹤每個柱子左右兩側第一個較小元素的位置，幫助我們確定每個高度能擴展的最大範圍。"
- 清晰溝通實作決策的重要性

### 潛在後續問題
- 如果輸入規模增加到 10^7，你會如何修改你的 Go 程式碼？
- 如果記憶體受到嚴格限制，你會如何優化你的解法？
- 如果問題變成找出柱狀圖中最大的正方形，你會如何調整你的解法？

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會了我如何有效地使用單調堆疊
- 加深了對 Go 中堆疊操作（使用切片實現）的理解
- 需要進一步強化的領域：處理複雜資料結構的能力

### 心智模型建構
- 從這個問題中抽象出來的一般框架：遇到需要找出元素間關係的問題，考慮使用單調堆疊
- 這個框架可應用於許多相似的問題類型
- 將這種經驗內化為直覺，以便在未來遇到相似問題時迅速識別

### 錯誤模式識別
- 在實作過程中常見的錯誤：堆疊為空時的處理不當
- 這揭示了我在處理邊緣情況方面的盲點
- 未來可通過更仔細地考慮所有可能的狀態來預防類似錯誤

### 知識圖譜擴展
- 相關 Go 程式設計資源：Go 官方文檔中關於切片和堆疊的部分
- 進階 Go 模式：了解更多關於在 Go 中實現各種資料結構的方法
- 這個實作如何融入我整體的 Go 知識系統：加強了對基本資料結構應用的理解