# LeetCode 86: 分割鏈表 (Partition List)

## 1. 問題定義

### 原始問題 (英文)
```
Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.
```

### 問題翻譯 (繁體中文)
```
給定一個鏈表的頭節點 head 和一個特定值 x，對鏈表進行分割，使得所有小於 x 的節點都出現在大於或等於 x 的節點之前。

你應該保留兩個分區中每個節點的原始相對順序。
```

### 範例與約束
- **範例 1:**
  ```
  輸入: head = [1,4,3,2,5,2], x = 3
  輸出: [1,2,2,4,3,5]
  說明: 小於 3 的節點有 1、2、2，大於或等於 3 的節點有 4、3、5，在分割後保留原始相對順序。
  ```
- **範例 2:**
  ```
  輸入: head = [2,1], x = 2
  輸出: [1,2]
  說明: 小於 2 的節點只有 1，大於或等於 2 的節點是 2。
  ```

- **約束條件:**
    - 鏈表中的節點數在範圍 [0, 200] 內
    - -100 <= Node.val <= 100
    - -200 <= x <= 200

## 2. 問題理解

### 初始反應與心智模型
- 這是一個鏈表操作問題，需要基於節點值的比較對鏈表進行重組。
- 問題的關鍵是：保持原有節點的相對順序，同時將所有小於 x 的節點移到大於或等於 x 的節點之前。
- 可以將問題視為建立兩個分區，然後重新連接它們。

### 問題分解
- 核心子問題：如何維持節點順序的同時，將鏈表分成兩部分。
- 需要遍歷鏈表，判斷每個節點的值與 x 的關係。
- 需要處理的邊緣情況：空鏈表、僅有一個節點的鏈表、所有節點都小於或都大於 x 的情況。

### 視覺表示
```
原始鏈表: 1 -> 4 -> 3 -> 2 -> 5 -> 2, x = 3

分割過程:
小於 x 的節點: 1 -> 2 -> 2
大於等於 x 的節點: 4 -> 3 -> 5

結果鏈表: 1 -> 2 -> 2 -> 4 -> 3 -> 5
```
- 這個視覺化幫助理解我們需要將鏈表分成兩個部分，再重新連接。
- 可以看出我們需要維持節點在原始鏈表中的相對順序。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [x] 鏈表操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪心演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別依據:
    - 問題明確要求對鏈表進行操作和重組。
    - 需要遍歷和重新連接鏈表節點。
    - 與類似的鏈表分割/重組問題有相似之處。

### 知識連接
- 這個問題涉及的基本計算機科學概念是鏈表的操作。
- 需要理解指針操作和節點連接的基本原理。
- 需要瞭解如何在不創建新節點的情況下重組現有鏈表。

### 類似問題比較
- LeetCode 21: 合併兩個有序鏈表 - 也涉及鏈表的重組和遍歷。
- LeetCode 2: 兩數相加 - 也需要操作鏈表。
- LeetCode 328: 奇偶鏈表 - 類似地需要將鏈表按照某種規則分組重組。

## 4. 演算法直覺發展

### 直覺建立
- 直觀上，可以創建兩個新的鏈表，一個存放小於 x 的節點，另一個存放大於等於 x 的節點。
- 最後將這兩個鏈表連接起來。
- 這種方法能夠保持兩個部分中節點的原始相對順序。

### 多重視角
- 迭代與遞迴方法：對於這類鏈表操作問題，迭代方法通常更直觀且效率更高。
- 原地操作：可以不創建新節點，僅通過改變指針來重組鏈表，這樣可以優化空間複雜度。
- 雙指針技術：可以使用兩個指針分別構建兩個子鏈表，然後再將它們連接起來。

## 5. 解決方案開發歷程

### 方法 1: 雙鏈表解決方案

#### 思考過程
- 最直接的解決方案是創建兩個新的鏈表：一個用於小於 x 的節點，一個用於大於等於 x 的節點。
- 遍歷原始鏈表，根據節點值的大小將節點分配到對應的新鏈表。
- 最後將兩個新鏈表連接起來，形成最終的結果。

#### 演算法設計
```
1. 創建兩個空鏈表 smallerHead 和 greaterOrEqualHead，用於存放分別小於 x 和大於等於 x 的節點。
2. 創建兩個指針 smallerPtr 和 greaterOrEqualPtr，分別指向兩個新鏈表的尾部。
3. 遍歷原始鏈表，對於每個節點：
   a. 如果節點值小於 x，將其添加到 smallerPtr 指向的鏈表。
   b. 否則，將其添加到 greaterOrEqualPtr 指向的鏈表。
4. 將 smallerPtr 指向的鏈表末尾連接到 greaterOrEqualHead 的下一個節點。
5. 返回 smallerHead 的下一個節點作為結果鏈表的頭部。
```


#### 實現細節
- 使用虛擬頭節點 (dummy head) 技巧來簡化對鏈表頭部的操作。
- 通過修改 Next 指針來重新連接節點，而不是創建新的節點。
- 注意要將 greaterOrEqualPtr.Next 設置為 nil，防止可能的循環引用。

#### 複雜度分析
- **時間複雜度**: O(n)，其中 n 是鏈表中的節點數。我們只需要遍歷鏈表一次。
- **空間複雜度**: O(1)，我們只使用了固定數量的額外指針，未創建新的節點。

#### 解決方案評估
- 優點：直觀、易於理解和實現。時間複雜度最優。
- 缺點：需要謹慎處理指針操作，特別是在連接兩個鏈表時，以防止出現循環引用或遺漏節點。
- 在面試環境中，這是一個可接受的解決方案，因為它既簡單又高效。

## 6. 範例演練與 Go 實現

### 完整範例追蹤
追蹤範例輸入: head = [1,4,3,2,5,2], x = 3，使用我們的解決方案:

1. 初始狀態:
    - 輸入: head = [1,4,3,2,5,2], x = 3
    - smallerHead = 0 (虛擬頭節點)
    - greaterOrEqualHead = 0 (虛擬頭節點)
    - smallerPtr 指向 smallerHead
    - greaterOrEqualPtr 指向 greaterOrEqualHead

2. 遍歷節點 1:
    - 1 < 3，添加到 smaller 鏈表
    - smallerHead -> 1
    - smallerPtr 指向 1

3. 遍歷節點 4:
    - 4 >= 3，添加到 greaterOrEqual 鏈表
    - greaterOrEqualHead -> 4
    - greaterOrEqualPtr 指向 4

4. 遍歷節點 3:
    - 3 >= 3，添加到 greaterOrEqual 鏈表
    - greaterOrEqualHead -> 4 -> 3
    - greaterOrEqualPtr 指向 3

5. 遍歷節點 2:
    - 2 < 3，添加到 smaller 鏈表
    - smallerHead -> 1 -> 2
    - smallerPtr 指向 2

6. 遍歷節點 5:
    - 5 >= 3，添加到 greaterOrEqual 鏈表
    - greaterOrEqualHead -> 4 -> 3 -> 5
    - greaterOrEqualPtr 指向 5

7. 遍歷節點 2:
    - 2 < 3，添加到 smaller 鏈表
    - smallerHead -> 1 -> 2 -> 2
    - smallerPtr 指向 2

8. 連接兩個鏈表:
    - smallerPtr.Next = greaterOrEqualHead.Next
    - smallerHead -> 1 -> 2 -> 2 -> 4 -> 3 -> 5
    - greaterOrEqualPtr.Next = nil

9. 最終狀態:
    - 輸出: [1,2,2,4,3,5]

### 所有方法的性能比較
```
| 方法            | 時間複雜度 | 空間複雜度 | 範例執行時間 |
|-----------------|-----------|------------|-------------|
| 雙鏈表解決方案   | O(n)      | O(1)       | 0 ms        |
```

## 7. Go 最佳實踐與測試

### Go 符合慣例的解決方案
- 我們的解決方案遵循 Go 的慣例，使用指針來操作鏈表。
- 使用虛擬頭節點來簡化鏈表操作，是一種常見且有效的模式。
- 程式碼結構清晰，命名明確，易於理解和維護。

### 錯誤處理與邊緣情況
- 處理了空鏈表的情況：當 head 為 nil 時，返回 nil。
- 處理了所有節點都小於 x 或都大於等於 x 的情況。
- 確保了最終鏈表正確終止，避免了循環引用的問題

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解決方案提案：~3-5 分鐘
- 優化討論：~2-3 分鐘
- 程式碼編寫：~8-10 分鐘
- 測試與除錯：~3-5 分鐘

### 面試官互動模擬
- 我會這樣向面試官解釋我的 Go 實現：
  "我的解決方案使用兩個虛擬頭節點來創建兩個子鏈表：一個用於小於 x 的節點，另一個用於大於等於 x 的節點。遍歷原始鏈表時，我根據節點值將其分配到對應的子鏈表。最後，我將兩個子鏈表連接起來，形成最終結果。這種方法保持了節點的原始相對順序，時間複雜度為 O(n)，空間複雜度為 O(1)。"

- 可能的問題和解答：
    1. Q: "如何處理環形鏈表的情況？"
       A: "這個解決方案假設輸入是非環形鏈表。若考慮環形鏈表，需要額外的檢測邏輯來避免無限循環。"

    2. Q: "如何優化空間使用？"
       A: "當前解決方案已經是 O(1) 空間複雜度，因為我們只使用了固定數量的指針而沒有創建新節點。我們只是重新連接了原始節點。"

### 潛在的後續問題
- 如果入參是非鏈表結構（如陣列），如何調整解決方案？
- 若節點還包含其他屬性，除了 Val 之外，如何確保所有屬性都被正確處理？
- 如何在不使用虛擬頭節點的情況下實現相同的功能？

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會我如何有效地使用虛擬頭節點來簡化鏈表操作。
- 我更深入地理解了如何在不創建新節點的情況下通過重新連接指針來重組鏈表。
- 需要進一步加強的是複雜鏈表操作中的指針管理和邊緣情況處理。

### 心智模型構建
- 這個問題可以抽象為"分組+保持相對順序"的模式，適用於多種資料結構問題。
- 虛擬頭節點技巧可以應用於許多鏈表操作問題中，特別是那些可能涉及頭節點變化的問題。

### 錯誤模式識別
- 鏈表操作中的常見錯誤是未正確設置尾節點的 Next 指針，導致鏈表不完整或形成環。
- 另一個常見錯誤是忘記更新指針位置，導致節點丟失或再次訪問。

### 知識圖譜擴展
- 相關 Go 程式設計資源：《Effective Go》中有關指針和結構體的章節。
- 更多鏈表操作的進階模式：快慢指針技術、遞迴反轉等。
- 這個實現與 Go 的垃圾回收機制相結合，能夠有效管理記憶體