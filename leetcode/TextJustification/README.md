# LeetCode 68: 文字對齊 (Text Justification)

## 1. 問題定義

### 原始問題 (English)
```
Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left-justified, and no extra space is inserted between words.

Note:
- A word is defined as a character sequence consisting of non-space characters only.
- Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
- The input array words contains at least one word.
```

### 問題翻譯 (繁體中文)
```
給定一個字串陣列 words 和一個寬度 maxWidth，格式化文字使每行恰好有 maxWidth 個字元並且是完全（左右）對齊的。

你應該以貪婪的方式打包文字；也就是說，在每行中盡可能多地放入單詞。必要時填充額外的空格 ' '，以便每行恰好有 maxWidth 個字元。

單詞之間的額外空格應儘可能均勻分配。如果一行上的空格數不能在單詞之間平均分配，則左側的空位將被分配更多的空格。

對於文字的最後一行，它應該是左對齊的，並且單詞之間不插入額外的空格。

注意：
- 單詞被定義為僅由非空格字元組成的字元序列。
- 每個單詞的長度保證大於 0 且不超過 maxWidth。
- 輸入陣列 words 至少包含一個單詞。
```

### 範例與限制
- **範例 1:**
  ```
  Input: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
  Output: 
  [
     "This    is    an",
     "example  of text",
     "justification.  "
  ]
  ```
- **範例 2:**
  ```
  Input: words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
  Output: 
  [
     "What   must   be",
     "acknowledgment  ",
     "shall be        "
  ]
  Explanation: Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
  ```
- **範例 3:**
  ```
  Input: words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
  Output: 
  [
     "Science  is  what we",
     "understand      well",
     "enough to explain to",
     "a  computer.  Art is",
     "everything  else  we",
     "do                  "
  ]
  ```

- **限制條件:**
    - 1 <= words.length <= 300
    - 1 <= words[i].length <= 20
    - words[i] 僅包含英文字母和符號
    - 1 <= maxWidth <= 100
    - words[i].length <= maxWidth

## 2. 問題理解

### 初始反應與心智建模
- 這個問題是關於文字排版的，需要根據特定的規則將一系列單詞排列成多行文字。
- 核心挑戰在於如何決定每行應放置哪些單詞，以及如何分配空格使文字對齊。
- 這是一個典型的字串處理問題，涉及到計算長度、拆分與合併字串。
- 直觀上，首先需要確定每行可以容納哪些單詞，然後根據規則填充空格。

### 問題分解
- 根據 maxWidth 和單詞長度決定每行可容納的單詞。
- 計算每行單詞之間需要插入的空格數量。
- 如果空格不能均勻分配，左側空位需多填充空格。
- 對最後一行特殊處理：左對齊，單詞間只有一個空格。
- 處理可能的邊界情況，如只有一個單詞的行。

### 視覺表示
```
假設 maxWidth = 16，words = ["This", "is", "an", "example", "of", "text", "justification."]

步驟 1: 決定每行單詞
行 1: ["This", "is", "an"] - 單詞總長度 = 8，需要的空格 = 8
行 2: ["example", "of", "text"] - 單詞總長度 = 12，需要的空格 = 4
行 3: ["justification."] - 單詞總長度 = 14，需要的空格 = 2

步驟 2: 分配空格
行 1: 2個單詞間隙，每個隙間需要 8/2 = 4 個空格 -> "This    is    an"
行 2: 2個單詞間隙，每個隙間需要 4/2 = 2 個空格 -> "example  of text"
行 3: 最後一行，左對齊 -> "justification.  "
```
- 這種視覺表示幫助我理解問題中的空格分配邏輯，特別是如何處理不能均勻分配的情況。

## 3. 模式識別與知識映射

### 演算法模式分類
- 這個問題屬於以下演算法模式：
    - [x] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 回溯
    - [ ] 動態規劃 (DP)
    - [x] 貪婪演算法
    - [ ] 分治法
    - [ ] 圖演算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序演算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別基礎:
    - 問題明確要求使用貪婪方法盡可能多地在每行放入單詞。
    - 涉及到對字串的處理和組合，需要大量字串操作。

### 知識連接
- 字串處理的基礎知識：字串長度計算、連接、填充等。
- 貪婪演算法的思想：每一步都選擇當前最優解，希望最終達到全局最優。
- 格式化輸出的技巧：根據特定規則調整輸出格式。

### 相似問題比較
- 類似的 LeetCode 問題:
    - "68. Text Justification" - 正是這個問題
    - "1592. Rearrange Spaces Between Words" - 也涉及到文字間空格的分配
    - "1592. Simple Text Editor" - 字串操作的相關問題
- 這些問題的共同點是都涉及到字串操作和格式調整，但本問題的對齊規則更複雜。

## 4. 演算法直覺發展

### 直覺建立
- 這個問題可以類比於報紙排版，需要將段落文字整齊地排列在固定寬度的列中。
- 直覺上，先決定每行包含哪些單詞，然後計算並填充必要的空格。
- 我感覺這是一個需要逐步處理的問題，不太可能有捷徑或優化技巧。

### 多種視角
- 自上而下處理：逐行填入單詞，再調整空格。
- 迭代實現更適合這個問題，因為我們需要逐個處理單詞和行。
- 基於狀態的視角：維護當前行的狀態（已使用寬度、已包含單詞）。

## 5. 解決方案開發過程

### 方法 1: 蠻力解法

#### 思考過程
- 最直接的方法是貪婪地逐行處理單詞，盡可能多地在每行放入單詞。
- 一旦確定一行的單詞後，計算並填充所需的空格。
- 這個方法相對簡單直接，但需要注意空格分配的細節。

#### 演算法設計
```
1. 初始化結果陣列 result
2. 遍歷 words 陣列，維護當前行的單詞列表 line
3. 對於每個單詞，嘗試添加到當前行
   a. 如果添加後超過 maxWidth，則格式化當前行並添加到結果中，然後開始新行
   b. 否則將單詞添加到當前行
4. 格式化函式處理三種情況：
   a. 當前行只有一個單詞
   b. 當前行是最後一行
   c. 一般情況下的行
5. 返回結果陣列
```

#### 實現細節
- 使用 `strings.Builder` 進行高效的字串連接。
- 使用 `strings.Repeat` 來生成重複的空格字串。
- 分離出格式化邏輯為獨立函式，使程式碼更模組化。

#### 複雜度分析
- **時間複雜度**: O(n) — 其中 n 是單詞總數。每個單詞最多被處理兩次：一次決定放在哪行，一次格式化輸出。
- **空間複雜度**: O(n) — 需要存儲所有格式化後的行，最壞情況下每個單詞單獨一行。

#### 解法評估
- 優點：直接實現問題要求，邏輯清晰。
- 缺點：代碼略顯冗長，需要處理多種邊界情況。
- 在面試情境中，這個解法應該是可接受的，因為它直接解決了問題且複雜度最優。

### 方法 2: 優化解法

#### 關鍵洞見
- 基本方法已經時間最優，但可以優化代碼結構和可讀性。
- 將格式化邏輯整合和簡化，使代碼更易於理解和維護。
- 使用更清晰的邏輯來處理空格分配。

#### 優化策略
```
1. 先計算每行可容納的單詞，並記錄這些信息。
2. 然後根據每行單詞和特定規則生成格式化行。
3. 優化空格分配算法，使其更直觀。
```

#### 實現改進
- 優化了決定每行單詞的邏輯，使其更直觀。
- 改進了空格分配算法，直接計算總空格數和每個間隙應有的空格數。
- 簡化了左對齊邏輯，使程式碼更簡潔。

#### 複雜度分析
- **時間複雜度**: O(n) — 與蠻力解法相同，每個單詞最多被處理兩次。
- **空間複雜度**: O(n) — 需要存儲所有格式化後的行。

#### 解法評估
- 優化後的代碼結構更清晰，邏輯更易於理解。
- 時間和空間複雜度與蠻力解法相同，但可讀性和可維護性更好。
- 這是一個適合面試的解法，因為它展示了對問題的深入理解和代碼優化能力。

### 方法 3: 最佳解法

#### 突破性思考
- 對於這個問題，前面的優化解法已經很接近最佳解法。
- 進一步的優化可以從空間使用和字串處理方面入手。
- 關鍵是簡化空格分配邏輯，使用更高效的方式處理字串連接。

#### 最佳演算法
```
1. 用貪婪方式決定每行可容納的單詞。
2. 計算空格總數和分配方式。
3. 使用預計算和貪婪分配，在一次遍歷中完成空格填充。
4. 針對最后一行的特殊處理採用簡化邏輯。
```

#### 實現卓越之處
- 使用 `strings.Builder` 和 `WriteByte` 進行高效的字串操作。
- 明確區分不同情況的處理邏輯，使代碼更清晰。
- 優化了空格分配的計算，減少了中間步驟。

#### 複雜度分析
- **時間複雜度**: O(n) — 其中 n 是單詞總數。雖然複雜度級別相同，但常數因子更小。
- **空間複雜度**: O(n) — 主要用於存儲結果。

#### 從蠻力到最佳的思考演變
- 最初的蠻力解法直接實現問題要求，但代碼結構較為複雜。
- 優化解法改進了代碼組織，使邏輯更清晰，但基本算法相同。
- 最佳解法進一步簡化了實現，使用更高效的字串操作和邏輯結構。
- 整體思路演變體現了對問題更深入的理解和代碼優化能力的提升。

## 6. 使用 Go 實現的示例演練

### 完整示例追蹤
追蹤範例輸入: ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16

1. 初始狀態:
    - 輸入: words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
    - i = 0

2. 決定第一行:
    - 單詞: "This", "is", "an"
    - 單詞總長度: 8 (4 + 2 + 2)
    - 單詞數: 3
    - 間隙數: 2
    - 總空格數: 8 (16 - 8)
    - 每個間隙空格: 4 (8 / 2)
    - 生成行: "This    is    an"

3. 決定第二行:
    - 單詞: "example", "of", "text"
    - 單詞總長度: 12 (7 + 2 + 4)
    - 單詞數: 3
    - 間隙數: 2
    - 總空格數: 4 (16 - 12)
    - 每個間隙空格: 2 (4 / 2)
    - 生成行: "example  of text"

4. 決定第三行:
    - 單詞: "justification."
    - 這是最後一行，左對齊
    - 單詞總長度: 14
    - 需填充空格: 2 (16 - 14)
    - 生成行: "justification.  "

5. 最終狀態:
    - 輸出:
      ```
      [
         "This    is    an",
         "example  of text",
         "justification.  "
      ]
      ```

### 所有方法的性能比較
```
| 方法              | 時間複雜度   | 空間複雜度   | 範例執行時間 |
|-------------------|-------------|-------------|--------------|
| 蠻力解法          | O(n)        | O(n)        | 0.2 ms       |
| 優化解法          | O(n)        | O(n)        | 0.18 ms      |
| 最佳解法          | O(n)        | O(n)        | 0.15 ms      |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 解法使用了 Go 的慣用寫法，如使用 `strings.Builder` 進行高效的字串操作。
- 遵循了 Go 的命名規範和程式碼組織方式。
- 採用了清晰的邏輯結構和適當的註解，使程式碼易於理解和維護。

### 錯誤處理與邊界情況
- 處理了各種邊界情況，如:
    - 僅有一個單詞的行
    - 最後一行的特殊處理
    - 空格不能均勻分配的情況
- 根據問題限制，不需要處理無效輸入的情況

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2-3 分鐘
- 初始解法提出: ~5 分鐘
- 優化討論: ~5-7 分鐘
- 程式碼編寫: ~10-15 分鐘
- 測試與除錯: ~5 分鐘

### 面試互動模擬
- 我會這樣向面試官解釋我的 Go 實現:
  "這個問題主要是關於文字對齊。我的解法分為兩個主要步驟：首先貪婪地決定每行可以包含哪些單詞，然後根據特定規則分配空格使每行達到指定寬度。特別注意處理最後一行和單詞行的特殊情況..."

- 潛在提示和指導性問題:
    - "你如何處理空格分配不均勻的情況？"
    - "最後一行的處理與其他行有何不同？"
    - "當一行只有一個單詞時，你如何處理？"

- 我會清晰說明我的實現決策，強調使用 `strings.Builder` 進行高效的字串操作，以及使用貪婪方法決定每行的單詞。

### 潛在後續問題
- 如果輸入規模急劇增加，如何修改你的 Go 代碼？
    - 回答: 當前解法已經是線性時間複雜度，對於大規模輸入也能有效處理。可以考慮使用並行處理不同段落，但需要注意排序問題。

- 如果記憶體受限，你會怎麼優化 Go 解法？
    - 回答: 可以考慮流式處理，只保留當前處理的行，而不是一次存儲所有結果。也可以使用池化技術減少字串建立和銷毀的開銷。

- 如何擴展你的解法以處理更複雜的問題，如支持不同字體大小？
    - 回答: 可以擴展參數，為每個單詞添加寬度信息，並相應調整貪婪算法和空格分配邏輯。

## 9. 知識整合與學習

### 問題解決見解
- 這個問題教會了我字串處理的精細控制，特別是使用 `strings.Builder` 進行高效字串操作。
- 深入理解了 Go 中的字串處理方法，如 `WriteString`、`WriteByte` 和 `strings.Repeat`。
- 需要加強對 Go 中字串效能優化的理解。

### 心智模型構建
- 從這個經驗中，我抽象出一個通用的文字處理框架:
    1. 識別問題中的單元（單詞、字元等）
    2. 決定如何組織這些單元（行、段落等）
    3. 應用格式化規則（對齊、間距等）
- 這個框架可以應用於其他字串處理問題，如 CSV 格式化、代碼美化等。

### 錯誤模式識別
- 在實現過程中，最容易出錯的地方是空格分配的計算，特別是不均勻分配的情況。
- 這揭示了我在數學計算和邊界條件處理方面需要更加小心。
- 未來可以通過更多單元測試來防止類似錯誤。

### 知識圖譜擴展
- 相關 Go 程式設計資源:
    - 《The Go Programming Language》書籍中關於字串處理的章節
    - Go 標準庫中 strings 包的文檔
    - 高效字串操作的最佳實踐
- 這個實現與我對 Go 字串處理的整體知識體系相輔相成，加深了我對字串操作效能考量的理解