## 1. Original Problem

### English
Given the head of a linked list, remove the nth node from the end of the list and return its head.

### 繁體中文
給定一個鏈表的頭節點，刪除鏈表的倒數第 n 個節點，並且返回鏈表的頭節點。

### Examples

**Example 1:**
```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**
```
Input: head = [1], n = 1
Output: []
```

**Example 3:**
```
Input: head = [1,2], n = 1
Output: [1]
```

### Constraints
- The number of nodes in the list is sz.
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz

## 2. 問題理解

這個問題要求我們從鏈表的末尾開始計數，刪除第 n 個節點。關鍵點如下：

1. 我們需要找到鏈表中倒數第 n 個節點，並將其刪除
2. 刪除節點後，需要返回新的鏈表頭
3. 特殊情況：
    - 當鏈表只有一個節點，且 n = 1 時，返回空鏈表
    - 當刪除的是頭節點（即倒數第 n 個節點是頭節點）時，需要特別處理

這個問題的挑戰在於：鏈表只能從前往後遍歷，而我們需要刪除從後往前數的節點。因此，我們不能直接得知倒數第 n 個節點的位置。

鏈表的節點結構：
```go
type ListNode struct {
    Val int
    Next *ListNode
}
```

## 3. 視覺解釋

讓我們通過一個例子來視覺化理解這個問題：

假設我們有一個鏈表：1 -> 2 -> 3 -> 4 -> 5，需要刪除倒數第 2 個節點。

```
初始鏈表：
1 -> 2 -> 3 -> 4 -> 5 -> nil
                 ^
                 |
              要刪除的節點（倒數第 2 個）
```

刪除節點後的鏈表：
```
1 -> 2 -> 3 -> 5 -> nil
```

為了刪除這個節點，我們需要找到節點 3（即倒數第 2 個節點的前一個節點），然後將其 Next 指針指向節點 5。

## 4. 思考過程

解決這個問題，我們可以考慮幾種方法：

### 方法一：兩次遍歷
1. 第一次遍歷計算鏈表的長度 len
2. 第二次遍歷到第 (len-n) 個節點，將其刪除

這種方法簡單明瞭，但需要遍歷鏈表兩次。

### 方法二：一次遍歷（雙指針法）
使用兩個指針，快指針和慢指針：
1. 快指針先走 n 步
2. 然後快慢指針一起走，當快指針到達鏈表末尾時，慢指針正好在倒數第 n 個節點的前一個位置
3. 修改慢指針的 Next 指向，完成刪除操作

這種方法只需遍歷一次鏈表，效率更高。

### 方法三：使用遞迴
通過遞迴函數返回當前節點的位置（從尾部數起），當位置為 n 時刪除該節點。

對於這個問題，方法二（雙指針）是最優的選擇，因為它既高效（只需一次遍歷）又直觀易懂。

## 5. 最佳解決方案開發

讓我們採用雙指針方法來解決這個問題：

1. 創建一個虛擬頭節點（dummy node），連接到原始鏈表的頭部。這樣可以統一處理所有情況，包括刪除頭節點的情況。
2. 設置兩個指針 fast 和 slow，初始都指向虛擬頭節點。
3. 先讓 fast 指針前進 n 步。
4. 然後 fast 和 slow 同時前進，直到 fast 指向鏈表的最後一個節點。
5. 此時，slow 指向要刪除節點的前一個節點，執行刪除操作：`slow.Next = slow.Next.Next`。
6. 返回虛擬頭節點的下一個節點作為新的頭節點。

讓我們看一個具體的例子，假設鏈表是 [1,2,3,4,5]，n = 2：

```
初始狀態：
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
fast^
slow^

步驟1：fast 前進 n 步
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
          fast^
slow^

步驟2：fast 和 slow 同時前進，直到 fast 到達最後一個節點
dummy -> 1 -> 2 -> 3 -> 4 -> 5 -> nil
                         fast^
               slow^

步驟3：執行刪除操作，slow.Next = slow.Next.Next
dummy -> 1 -> 2 -> 3 -> 5 -> nil
                   
步驟4：返回 dummy.Next 作為新的頭節點
1 -> 2 -> 3 -> 5 -> nil
```

## 7. 複雜度分析

### 時間複雜度
- 我們只需遍歷鏈表一次，快慢指針各自移動一次。
- 因此，時間複雜度為 O(L)，其中 L 是鏈表的長度。

### 空間複雜度
- 我們只使用了常數個額外變數（dummy, fast, slow）。
- 因此，空間複雜度為 O(1)。

## 8. 優化與改進

這個解決方案已經相當優化，因為：
1. 只需遍歷鏈表一次（時間複雜度 O(L)）
2. 只使用常數額外空間（空間複雜度 O(1)）

不過，我們可以考慮一些邊界情況：
- 如果鏈表為空，我們的解決方案會直接返回 dummy.Next，即 nil。
- 如果 n 超出了鏈表長度，根據題目約束，這種情況不會發生。

另一種解決方案是使用遞迴方法，但這會增加空間複雜度到 O(L)（因為遞迴調用堆棧），所以雙指針法是更優選擇。

## 9. 測試策略

這個測試涵蓋了多種情況：
1. 移除中間節點
2. 移除鏈表中唯一的節點
3. 移除尾節點
4. 移除頭節點
5. 在較長的鏈表中移除節點

通過這些測試可以確保我們的解決方案在各種情況下都能正確運作。

## 總結

這個問題的關鍵是如何在單向鏈表中找到倒數第 n 個節點。我們使用雙指針方法，通過讓快指針先走 n 步，然後快慢指針一起走，當快指針到達鏈表末尾時，慢指針剛好位於要刪除節點的前一個位置，從而可以進行刪除操作。

這種方法的優點是：
1. 只需遍歷鏈表一次，時間複雜度為 O(L)
2. 只使用常數額外空間，空間複雜度為 O(1)
3. 通過引入虛擬頭節點，統一處理所有情況，包括刪除頭節點的特殊情況