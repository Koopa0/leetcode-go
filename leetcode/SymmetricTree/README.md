# LeetCode 101: 對稱二元樹 (Symmetric Tree)

## 1. 問題定義

### 原始問題 (英文)
```
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true

Example 2:
Input: root = [1,2,2,null,3,null,3]
Output: false

Constraints:
- The number of nodes in the tree is in the range [1, 1000].
- -100 <= Node.val <= 100
```

### 問題翻譯 (繁體中文)
```
給定一個二元樹的根節點，檢查它是否是自身的鏡像（即圍繞其中心對稱）。

範例 1:
輸入: root = [1,2,2,3,4,4,3]
輸出: true

範例 2:
輸入: root = [1,2,2,null,3,null,3]
輸出: false

限制條件:
- 樹中的節點數量範圍在 [1, 1000] 之間。
- -100 <= 節點值 <= 100
```

### 範例與限制條件
- **範例 1:**
  ```
  輸入: root = [1,2,2,3,4,4,3]
  輸出: true
  解釋: 這棵樹在視覺上呈現為:
       1
      / \
     2   2
    / \ / \
   3  4 4  3
  可以看出，它圍繞中心是對稱的。
  ```
- **範例 2:**
  ```
  輸入: root = [1,2,2,null,3,null,3]
  輸出: false
  解釋: 這棵樹在視覺上呈現為:
       1
      / \
     2   2
      \   \
       3   3
  可以看出，它不是圍繞中心對稱的。
  ```

- **限制條件:**
    - 樹中的節點數量範圍在 [1, 1000] 之間。
    - -100 <= 節點值 <= 100

## 2. 問題理解

### 初始反應與心智建模
- 第一反應：這是一個關於樹結構對稱性的問題，要判斷一棵二元樹是否關於中心軸對稱。
- 範例解釋：當我們視覺化這些樹，第一個範例中的樹從中間切開後，左右兩邊形成了鏡像；而第二個範例則不是鏡像。
- 輸入輸出與轉換：輸入是一個二元樹的根節點，輸出是一個布林值，表示這棵樹是否對稱。
- 視覺化：需要考慮樹的結構以及節點的值，兩者都必須對稱才算是對稱樹。

### 問題分解
- 核心子問題：如何判斷兩個子樹是否互為鏡像？
- 本質操作：比較左子樹的左節點與右子樹的右節點，以及左子樹的右節點與右子樹的左節點。
- 邊界情況：空樹、只有根節點的樹、不完全二元樹等情況需要特別處理。
- 問題拆解：可以將問題拆解為比較兩棵子樹是否鏡像對稱的子問題。

### 視覺表示
```
對稱樹示例：
       1
      / \
     2   2
    / \ / \
   3  4 4  3

非對稱樹示例：
       1
      / \
     2   2
      \   \
       3   3
```
- 這個視覺化幫助我們理解對稱的本質：對於左子樹的每個節點，右子樹都有一個相應的鏡像位置節點，且值相同。
- 從視覺模型中可以得出的模式：要檢查整棵樹是否對稱，需要從根節點開始，比較左子樹和右子樹是否互為鏡像。

## 3. 模式識別與知識對應

### 演算法模式分類
- 這個問題屬於以下常見演算法模式：
    - [x] 樹問題
    - [x] 深度優先搜尋 (DFS)
    - [ ] 廣度優先搜尋 (BFS)
    - [ ] 其他

- 識別基礎：
    - 問題直接涉及二元樹的結構檢查，屬於典型的樹問題。
    - 需要遍歷整棵樹並進行比較，可以使用深度優先搜尋。
    - 也可以使用廣度優先搜尋層序遍歷樹，進行層級比較。

### 知識連接
- 涉及的基本資訊科學概念：二元樹、樹的遍歷、遞迴、對稱性。
- 這個問題與樹的前序、中序、後序遍歷有關，但需要自定義遍歷順序來比較對稱性。
- 需要應用的理論知識：樹結構的遞迴性質，以及如何利用遞迴解決樹問題。

### 相似問題比較
- 類似的 LeetCode 問題：
    - LeetCode 100：Same Tree（相同的樹）
    - LeetCode 226：Invert Binary Tree（翻轉二元樹）
    - LeetCode 572：Subtree of Another Tree（另一個樹的子樹）
- 相似之處：都涉及樹的結構比較和遍歷。
- 差異之處：對稱樹問題需要比較的是鏡像關係，而不是完全相同的結構。

## 4. 演算法直覺發展

### 直覺建立
- 現實生活類比：就像照鏡子，左手在鏡中變成右手，右手變成左手，但手的形狀和特徵保持不變。
- 初步想法：可以同時遍歷左右子樹，但遍歷順序相反，然後比較對應位置的節點值。
- 直覺驗證：使用範例測試這個想法，確保它能處理所有情況，包括空節點。

### 多角度思考
- 不同角度的方法：
    - 遞迴方法：同時比較左右子樹對應的節點。
    - 迭代方法：使用堆疊或佇列進行非遞迴遍歷。
    - 層序遍歷：逐層檢查對稱性。
- 最有希望的方法：遞迴方法最直觀，迭代方法可能在效能上有優勢，尤其是在樹很深的情況下。

## 5. 解決方案發展歷程

### 方法一：遞迴解法

#### 思考過程
- 最直接的方法是使用遞迴。
- 從根節點開始，分別檢查左右子樹。
- 對於左子樹的左節點，比較右子樹的右節點；對於左子樹的右節點，比較右子樹的左節點。

#### 演算法設計
```
1. 如果樹為空，返回 true（空樹被視為對稱）
2. 否則，調用輔助函數 isMirror 來檢查左右子樹是否互為鏡像
3. isMirror 函數：
   a. 如果兩個節點都為空，返回 true
   b. 如果一個節點為空而另一個不為空，返回 false
   c. 如果兩個節點的值不相等，返回 false
   d. 遞迴檢查：第一個節點的左子樹與第二個節點的右子樹，以及第一個節點的右子樹與第二個節點的左子樹
```

#### 實作細節
- 使用的 Go 資料結構：TreeNode 結構體表示二元樹節點。
- Go 習慣用法：遞迴函數分離，使主函數簡潔明了。
- 潛在實作陷阱：處理空節點的情況，確保在比較之前進行空檢查。

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是樹中的節點數。每個節點訪問一次。
- **空間複雜度**：O(h)，其中 h 是樹的高度。在最壞情況下（樹呈線性），可能達到 O(n)。

#### 解法評估
- 優點：簡單易懂，直接實現對稱的定義。
- 缺點：對於深度很大的樹，可能導致堆疊溢出。
- 面試情境：這是一個穩健且直觀的解法，適合面試中優先提出。

### 方法二：迭代解法（使用佇列）

#### 關鍵洞見
- 遞迴解法隱含使用了調用堆疊，我們可以顯式使用佇列或堆疊來避免遞迴。
- 使用佇列可以同時處理兩個節點，實現層序遍歷的效果。
- 冗餘操作削減：採用迭代方式，避免深層遞迴造成的堆疊開銷。

#### 最佳化策略
```
1. 初始化一個佇列，將左右子樹的根節點入佇列
2. 當佇列不為空時：
   a. 取出兩個節點
   b. 如果兩個都是 null，繼續
   c. 如果一個是 null 而另一個不是，返回 false
   d. 如果兩個節點的值不相等，返回 false
   e. 將左節點的左子節點和右節點的右子節點入佇列
   f. 將左節點的右子節點和右節點的左子節點入佇列
3. 如果循環正常結束，返回 true
```

#### 實作改進
- 利用了 Go 的切片作為佇列，使用 append 和切片操作進行入佇列和出佇列。
- 相比遞迴版本，避免了深度遞迴可能導致的堆疊溢出問題。
- 使用廣度優先遍歷的方式處理樹，逐層比較對稱性。

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是樹中的節點數。每個節點仍然只訪問一次。
- **空間複雜度**：O(w)，其中 w 是樹的最大寬度。在最壞情況下，佇列可能包含樹中的一半節點，空間複雜度約為 O(n)。

#### 解法評估
- 為什麼這種最佳化有效：避免了遞迴堆疊溢出的風險，特別是對於深度很大的樹。
- 哪些情況下特別有價值：當樹很深且不平衡時，迭代解法比遞迴更可靠。
- 權衡：實作上略微複雜，但在大規模輸入下更穩定。

### 方法三：層序遍歷檢查對稱性

#### 突破性思考
- 關鍵洞見：對稱樹的每一層，從左到右讀和從右到左讀應該是相同的。
- 如何發現這一洞見：觀察對稱樹的視覺表示，發現每一層的節點形成回文序列。
- 這一洞見如何根本性地改變解法：可以逐層檢查，而不是遞迴地比較子樹。

#### 最佳演算法
```
1. 使用廣度優先搜尋 (BFS) 逐層遍歷樹
2. 對於每一層，建立一個包含該層所有節點值的列表（空節點記為特殊值）
3. 檢查每一層的列表是否為回文序列
4. 如果所有層都是回文序列，則樹是對稱的
```

#### 實作卓越性
- 此 Go 實作使用 interface{} 類型處理可能為 nil 的節點值。
- 利用 Go 的切片特性，簡化了層序遍歷的實作。
- 保持程式碼可讀性的同時，實現了高效的演算法。

#### 複雜度分析
- **時間複雜度**：O(n)，其中 n 是樹中的節點數。每個節點訪問一次，額外對每層進行回文檢查。
- **空間複雜度**：O(w)，其中 w 是樹的最大寬度。在最壞情況下，可能需要存儲最寬一層的所有節點，約為 O(n/2) = O(n)。

#### 從暴力解法到最佳解法的思考演進
- 思考如何逐步演變：從最初的遞迴比較兩個子樹，到使用明確的佇列避免遞迴，再到基於層的對稱性檢查。
- 每個最佳化階段解決的問題：遞迴解決基本問題，迭代解決堆疊溢出風險，層序遍歷提供另一種思考角度。
- Go 實作如何反映這種演變：從簡單的遞迴函數到更複雜的資料結構使用。
- 這種思考模式如何應用於其他問題：先想最直接的解法，再考慮效能改進和替代思路。

## 6. 使用 Go 實作的範例演練

### 完整範例追蹤
追蹤範例輸入：`[1,2,2,3,4,4,3]` 使用我們的最佳解法（遞迴解法）：

1. 初始狀態：
    - 輸入：`root = [1,2,2,3,4,4,3]`
    - 呼叫 `isSymmetric(root)`

2. 第一步：檢查根節點
    - 根節點不為 nil，呼叫 `isMirror(root.Left, root.Right)`
    - `root.Left` 是值為 2 的節點，`root.Right` 是值為 2 的節點

3. 檢查第二層節點：
    - 兩個節點都不為 nil，且值都是 2，進行下一步遞迴
    - 遞迴 `isMirror(left.Left, right.Right)`：比較左子樹的左節點 (3) 與右子樹的右節點 (3)
    - 遞迴 `isMirror(left.Right, right.Left)`：比較左子樹的右節點 (4) 與右子樹的左節點 (4)

4. 檢查第三層節點：
    - 左子樹的左節點和右子樹的右節點都是 3，相等
    - 左子樹的右節點和右子樹的左節點都是 4，相等
    - 這些節點沒有子節點，所以遞迴到葉節點，返回 true

5. 最終狀態：
    - 輸出：`true`

### 所有方法的效能比較
```
| 方法             | 時間複雜度 | 空間複雜度 | 範例運行時間 |
|------------------|------------|------------|--------------|
| 遞迴解法         | O(n)       | O(h)       | 0 ms         |
| 佇列迭代解法     | O(n)       | O(w)       | 0 ms         |
| 層序遍歷解法     | O(n)       | O(w)       | 0 ms         |
```

## 7. Go 最佳實踐與測試

### Go 習慣性解法
- 我的解決方案遵循 Go 最佳實踐：使用清晰的函數名稱，適當的註解，以及 Go 的慣用控制結構。
- 使用的 Go 特定模式：利用零值、多返回值和明確的錯誤處理。
- 如何確保整潔、可維護的 Go 程式碼：函數職責單一，邏輯流程清晰，變數命名有意義。

### 錯誤處理與邊界情況
- 在 Go 實作中如何處理潛在錯誤：檢查空指針，避免越界訪問。
- 需要特別注意的邊界情況：空樹、只有根節點的樹、不平衡的樹。
- 解決方案對意外輸入的穩健性：通過明確處理空節點和各種樹結構，確保穩健性。

## 8. 面試模擬

### 時間管理規劃
- 問題理解：~2-3 分鐘
- 初始解法提案：~5 分鐘
- 最佳化討論：~5-7 分鐘
- 程式碼編寫：~10-15 分鐘
- 測試和除錯：~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實作：
  "我首先提出了一個遞迴解法，直接比較左右子樹的對應節點。然後我發展了兩種替代方法：一種使用佇列的迭代解法，可以避免深度遞迴；另一種是基於層序遍歷的解法，檢查每一層是否形成回文序列。"
- 潛在提示和引導問題：
    - "你如何處理空節點的情況？"
    - "在最壞情況下，這些解法的空間複雜度是多少？"
    - "你的解法如何處理高度不平衡的樹？"
- 如何清晰地溝通我的實作決策：
  強調每種方法的優缺點，並解釋為什麼選擇特定的資料結構和演算法模式。

### 潛在後續問題
- 如果輸入規模大幅增加，您如何修改 Go 程式碼？
  答：對於非常大的樹，我會選擇迭代解法，避免堆疊溢出風險。也可以考慮使用工作池並行處理不同子樹的比較。
- 如果記憶體受限，您會應用哪些 Go 特定最佳化？
  答：使用指針而非值傳遞，避免不必要的記憶體分配，考慮使用固定大小的緩衝區而非無限增長的切片。
- 如何擴展您的解決方案以處理相關但更複雜的問題？
  答：例如，可以擴展為檢查「近似對稱」的樹，允許某些節點值有小的差異，或者檢查子樹的對稱性。

## 9. 知識整合與學習

### 問題解決洞見
- 這個問題教會我的 Go 實作技巧：處理樹結構、遞迴與迭代的轉換、使用介面型別處理 nil 值。
- 現在更深入理解的 Go 程式設計概念：切片操作、指針處理、遞迴控制流程。
- 需要進一步加強的 Go 知識領域：更進階的並行處理技術，以處理大規模樹結構。

### 心智模型建構
- 從這次經驗中抽象出的一般問題解決框架：
    1. 首先考慮最直觀的解法（通常是遞迴）
    2. 識別遞迴解法中的潛在問題（如堆疊溢出）
    3. 開發迭代替代方案
    4. 思考問題的另一種視角（如層級對稱性）
- 這個框架如何應用於其他問題類型：對於其他樹問題，可以採用類似的思考過程，先考慮遞迴，再考慮迭代。
- 如何將這次經驗內化為直覺：通過多練習相似問題，建立對樹結構模式的直覺識別能力。

### 錯誤模式識別
- 在 Go 實作過程中出現的錯誤：可能忘記處理 nil 指針、誤解切片操作、忽略特殊邊界情況。
- 這些錯誤揭示的 Go 程式設計盲點：對 nil 的處理、介面值比較、記憶體管理。
- 如何預防未來實作中的類似錯誤：建立更完善的測試流程，包括邊界情況測試。