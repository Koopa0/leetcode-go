# LeetCode 93: 復原 IP 地址

## 1. 問題定義

### 原始問題 (英文)
```
Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.

A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.
```

### 問題翻譯 (繁體中文)
```
給定一個只包含數字的字串 s，返回所有可以從 s 中獲得的有效 IP 地址。你可以按任意順序返回它們。

一個有效的 IP 地址由四個整數組成，每個整數在 0 到 255 之間，由單個點分隔，且不能有前導零。例如，"0.1.2.201" 和 "192.168.1.1" 是有效的 IP 地址，而 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是無效的 IP 地址。
```

### 範例與限制
- **範例 1:**
  ```
  輸入: s = "25525511135"
  輸出: ["255.255.11.135","255.255.111.35"]
  ```
- **範例 2:**
  ```
  輸入: s = "0000"
  輸出: ["0.0.0.0"]
  ```
- **範例 3:**
  ```
  輸入: s = "101023"
  輸出: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
  ```

- **限制:**
    - 0 <= s.length <= 20
    - s 只包含數字

## 2. 問題理解

### 初始反應與心智建模
- 這個問題要求我們將一個純數字字串分割成有效的 IP 地址。
- IP 地址由四個整數組成，每個整數介於 0-255 之間，並由點分隔。
- 關鍵限制是不能有前導零（如 "01" 是無效的），但單個 "0" 是有效的。
- 這似乎是一個需要嘗試各種分割方式的問題，可能需要回溯法。
- 我需要尋找所有可能的有效分割方式，而不僅僅是一種解法。

### 問題分解
- 核心子問題：如何在一個字串中插入三個點，使得形成的四個部分都是有效的 IP 地址整數部分。
- 必須確保每個部分都符合以下條件：
    1. 數值在 0-255 之間
    2. 沒有不必要的前導零（單個 "0" 是允許的）
- 需要考慮的邊界情況：
    1. 字串長度太短（小於 4）
    2. 字串長度太長（超過 12，因為 IP 地址最多有 12 位數字）
    3. 特殊情況如全是零的字串

### 視覺表示
```
例如，對於字串 "25525511135"：

可能的分割：
2.5.5.25511135 (無效，最後一部分太大)
2.5.52.5511135 (無效，最後一部分太大)
...
255.255.11.135 (有效)
255.255.111.35 (有效)
...
```

## 3. 模式識別與知識映射

### 算法模式分類
- 此問題屬於以下常見算法模式：
    - [ ] 陣列/字串操作
    - [ ] 雙指針/滑動窗口
    - [ ] 二分搜尋/二分答案
    - [ ] 深度優先搜尋 (DFS)
    - [x] 回溯法
    - [ ] 動態規劃 (DP)
    - [ ] 貪心算法
    - [ ] 分治法
    - [ ] 圖算法
    - [ ] 樹問題
    - [ ] 堆疊/佇列
    - [ ] 優先佇列/堆
    - [ ] 雜湊表/集合
    - [ ] 排序算法
    - [ ] 位元操作
    - [ ] 其他: ________

- 識別基礎：
    - 問題要求找到所有可能的解，這是回溯法的典型特徵。
    - 我們需要嘗試所有可能的分割方式，並在遇到無效分割時回溯。
    - 需要系統性地探索決策樹，這適合使用深度優先搜尋和回溯法。

### 知識連接
- 這個問題涉及字串操作、字串分割和回溯法。
- 回溯法是一種系統性地嘗試所有可能解的方法，類似於深度優先搜尋。
- 需要理解 IP 地址的規則和限制。

### 相似問題比較
- LeetCode 131: 分割回文串 - 同樣需要找出所有可能的字串分割方式。
- LeetCode 17: 電話號碼的字母組合 - 使用回溯法生成所有可能的組合。
- LeetCode 22: 括號生成 - 使用回溯法生成有效的括號組合。

## 4. 算法直覺發展

### 直覺建立
- 由於 IP 地址只有四個部分，我們可以嘗試所有可能的方式來放置三個點。
- 當我們放置一個點時，我們需要確認當前部分是否有效。如果有效，繼續嘗試放置下一個點；如果無效，則回溯並嘗試其他位置。
- 由於每個 IP 部分最多三位數字，我們每次只需嘗試在當前位置後的 1、2 或 3 個字處放置點。

### 多角度思考
- 自上而下 vs. 自下而上：在這個問題中，自上而下的方法更自然，我們從起始位置開始，逐步構建 IP 地址。
- 迭代 vs. 遞迴：遞迴實現更符合回溯法的本質，但也可以用迭代方式實現。
- 以狀態為基礎 vs. 以轉換為基礎：我們可以將問題視為狀態轉移，每次決定是否在某個位置放置點。

## 5. 解決方案開發過程

### 方法 1: 回溯法

#### 思路過程
- 最直觀的方法是使用回溯法嘗試所有可能的分割方式。
- 從字串的第一個字開始，嘗試將其解析為 IP 地址的第一部分。
- 如果該部分有效，則遞迴地處理剩餘部分；如果無效，則回溯並嘗試其他分割。
- 當我們成功分割出四個有效部分且用完了所有字時，我們找到了一個有效的 IP 地址。

#### 算法設計
```
1. 創建一個回溯函數，接收當前處理的字串位置、已形成的 IP 部分數量和當前已構建的 IP。
2. 如果已經形成了 4 個 IP 部分且用完了所有字，將其添加到結果列表中。
3. 如果已經形成了 4 個 IP 部分但還有剩餘字，或者字用完但還未形成 4 個 IP 部分，則返回。
4. 嘗試從當前位置取 1、2 或 3 個字作為 IP 的一部分：
   a. 檢查該部分是否有效（0-255 之間且沒有前導零）。
   b. 如果有效，將該部分添加到當前 IP 中，並遞迴處理剩餘部分。
   c. 回溯，嘗試其他分割方式。
```

#### 實現細節
- 使用 Go 的字串切片操作來獲取 IP 的各個部分。
- 使用 `strconv.Atoi` 將字串轉換為整數以進行有效性檢查。
- 注意回溯時的狀態管理，確保正確添加和移除點。
- 使用指針傳遞結果列表，以便在遞迴過程中修改。

#### 複雜度分析
- **時間複雜度**: O(3^4) = O(81) — 在最壞情況下，我們在字串中嘗試插入三個點，每個點有三種可能的位置（在前 1、2 或 3 個字之後）。
- **空間複雜度**: O(n) — 我們需要存儲中間結果和遞迴調用棧，其中 n 是輸入字串的長度。

#### 解決方案評估
- 優點：實現直觀，易於理解，可以找到所有可能的解。
- 缺點：可能存在一些冗余的檢查，但由於問題規模小（最多 12 個字），這不是主要問題。
- 在面試環境中，這是一個可接受的解決方案，展示了對回溯法的理解。

### 方法 2: 迭代法

#### 關鍵洞察
- 由於 IP 地址只有四個部分，且每部分最多 3 位數字，我們可以直接用四層嵌套迴圈嘗試所有可能的分割位置。
- 這樣可以避免遞迴和回溯的開銷，但邏輯上與回溯法相同。

#### 優化策略
```
1. 使用四層嵌套迴圈，分別表示 IP 地址四個部分的結束位置。
2. 檢查每個部分是否有效。
3. 如果所有四個部分都有效且用完了所有字，則將構建的 IP 地址添加到結果中。
```

#### 實現改進
- 使用輔助函數 `isValidPart` 來檢查 IP 地址的每個部分是否有效，使代碼更簡潔。
- 直接構建最終的 IP 地址字串，避免了回溯法中的字串拼接和刪除操作。
- 明確的邊界檢查，確保不會嘗試無效的分割位置。

#### 複雜度分析
- **時間複雜度**: O(n^3) — 三層嵌套迴圈，每層最多循環 3 次。
- **空間複雜度**: O(1) — 只需要固定的額外空間來存儲中間變數。

#### 解決方案評估
- 優點：避免了遞迴調用的開銷，實現更直接，更易於理解。
- 缺點：代碼較為冗長，不如回溯法那麼通用和可擴展。
- 在面試環境中，這也是一個很好的解決方案，展示了對問題的深入理解和不同的解決思路。

## 6. 範例演示

### 完整範例追蹤
追蹤輸入範例: "25525511135" 使用迭代法的過程:

1. 嘗試 a=1, b=2, c=3:
    - s1 = "2", s2 = "5", s3 = "5", s4 = "25511135"
    - s1, s2, s3 有效，但 s4 無效（超過 255）

2. 嘗試 a=1, b=2, c=4:
    - s1 = "2", s2 = "5", s3 = "52", s4 = "5511135"
    - s1, s2, s3 有效，但 s4 無效（超過 255）

... [中間過程省略] ...

3. 嘗試 a=3, b=6, c=8:
    - s1 = "255", s2 = "255", s3 = "11", s4 = "135"
    - 所有部分都有效
    - 添加 "255.255.11.135" 到結果中

4. 嘗試 a=3, b=6, c=9:
    - s1 = "255", s2 = "255", s3 = "111", s4 = "35"
    - 所有部分都有效
    - 添加 "255.255.111.35" 到結果中

... [繼續檢查其他可能性] ...

5. 最終結果: ["255.255.11.135", "255.255.111.35"]

### 所有方法的性能比較
```
| 方法          | 時間複雜度    | 空間複雜度  | 範例運行時間  |
|--------------|-------------|------------|-------------|
| 回溯法        | O(3^4)      | O(n)       | < 1 ms     |
| 迭代法        | O(n^3)      | O(1)       | < 1 ms     |
```

## 7. Go 最佳實踐與測試

### Go 慣用解法
- 在回溯法實現中，我們使用指針傳遞結果列表，這是 Go 中處理遞迴修改的常見做法。
- 使用 Go 的 `strconv.Atoi` 函數進行字串到整數的轉換。
- 保持代碼結構清晰，使用有意義的變數名和註釋。

### 錯誤處理與邊界情況
- 在函數開始進行邊界檢查，快速排除無效輸入。
- 在 `isValidPart` 輔助函數中，全面檢查部分的有效性。
- 仔細考慮 IP 地址規則中的特殊情況，例如處理前導零。

## 8. 面試模擬

### 時間管理規劃
- 問題理解: ~2-3 分鐘
- 初始解法提案: ~5 分鐘
- 優化討論: ~5-7 分鐘
- 代碼編寫: ~10-15 分鐘
- 測試與調試: ~5 分鐘

### 面試官互動模擬
- 如何向面試官解釋我的 Go 實現:
  "我使用回溯法來處理這個問題，因為它要求找到所有可能的解。回溯法允許我系統性地嘗試所有可能的分割位置，並在發現無效分割時及時回溯。"

- 潛在的提示和引導問題:
    - 問: "如何優化這個解決方案？"
      答: "由於 IP 地址只有四個部分，且每部分有明確的限制，我們可以使用迭代法直接嘗試所有可能的分割位置，避免遞迴和回溯的開銷。"

    - 問: "如何處理前導零的情況？"
      答: "我檢查每個部分的長度和首字。如果長度大於 1 且首字為 '0'，則該部分無效。這樣處理了前導零的規則，同時允許單個 '0' 作為有效值。"

### 潛在的後續問題
- 如果輸入規模劇增，你如何修改你的 Go 程式碼？
    - 對於這個問題，輸入規模受到 IP 地址格式的限制（最多 12 位數字），所以現有的解決方案已經是最優的。

- 如果內存受限，你會如何應用 Go 特定的優化？
    - 可以使用迭代法減少遞迴棧的開銷。
    - 減少中間字串拼接操作，直接在最終確認有效的 IP 地址時才構建完整字串。

- 如何擴展你的解決方案以處理相關但更複雜的問題，如 IPv6 地址？
    - 需要修改有效性檢查的邏輯以符合 IPv6 規範。
    - 可能需要處理十六進制數字和不同的分隔符。
    - 使用回溯法的基本架構仍然適用，但需要調整具體的實現細節。

## 9. 知識整合與學習

### 問題解決的洞察
- 這個問題強化了我對回溯法的理解，特別是如何有效地處理約束條件。
- 學習了在 Go 中高效實現回溯法的方式，包括如何管理狀態和結果。
- 理解了如何將一個問題分解成更簡單的子問題進行處理。

### 心智模型構建
- 從這個問題中，我總結出一個用於字串分割問題的框架:
    1. 識別有效部分的規則
    2. 系統性地嘗試不同的分割方式
    3. 在發現無效分割時及時回溯
    4. 收集所有有效的解

### 錯誤模式識別
- 容易忽略的錯誤:
    1. 沒有正確處理前導零的情況
    2. 沒有確保用完所有字
    3. 在遞迴回溯時沒有正確管理當前狀態